
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model ProfileSettings
 * 
 */
export type ProfileSettings = $Result.DefaultSelection<Prisma.$ProfileSettingsPayload>
/**
 * Model FriendRequest
 * 
 */
export type FriendRequest = $Result.DefaultSelection<Prisma.$FriendRequestPayload>
/**
 * Model Friendship
 * 
 */
export type Friendship = $Result.DefaultSelection<Prisma.$FriendshipPayload>
/**
 * Model Clan
 * 
 */
export type Clan = $Result.DefaultSelection<Prisma.$ClanPayload>
/**
 * Model ProfileClan
 * 
 */
export type ProfileClan = $Result.DefaultSelection<Prisma.$ProfileClanPayload>
/**
 * Model Lineage
 * 
 */
export type Lineage = $Result.DefaultSelection<Prisma.$LineagePayload>
/**
 * Model LineageMembership
 * 
 */
export type LineageMembership = $Result.DefaultSelection<Prisma.$LineageMembershipPayload>
/**
 * Model Kinship
 * 
 */
export type Kinship = $Result.DefaultSelection<Prisma.$KinshipPayload>
/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model Mute
 * 
 */
export type Mute = $Result.DefaultSelection<Prisma.$MutePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model MediaFile
 * 
 */
export type MediaFile = $Result.DefaultSelection<Prisma.$MediaFilePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model PostReaction
 * 
 */
export type PostReaction = $Result.DefaultSelection<Prisma.$PostReactionPayload>
/**
 * Model CommentReaction
 * 
 */
export type CommentReaction = $Result.DefaultSelection<Prisma.$CommentReactionPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationParticipant
 * 
 */
export type ConversationParticipant = $Result.DefaultSelection<Prisma.$ConversationParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Interest
 * 
 */
export type Interest = $Result.DefaultSelection<Prisma.$InterestPayload>
/**
 * Model AppInterest
 * 
 */
export type AppInterest = $Result.DefaultSelection<Prisma.$AppInterestPayload>
/**
 * Model ProfileInterest
 * 
 */
export type ProfileInterest = $Result.DefaultSelection<Prisma.$ProfileInterestPayload>
/**
 * Model ProfileAppInterests
 * 
 */
export type ProfileAppInterests = $Result.DefaultSelection<Prisma.$ProfileAppInterestsPayload>
/**
 * Model MessageRead
 * 
 */
export type MessageRead = $Result.DefaultSelection<Prisma.$MessageReadPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductMedia
 * 
 */
export type ProductMedia = $Result.DefaultSelection<Prisma.$ProductMediaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  DOCUMENT: 'DOCUMENT',
  AUDIO: 'AUDIO',
  OTHER: 'OTHER'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const LineageType: {
  FAMILY: 'FAMILY',
  CLAN: 'CLAN',
  SURNAME_LINE: 'SURNAME_LINE',
  TRIBE: 'TRIBE'
};

export type LineageType = (typeof LineageType)[keyof typeof LineageType]


export const LineageRole: {
  ANCESTOR: 'ANCESTOR',
  DESCENDANT: 'DESCENDANT',
  SPOUSE: 'SPOUSE',
  EXTENDED: 'EXTENDED'
};

export type LineageRole = (typeof LineageRole)[keyof typeof LineageRole]


export const KinshipType: {
  PARENT: 'PARENT',
  CHILD: 'CHILD',
  SIBLING: 'SIBLING',
  SPOUSE: 'SPOUSE',
  GRANDPARENT: 'GRANDPARENT',
  GRANDCHILD: 'GRANDCHILD',
  COUSIN: 'COUSIN',
  UNCLE_AUNT: 'UNCLE_AUNT',
  NEPHEW_NIECE: 'NEPHEW_NIECE',
  OTHER: 'OTHER'
};

export type KinshipType = (typeof KinshipType)[keyof typeof KinshipType]


export const PostVisibility: {
  PUBLIC: 'PUBLIC',
  FOLLOWERS: 'FOLLOWERS',
  LINEAGE_ONLY: 'LINEAGE_ONLY',
  PRIVATE: 'PRIVATE'
};

export type PostVisibility = (typeof PostVisibility)[keyof typeof PostVisibility]


export const ReactionType: {
  LIKE: 'LIKE',
  LOVE: 'LOVE',
  LAUGH: 'LAUGH',
  ANGRY: 'ANGRY',
  SAD: 'SAD'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const NotificationType: {
  FRIEND_REQUEST: 'FRIEND_REQUEST',
  LIKE: 'LIKE',
  COMMENT: 'COMMENT',
  MENTION: 'MENTION',
  MESSAGE: 'MESSAGE',
  LINEAGE_INVITE: 'LINEAGE_INVITE',
  LINEAGE_ACCEPT: 'LINEAGE_ACCEPT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const ListingStatus: {
  DRAFT: 'DRAFT',
  ACTIVE: 'ACTIVE',
  PAUSED: 'PAUSED',
  SOLD: 'SOLD',
  DELETED: 'DELETED'
};

export type ListingStatus = (typeof ListingStatus)[keyof typeof ListingStatus]


export const ProductCondition: {
  NEW: 'NEW',
  USED_LIKE_NEW: 'USED_LIKE_NEW',
  USED_GOOD: 'USED_GOOD',
  USED_FAIR: 'USED_FAIR'
};

export type ProductCondition = (typeof ProductCondition)[keyof typeof ProductCondition]


export const Available: {
  IMMEDIATLY: 'IMMEDIATLY',
  IN_A_WEEK: 'IN_A_WEEK',
  IN_A_MONTH: 'IN_A_MONTH',
  OTHER: 'OTHER'
};

export type Available = (typeof Available)[keyof typeof Available]


export const FriendRequestStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  DECLINED: 'DECLINED',
  CANCELLED: 'CANCELLED'
};

export type FriendRequestStatus = (typeof FriendRequestStatus)[keyof typeof FriendRequestStatus]

}

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type LineageType = $Enums.LineageType

export const LineageType: typeof $Enums.LineageType

export type LineageRole = $Enums.LineageRole

export const LineageRole: typeof $Enums.LineageRole

export type KinshipType = $Enums.KinshipType

export const KinshipType: typeof $Enums.KinshipType

export type PostVisibility = $Enums.PostVisibility

export const PostVisibility: typeof $Enums.PostVisibility

export type ReactionType = $Enums.ReactionType

export const ReactionType: typeof $Enums.ReactionType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type ListingStatus = $Enums.ListingStatus

export const ListingStatus: typeof $Enums.ListingStatus

export type ProductCondition = $Enums.ProductCondition

export const ProductCondition: typeof $Enums.ProductCondition

export type Available = $Enums.Available

export const Available: typeof $Enums.Available

export type FriendRequestStatus = $Enums.FriendRequestStatus

export const FriendRequestStatus: typeof $Enums.FriendRequestStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Profiles
 * const profiles = await prisma.profile.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Profiles
   * const profiles = await prisma.profile.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profileSettings`: Exposes CRUD operations for the **ProfileSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileSettings
    * const profileSettings = await prisma.profileSettings.findMany()
    * ```
    */
  get profileSettings(): Prisma.ProfileSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friendRequest`: Exposes CRUD operations for the **FriendRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FriendRequests
    * const friendRequests = await prisma.friendRequest.findMany()
    * ```
    */
  get friendRequest(): Prisma.FriendRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friendship`: Exposes CRUD operations for the **Friendship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friendships
    * const friendships = await prisma.friendship.findMany()
    * ```
    */
  get friendship(): Prisma.FriendshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clan`: Exposes CRUD operations for the **Clan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clans
    * const clans = await prisma.clan.findMany()
    * ```
    */
  get clan(): Prisma.ClanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profileClan`: Exposes CRUD operations for the **ProfileClan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileClans
    * const profileClans = await prisma.profileClan.findMany()
    * ```
    */
  get profileClan(): Prisma.ProfileClanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lineage`: Exposes CRUD operations for the **Lineage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lineages
    * const lineages = await prisma.lineage.findMany()
    * ```
    */
  get lineage(): Prisma.LineageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lineageMembership`: Exposes CRUD operations for the **LineageMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LineageMemberships
    * const lineageMemberships = await prisma.lineageMembership.findMany()
    * ```
    */
  get lineageMembership(): Prisma.LineageMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kinship`: Exposes CRUD operations for the **Kinship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kinships
    * const kinships = await prisma.kinship.findMany()
    * ```
    */
  get kinship(): Prisma.KinshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mute`: Exposes CRUD operations for the **Mute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mutes
    * const mutes = await prisma.mute.findMany()
    * ```
    */
  get mute(): Prisma.MuteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaFile`: Exposes CRUD operations for the **MediaFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaFiles
    * const mediaFiles = await prisma.mediaFile.findMany()
    * ```
    */
  get mediaFile(): Prisma.MediaFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postReaction`: Exposes CRUD operations for the **PostReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostReactions
    * const postReactions = await prisma.postReaction.findMany()
    * ```
    */
  get postReaction(): Prisma.PostReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentReaction`: Exposes CRUD operations for the **CommentReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentReactions
    * const commentReactions = await prisma.commentReaction.findMany()
    * ```
    */
  get commentReaction(): Prisma.CommentReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.ConversationParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interest`: Exposes CRUD operations for the **Interest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interests
    * const interests = await prisma.interest.findMany()
    * ```
    */
  get interest(): Prisma.InterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appInterest`: Exposes CRUD operations for the **AppInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppInterests
    * const appInterests = await prisma.appInterest.findMany()
    * ```
    */
  get appInterest(): Prisma.AppInterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profileInterest`: Exposes CRUD operations for the **ProfileInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileInterests
    * const profileInterests = await prisma.profileInterest.findMany()
    * ```
    */
  get profileInterest(): Prisma.ProfileInterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profileAppInterests`: Exposes CRUD operations for the **ProfileAppInterests** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileAppInterests
    * const profileAppInterests = await prisma.profileAppInterests.findMany()
    * ```
    */
  get profileAppInterests(): Prisma.ProfileAppInterestsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageRead`: Exposes CRUD operations for the **MessageRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageReads
    * const messageReads = await prisma.messageRead.findMany()
    * ```
    */
  get messageRead(): Prisma.MessageReadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productMedia`: Exposes CRUD operations for the **ProductMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductMedias
    * const productMedias = await prisma.productMedia.findMany()
    * ```
    */
  get productMedia(): Prisma.ProductMediaDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Profile: 'Profile',
    ProfileSettings: 'ProfileSettings',
    FriendRequest: 'FriendRequest',
    Friendship: 'Friendship',
    Clan: 'Clan',
    ProfileClan: 'ProfileClan',
    Lineage: 'Lineage',
    LineageMembership: 'LineageMembership',
    Kinship: 'Kinship',
    Block: 'Block',
    Mute: 'Mute',
    Post: 'Post',
    MediaFile: 'MediaFile',
    Comment: 'Comment',
    PostReaction: 'PostReaction',
    CommentReaction: 'CommentReaction',
    Conversation: 'Conversation',
    ConversationParticipant: 'ConversationParticipant',
    Message: 'Message',
    Notification: 'Notification',
    Interest: 'Interest',
    AppInterest: 'AppInterest',
    ProfileInterest: 'ProfileInterest',
    ProfileAppInterests: 'ProfileAppInterests',
    MessageRead: 'MessageRead',
    Product: 'Product',
    ProductMedia: 'ProductMedia'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "profile" | "profileSettings" | "friendRequest" | "friendship" | "clan" | "profileClan" | "lineage" | "lineageMembership" | "kinship" | "block" | "mute" | "post" | "mediaFile" | "comment" | "postReaction" | "commentReaction" | "conversation" | "conversationParticipant" | "message" | "notification" | "interest" | "appInterest" | "profileInterest" | "profileAppInterests" | "messageRead" | "product" | "productMedia"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      ProfileSettings: {
        payload: Prisma.$ProfileSettingsPayload<ExtArgs>
        fields: Prisma.ProfileSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          findFirst: {
            args: Prisma.ProfileSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          findMany: {
            args: Prisma.ProfileSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>[]
          }
          create: {
            args: Prisma.ProfileSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          createMany: {
            args: Prisma.ProfileSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>[]
          }
          delete: {
            args: Prisma.ProfileSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          update: {
            args: Prisma.ProfileSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          deleteMany: {
            args: Prisma.ProfileSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>[]
          }
          upsert: {
            args: Prisma.ProfileSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          aggregate: {
            args: Prisma.ProfileSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileSettings>
          }
          groupBy: {
            args: Prisma.ProfileSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileSettingsCountAggregateOutputType> | number
          }
        }
      }
      FriendRequest: {
        payload: Prisma.$FriendRequestPayload<ExtArgs>
        fields: Prisma.FriendRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          findFirst: {
            args: Prisma.FriendRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          findMany: {
            args: Prisma.FriendRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>[]
          }
          create: {
            args: Prisma.FriendRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          createMany: {
            args: Prisma.FriendRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>[]
          }
          delete: {
            args: Prisma.FriendRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          update: {
            args: Prisma.FriendRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          deleteMany: {
            args: Prisma.FriendRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FriendRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>[]
          }
          upsert: {
            args: Prisma.FriendRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendRequestPayload>
          }
          aggregate: {
            args: Prisma.FriendRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendRequest>
          }
          groupBy: {
            args: Prisma.FriendRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendRequestCountArgs<ExtArgs>
            result: $Utils.Optional<FriendRequestCountAggregateOutputType> | number
          }
        }
      }
      Friendship: {
        payload: Prisma.$FriendshipPayload<ExtArgs>
        fields: Prisma.FriendshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findFirst: {
            args: Prisma.FriendshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          findMany: {
            args: Prisma.FriendshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          create: {
            args: Prisma.FriendshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          createMany: {
            args: Prisma.FriendshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          delete: {
            args: Prisma.FriendshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          update: {
            args: Prisma.FriendshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          deleteMany: {
            args: Prisma.FriendshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FriendshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>[]
          }
          upsert: {
            args: Prisma.FriendshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendshipPayload>
          }
          aggregate: {
            args: Prisma.FriendshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriendship>
          }
          groupBy: {
            args: Prisma.FriendshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendshipCountArgs<ExtArgs>
            result: $Utils.Optional<FriendshipCountAggregateOutputType> | number
          }
        }
      }
      Clan: {
        payload: Prisma.$ClanPayload<ExtArgs>
        fields: Prisma.ClanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          findFirst: {
            args: Prisma.ClanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          findMany: {
            args: Prisma.ClanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>[]
          }
          create: {
            args: Prisma.ClanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          createMany: {
            args: Prisma.ClanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>[]
          }
          delete: {
            args: Prisma.ClanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          update: {
            args: Prisma.ClanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          deleteMany: {
            args: Prisma.ClanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>[]
          }
          upsert: {
            args: Prisma.ClanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClanPayload>
          }
          aggregate: {
            args: Prisma.ClanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClan>
          }
          groupBy: {
            args: Prisma.ClanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClanCountArgs<ExtArgs>
            result: $Utils.Optional<ClanCountAggregateOutputType> | number
          }
        }
      }
      ProfileClan: {
        payload: Prisma.$ProfileClanPayload<ExtArgs>
        fields: Prisma.ProfileClanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileClanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileClanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload>
          }
          findFirst: {
            args: Prisma.ProfileClanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileClanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload>
          }
          findMany: {
            args: Prisma.ProfileClanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload>[]
          }
          create: {
            args: Prisma.ProfileClanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload>
          }
          createMany: {
            args: Prisma.ProfileClanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileClanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload>[]
          }
          delete: {
            args: Prisma.ProfileClanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload>
          }
          update: {
            args: Prisma.ProfileClanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload>
          }
          deleteMany: {
            args: Prisma.ProfileClanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileClanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileClanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload>[]
          }
          upsert: {
            args: Prisma.ProfileClanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileClanPayload>
          }
          aggregate: {
            args: Prisma.ProfileClanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileClan>
          }
          groupBy: {
            args: Prisma.ProfileClanGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileClanGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileClanCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileClanCountAggregateOutputType> | number
          }
        }
      }
      Lineage: {
        payload: Prisma.$LineagePayload<ExtArgs>
        fields: Prisma.LineageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LineageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LineageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          findFirst: {
            args: Prisma.LineageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LineageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          findMany: {
            args: Prisma.LineageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>[]
          }
          create: {
            args: Prisma.LineageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          createMany: {
            args: Prisma.LineageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LineageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>[]
          }
          delete: {
            args: Prisma.LineageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          update: {
            args: Prisma.LineageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          deleteMany: {
            args: Prisma.LineageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LineageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LineageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>[]
          }
          upsert: {
            args: Prisma.LineageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          aggregate: {
            args: Prisma.LineageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLineage>
          }
          groupBy: {
            args: Prisma.LineageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LineageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LineageCountArgs<ExtArgs>
            result: $Utils.Optional<LineageCountAggregateOutputType> | number
          }
        }
      }
      LineageMembership: {
        payload: Prisma.$LineageMembershipPayload<ExtArgs>
        fields: Prisma.LineageMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LineageMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LineageMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          findFirst: {
            args: Prisma.LineageMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LineageMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          findMany: {
            args: Prisma.LineageMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>[]
          }
          create: {
            args: Prisma.LineageMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          createMany: {
            args: Prisma.LineageMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LineageMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>[]
          }
          delete: {
            args: Prisma.LineageMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          update: {
            args: Prisma.LineageMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          deleteMany: {
            args: Prisma.LineageMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LineageMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LineageMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>[]
          }
          upsert: {
            args: Prisma.LineageMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          aggregate: {
            args: Prisma.LineageMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLineageMembership>
          }
          groupBy: {
            args: Prisma.LineageMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<LineageMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.LineageMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<LineageMembershipCountAggregateOutputType> | number
          }
        }
      }
      Kinship: {
        payload: Prisma.$KinshipPayload<ExtArgs>
        fields: Prisma.KinshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KinshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KinshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          findFirst: {
            args: Prisma.KinshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KinshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          findMany: {
            args: Prisma.KinshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>[]
          }
          create: {
            args: Prisma.KinshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          createMany: {
            args: Prisma.KinshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KinshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>[]
          }
          delete: {
            args: Prisma.KinshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          update: {
            args: Prisma.KinshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          deleteMany: {
            args: Prisma.KinshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KinshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KinshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>[]
          }
          upsert: {
            args: Prisma.KinshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          aggregate: {
            args: Prisma.KinshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKinship>
          }
          groupBy: {
            args: Prisma.KinshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<KinshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.KinshipCountArgs<ExtArgs>
            result: $Utils.Optional<KinshipCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      Mute: {
        payload: Prisma.$MutePayload<ExtArgs>
        fields: Prisma.MuteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MuteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MuteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          findFirst: {
            args: Prisma.MuteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MuteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          findMany: {
            args: Prisma.MuteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>[]
          }
          create: {
            args: Prisma.MuteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          createMany: {
            args: Prisma.MuteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MuteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>[]
          }
          delete: {
            args: Prisma.MuteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          update: {
            args: Prisma.MuteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          deleteMany: {
            args: Prisma.MuteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MuteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MuteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>[]
          }
          upsert: {
            args: Prisma.MuteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          aggregate: {
            args: Prisma.MuteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMute>
          }
          groupBy: {
            args: Prisma.MuteGroupByArgs<ExtArgs>
            result: $Utils.Optional<MuteGroupByOutputType>[]
          }
          count: {
            args: Prisma.MuteCountArgs<ExtArgs>
            result: $Utils.Optional<MuteCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      MediaFile: {
        payload: Prisma.$MediaFilePayload<ExtArgs>
        fields: Prisma.MediaFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          findFirst: {
            args: Prisma.MediaFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          findMany: {
            args: Prisma.MediaFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          create: {
            args: Prisma.MediaFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          createMany: {
            args: Prisma.MediaFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          delete: {
            args: Prisma.MediaFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          update: {
            args: Prisma.MediaFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          deleteMany: {
            args: Prisma.MediaFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          upsert: {
            args: Prisma.MediaFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          aggregate: {
            args: Prisma.MediaFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaFile>
          }
          groupBy: {
            args: Prisma.MediaFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaFileCountArgs<ExtArgs>
            result: $Utils.Optional<MediaFileCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      PostReaction: {
        payload: Prisma.$PostReactionPayload<ExtArgs>
        fields: Prisma.PostReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          findFirst: {
            args: Prisma.PostReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          findMany: {
            args: Prisma.PostReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>[]
          }
          create: {
            args: Prisma.PostReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          createMany: {
            args: Prisma.PostReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>[]
          }
          delete: {
            args: Prisma.PostReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          update: {
            args: Prisma.PostReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          deleteMany: {
            args: Prisma.PostReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>[]
          }
          upsert: {
            args: Prisma.PostReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          aggregate: {
            args: Prisma.PostReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostReaction>
          }
          groupBy: {
            args: Prisma.PostReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostReactionCountArgs<ExtArgs>
            result: $Utils.Optional<PostReactionCountAggregateOutputType> | number
          }
        }
      }
      CommentReaction: {
        payload: Prisma.$CommentReactionPayload<ExtArgs>
        fields: Prisma.CommentReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          findFirst: {
            args: Prisma.CommentReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          findMany: {
            args: Prisma.CommentReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>[]
          }
          create: {
            args: Prisma.CommentReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          createMany: {
            args: Prisma.CommentReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>[]
          }
          delete: {
            args: Prisma.CommentReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          update: {
            args: Prisma.CommentReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          deleteMany: {
            args: Prisma.CommentReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>[]
          }
          upsert: {
            args: Prisma.CommentReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          aggregate: {
            args: Prisma.CommentReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentReaction>
          }
          groupBy: {
            args: Prisma.CommentReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentReactionCountArgs<ExtArgs>
            result: $Utils.Optional<CommentReactionCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationParticipant: {
        payload: Prisma.$ConversationParticipantPayload<ExtArgs>
        fields: Prisma.ConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          update: {
            args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Interest: {
        payload: Prisma.$InterestPayload<ExtArgs>
        fields: Prisma.InterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findFirst: {
            args: Prisma.InterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findMany: {
            args: Prisma.InterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          create: {
            args: Prisma.InterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          createMany: {
            args: Prisma.InterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          delete: {
            args: Prisma.InterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          update: {
            args: Prisma.InterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          deleteMany: {
            args: Prisma.InterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          upsert: {
            args: Prisma.InterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          aggregate: {
            args: Prisma.InterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterest>
          }
          groupBy: {
            args: Prisma.InterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestCountArgs<ExtArgs>
            result: $Utils.Optional<InterestCountAggregateOutputType> | number
          }
        }
      }
      AppInterest: {
        payload: Prisma.$AppInterestPayload<ExtArgs>
        fields: Prisma.AppInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload>
          }
          findFirst: {
            args: Prisma.AppInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload>
          }
          findMany: {
            args: Prisma.AppInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload>[]
          }
          create: {
            args: Prisma.AppInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload>
          }
          createMany: {
            args: Prisma.AppInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload>[]
          }
          delete: {
            args: Prisma.AppInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload>
          }
          update: {
            args: Prisma.AppInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload>
          }
          deleteMany: {
            args: Prisma.AppInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppInterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload>[]
          }
          upsert: {
            args: Prisma.AppInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppInterestPayload>
          }
          aggregate: {
            args: Prisma.AppInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppInterest>
          }
          groupBy: {
            args: Prisma.AppInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppInterestCountArgs<ExtArgs>
            result: $Utils.Optional<AppInterestCountAggregateOutputType> | number
          }
        }
      }
      ProfileInterest: {
        payload: Prisma.$ProfileInterestPayload<ExtArgs>
        fields: Prisma.ProfileInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          findFirst: {
            args: Prisma.ProfileInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          findMany: {
            args: Prisma.ProfileInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>[]
          }
          create: {
            args: Prisma.ProfileInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          createMany: {
            args: Prisma.ProfileInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>[]
          }
          delete: {
            args: Prisma.ProfileInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          update: {
            args: Prisma.ProfileInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          deleteMany: {
            args: Prisma.ProfileInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileInterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>[]
          }
          upsert: {
            args: Prisma.ProfileInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          aggregate: {
            args: Prisma.ProfileInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileInterest>
          }
          groupBy: {
            args: Prisma.ProfileInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileInterestCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileInterestCountAggregateOutputType> | number
          }
        }
      }
      ProfileAppInterests: {
        payload: Prisma.$ProfileAppInterestsPayload<ExtArgs>
        fields: Prisma.ProfileAppInterestsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileAppInterestsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileAppInterestsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload>
          }
          findFirst: {
            args: Prisma.ProfileAppInterestsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileAppInterestsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload>
          }
          findMany: {
            args: Prisma.ProfileAppInterestsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload>[]
          }
          create: {
            args: Prisma.ProfileAppInterestsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload>
          }
          createMany: {
            args: Prisma.ProfileAppInterestsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileAppInterestsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload>[]
          }
          delete: {
            args: Prisma.ProfileAppInterestsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload>
          }
          update: {
            args: Prisma.ProfileAppInterestsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload>
          }
          deleteMany: {
            args: Prisma.ProfileAppInterestsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileAppInterestsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileAppInterestsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload>[]
          }
          upsert: {
            args: Prisma.ProfileAppInterestsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileAppInterestsPayload>
          }
          aggregate: {
            args: Prisma.ProfileAppInterestsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileAppInterests>
          }
          groupBy: {
            args: Prisma.ProfileAppInterestsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileAppInterestsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileAppInterestsCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileAppInterestsCountAggregateOutputType> | number
          }
        }
      }
      MessageRead: {
        payload: Prisma.$MessageReadPayload<ExtArgs>
        fields: Prisma.MessageReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageReadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageReadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          findFirst: {
            args: Prisma.MessageReadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageReadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          findMany: {
            args: Prisma.MessageReadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          create: {
            args: Prisma.MessageReadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          createMany: {
            args: Prisma.MessageReadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageReadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          delete: {
            args: Prisma.MessageReadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          update: {
            args: Prisma.MessageReadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          deleteMany: {
            args: Prisma.MessageReadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageReadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageReadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          upsert: {
            args: Prisma.MessageReadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          aggregate: {
            args: Prisma.MessageReadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageRead>
          }
          groupBy: {
            args: Prisma.MessageReadGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageReadCountArgs<ExtArgs>
            result: $Utils.Optional<MessageReadCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductMedia: {
        payload: Prisma.$ProductMediaPayload<ExtArgs>
        fields: Prisma.ProductMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload>
          }
          findFirst: {
            args: Prisma.ProductMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload>
          }
          findMany: {
            args: Prisma.ProductMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload>[]
          }
          create: {
            args: Prisma.ProductMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload>
          }
          createMany: {
            args: Prisma.ProductMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload>[]
          }
          delete: {
            args: Prisma.ProductMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload>
          }
          update: {
            args: Prisma.ProductMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload>
          }
          deleteMany: {
            args: Prisma.ProductMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload>[]
          }
          upsert: {
            args: Prisma.ProductMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductMediaPayload>
          }
          aggregate: {
            args: Prisma.ProductMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductMedia>
          }
          groupBy: {
            args: Prisma.ProductMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductMediaCountArgs<ExtArgs>
            result: $Utils.Optional<ProductMediaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    profile?: ProfileOmit
    profileSettings?: ProfileSettingsOmit
    friendRequest?: FriendRequestOmit
    friendship?: FriendshipOmit
    clan?: ClanOmit
    profileClan?: ProfileClanOmit
    lineage?: LineageOmit
    lineageMembership?: LineageMembershipOmit
    kinship?: KinshipOmit
    block?: BlockOmit
    mute?: MuteOmit
    post?: PostOmit
    mediaFile?: MediaFileOmit
    comment?: CommentOmit
    postReaction?: PostReactionOmit
    commentReaction?: CommentReactionOmit
    conversation?: ConversationOmit
    conversationParticipant?: ConversationParticipantOmit
    message?: MessageOmit
    notification?: NotificationOmit
    interest?: InterestOmit
    appInterest?: AppInterestOmit
    profileInterest?: ProfileInterestOmit
    profileAppInterests?: ProfileAppInterestsOmit
    messageRead?: MessageReadOmit
    product?: ProductOmit
    productMedia?: ProductMediaOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    blocksAsBlocked: number
    blocksAsBlocker: number
    comments: number
    commentReactions: number
    conversationsOwned: number
    conversationMembers: number
    clanTree: number
    kinshipsA: number
    kinshipsB: number
    lineagesCreated: number
    lineageMembershipsAdded: number
    lineageMemberships: number
    messages: number
    messageReads: number
    mutesAsMuted: number
    mutesAsMuter: number
    notificationsAsActor: number
    notifications: number
    posts: number
    postReactions: number
    product: number
    interests: number
    appInterests: number
    sentFriendRequests: number
    receivedFriendRequests: number
    friendshipsA: number
    friendshipsB: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocksAsBlocked?: boolean | ProfileCountOutputTypeCountBlocksAsBlockedArgs
    blocksAsBlocker?: boolean | ProfileCountOutputTypeCountBlocksAsBlockerArgs
    comments?: boolean | ProfileCountOutputTypeCountCommentsArgs
    commentReactions?: boolean | ProfileCountOutputTypeCountCommentReactionsArgs
    conversationsOwned?: boolean | ProfileCountOutputTypeCountConversationsOwnedArgs
    conversationMembers?: boolean | ProfileCountOutputTypeCountConversationMembersArgs
    clanTree?: boolean | ProfileCountOutputTypeCountClanTreeArgs
    kinshipsA?: boolean | ProfileCountOutputTypeCountKinshipsAArgs
    kinshipsB?: boolean | ProfileCountOutputTypeCountKinshipsBArgs
    lineagesCreated?: boolean | ProfileCountOutputTypeCountLineagesCreatedArgs
    lineageMembershipsAdded?: boolean | ProfileCountOutputTypeCountLineageMembershipsAddedArgs
    lineageMemberships?: boolean | ProfileCountOutputTypeCountLineageMembershipsArgs
    messages?: boolean | ProfileCountOutputTypeCountMessagesArgs
    messageReads?: boolean | ProfileCountOutputTypeCountMessageReadsArgs
    mutesAsMuted?: boolean | ProfileCountOutputTypeCountMutesAsMutedArgs
    mutesAsMuter?: boolean | ProfileCountOutputTypeCountMutesAsMuterArgs
    notificationsAsActor?: boolean | ProfileCountOutputTypeCountNotificationsAsActorArgs
    notifications?: boolean | ProfileCountOutputTypeCountNotificationsArgs
    posts?: boolean | ProfileCountOutputTypeCountPostsArgs
    postReactions?: boolean | ProfileCountOutputTypeCountPostReactionsArgs
    product?: boolean | ProfileCountOutputTypeCountProductArgs
    interests?: boolean | ProfileCountOutputTypeCountInterestsArgs
    appInterests?: boolean | ProfileCountOutputTypeCountAppInterestsArgs
    sentFriendRequests?: boolean | ProfileCountOutputTypeCountSentFriendRequestsArgs
    receivedFriendRequests?: boolean | ProfileCountOutputTypeCountReceivedFriendRequestsArgs
    friendshipsA?: boolean | ProfileCountOutputTypeCountFriendshipsAArgs
    friendshipsB?: boolean | ProfileCountOutputTypeCountFriendshipsBArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountBlocksAsBlockedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountBlocksAsBlockerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountCommentReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReactionWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountConversationsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountConversationMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountClanTreeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileClanWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountKinshipsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KinshipWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountKinshipsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KinshipWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLineagesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLineageMembershipsAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageMembershipWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLineageMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageMembershipWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMessageReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMutesAsMutedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuteWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMutesAsMuterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuteWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountNotificationsAsActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostReactionWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileInterestWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountAppInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileAppInterestsWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountSentFriendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendRequestWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountReceivedFriendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendRequestWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountFriendshipsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountFriendshipsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
  }


  /**
   * Count Type FriendRequestCountOutputType
   */

  export type FriendRequestCountOutputType = {
    notifications: number
  }

  export type FriendRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | FriendRequestCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * FriendRequestCountOutputType without action
   */
  export type FriendRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequestCountOutputType
     */
    select?: FriendRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FriendRequestCountOutputType without action
   */
  export type FriendRequestCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ClanCountOutputType
   */

  export type ClanCountOutputType = {
    members: number
  }

  export type ClanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | ClanCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * ClanCountOutputType without action
   */
  export type ClanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClanCountOutputType
     */
    select?: ClanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClanCountOutputType without action
   */
  export type ClanCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileClanWhereInput
  }


  /**
   * Count Type LineageCountOutputType
   */

  export type LineageCountOutputType = {
    memberships: number
    notifications: number
    posts: number
  }

  export type LineageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | LineageCountOutputTypeCountMembershipsArgs
    notifications?: boolean | LineageCountOutputTypeCountNotificationsArgs
    posts?: boolean | LineageCountOutputTypeCountPostsArgs
  }

  // Custom InputTypes
  /**
   * LineageCountOutputType without action
   */
  export type LineageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageCountOutputType
     */
    select?: LineageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LineageCountOutputType without action
   */
  export type LineageCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageMembershipWhereInput
  }

  /**
   * LineageCountOutputType without action
   */
  export type LineageCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * LineageCountOutputType without action
   */
  export type LineageCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
    mediaFiles: number
    notifications: number
    reactions: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    mediaFiles?: boolean | PostCountOutputTypeCountMediaFilesArgs
    notifications?: boolean | PostCountOutputTypeCountNotificationsArgs
    reactions?: boolean | PostCountOutputTypeCountReactionsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountMediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFileWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostReactionWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
    reactions: number
    notifications: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
    reactions?: boolean | CommentCountOutputTypeCountReactionsArgs
    notifications?: boolean | CommentCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReactionWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    participants: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    reads: number
    notifications: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reads?: boolean | MessageCountOutputTypeCountReadsArgs
    notifications?: boolean | MessageCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type InterestCountOutputType
   */

  export type InterestCountOutputType = {
    users: number
  }

  export type InterestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | InterestCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * InterestCountOutputType without action
   */
  export type InterestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestCountOutputType
     */
    select?: InterestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterestCountOutputType without action
   */
  export type InterestCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileInterestWhereInput
  }


  /**
   * Count Type AppInterestCountOutputType
   */

  export type AppInterestCountOutputType = {
    users: number
  }

  export type AppInterestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AppInterestCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * AppInterestCountOutputType without action
   */
  export type AppInterestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterestCountOutputType
     */
    select?: AppInterestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppInterestCountOutputType without action
   */
  export type AppInterestCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileAppInterestsWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    media: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | ProductCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductMediaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    username: string | null
    gender: string | null
    dateOfBirth: Date | null
    email: string | null
    country: string | null
    city: string | null
    district: string | null
    location: string | null
    bio: string | null
    profession: string | null
    countryCode: string | null
    avatarUrl: string | null
    coverUrl: string | null
    lineageMainSurname: string | null
    lineageRootVillage: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ethnicity: string | null
    occupation: string | null
    isProfileComplete: boolean | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    fullName: string | null
    username: string | null
    gender: string | null
    dateOfBirth: Date | null
    email: string | null
    country: string | null
    city: string | null
    district: string | null
    location: string | null
    bio: string | null
    profession: string | null
    countryCode: string | null
    avatarUrl: string | null
    coverUrl: string | null
    lineageMainSurname: string | null
    lineageRootVillage: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    ethnicity: string | null
    occupation: string | null
    isProfileComplete: boolean | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    fullName: number
    username: number
    gender: number
    dateOfBirth: number
    email: number
    country: number
    city: number
    district: number
    location: number
    bio: number
    profession: number
    countryCode: number
    avatarUrl: number
    coverUrl: number
    lineageMainSurname: number
    lineageRootVillage: number
    isVerified: number
    createdAt: number
    updatedAt: number
    ethnicity: number
    occupation: number
    isProfileComplete: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    fullName?: true
    username?: true
    gender?: true
    dateOfBirth?: true
    email?: true
    country?: true
    city?: true
    district?: true
    location?: true
    bio?: true
    profession?: true
    countryCode?: true
    avatarUrl?: true
    coverUrl?: true
    lineageMainSurname?: true
    lineageRootVillage?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    ethnicity?: true
    occupation?: true
    isProfileComplete?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    fullName?: true
    username?: true
    gender?: true
    dateOfBirth?: true
    email?: true
    country?: true
    city?: true
    district?: true
    location?: true
    bio?: true
    profession?: true
    countryCode?: true
    avatarUrl?: true
    coverUrl?: true
    lineageMainSurname?: true
    lineageRootVillage?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    ethnicity?: true
    occupation?: true
    isProfileComplete?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    fullName?: true
    username?: true
    gender?: true
    dateOfBirth?: true
    email?: true
    country?: true
    city?: true
    district?: true
    location?: true
    bio?: true
    profession?: true
    countryCode?: true
    avatarUrl?: true
    coverUrl?: true
    lineageMainSurname?: true
    lineageRootVillage?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    ethnicity?: true
    occupation?: true
    isProfileComplete?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string
    fullName: string | null
    username: string
    gender: string | null
    dateOfBirth: Date | null
    email: string
    country: string | null
    city: string | null
    district: string | null
    location: string
    bio: string
    profession: string | null
    countryCode: string | null
    avatarUrl: string | null
    coverUrl: string | null
    lineageMainSurname: string | null
    lineageRootVillage: string | null
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    ethnicity: string | null
    occupation: string | null
    isProfileComplete: boolean
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    username?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    email?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    location?: boolean
    bio?: boolean
    profession?: boolean
    countryCode?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    lineageMainSurname?: boolean
    lineageRootVillage?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ethnicity?: boolean
    occupation?: boolean
    isProfileComplete?: boolean
    blocksAsBlocked?: boolean | Profile$blocksAsBlockedArgs<ExtArgs>
    blocksAsBlocker?: boolean | Profile$blocksAsBlockerArgs<ExtArgs>
    comments?: boolean | Profile$commentsArgs<ExtArgs>
    commentReactions?: boolean | Profile$commentReactionsArgs<ExtArgs>
    conversationsOwned?: boolean | Profile$conversationsOwnedArgs<ExtArgs>
    conversationMembers?: boolean | Profile$conversationMembersArgs<ExtArgs>
    clanTree?: boolean | Profile$clanTreeArgs<ExtArgs>
    kinshipsA?: boolean | Profile$kinshipsAArgs<ExtArgs>
    kinshipsB?: boolean | Profile$kinshipsBArgs<ExtArgs>
    lineagesCreated?: boolean | Profile$lineagesCreatedArgs<ExtArgs>
    lineageMembershipsAdded?: boolean | Profile$lineageMembershipsAddedArgs<ExtArgs>
    lineageMemberships?: boolean | Profile$lineageMembershipsArgs<ExtArgs>
    messages?: boolean | Profile$messagesArgs<ExtArgs>
    messageReads?: boolean | Profile$messageReadsArgs<ExtArgs>
    mutesAsMuted?: boolean | Profile$mutesAsMutedArgs<ExtArgs>
    mutesAsMuter?: boolean | Profile$mutesAsMuterArgs<ExtArgs>
    notificationsAsActor?: boolean | Profile$notificationsAsActorArgs<ExtArgs>
    notifications?: boolean | Profile$notificationsArgs<ExtArgs>
    posts?: boolean | Profile$postsArgs<ExtArgs>
    postReactions?: boolean | Profile$postReactionsArgs<ExtArgs>
    product?: boolean | Profile$productArgs<ExtArgs>
    interests?: boolean | Profile$interestsArgs<ExtArgs>
    appInterests?: boolean | Profile$appInterestsArgs<ExtArgs>
    settings?: boolean | Profile$settingsArgs<ExtArgs>
    sentFriendRequests?: boolean | Profile$sentFriendRequestsArgs<ExtArgs>
    receivedFriendRequests?: boolean | Profile$receivedFriendRequestsArgs<ExtArgs>
    friendshipsA?: boolean | Profile$friendshipsAArgs<ExtArgs>
    friendshipsB?: boolean | Profile$friendshipsBArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    username?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    email?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    location?: boolean
    bio?: boolean
    profession?: boolean
    countryCode?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    lineageMainSurname?: boolean
    lineageRootVillage?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ethnicity?: boolean
    occupation?: boolean
    isProfileComplete?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    username?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    email?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    location?: boolean
    bio?: boolean
    profession?: boolean
    countryCode?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    lineageMainSurname?: boolean
    lineageRootVillage?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ethnicity?: boolean
    occupation?: boolean
    isProfileComplete?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    fullName?: boolean
    username?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    email?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    location?: boolean
    bio?: boolean
    profession?: boolean
    countryCode?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    lineageMainSurname?: boolean
    lineageRootVillage?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ethnicity?: boolean
    occupation?: boolean
    isProfileComplete?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "fullName" | "username" | "gender" | "dateOfBirth" | "email" | "country" | "city" | "district" | "location" | "bio" | "profession" | "countryCode" | "avatarUrl" | "coverUrl" | "lineageMainSurname" | "lineageRootVillage" | "isVerified" | "createdAt" | "updatedAt" | "ethnicity" | "occupation" | "isProfileComplete", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocksAsBlocked?: boolean | Profile$blocksAsBlockedArgs<ExtArgs>
    blocksAsBlocker?: boolean | Profile$blocksAsBlockerArgs<ExtArgs>
    comments?: boolean | Profile$commentsArgs<ExtArgs>
    commentReactions?: boolean | Profile$commentReactionsArgs<ExtArgs>
    conversationsOwned?: boolean | Profile$conversationsOwnedArgs<ExtArgs>
    conversationMembers?: boolean | Profile$conversationMembersArgs<ExtArgs>
    clanTree?: boolean | Profile$clanTreeArgs<ExtArgs>
    kinshipsA?: boolean | Profile$kinshipsAArgs<ExtArgs>
    kinshipsB?: boolean | Profile$kinshipsBArgs<ExtArgs>
    lineagesCreated?: boolean | Profile$lineagesCreatedArgs<ExtArgs>
    lineageMembershipsAdded?: boolean | Profile$lineageMembershipsAddedArgs<ExtArgs>
    lineageMemberships?: boolean | Profile$lineageMembershipsArgs<ExtArgs>
    messages?: boolean | Profile$messagesArgs<ExtArgs>
    messageReads?: boolean | Profile$messageReadsArgs<ExtArgs>
    mutesAsMuted?: boolean | Profile$mutesAsMutedArgs<ExtArgs>
    mutesAsMuter?: boolean | Profile$mutesAsMuterArgs<ExtArgs>
    notificationsAsActor?: boolean | Profile$notificationsAsActorArgs<ExtArgs>
    notifications?: boolean | Profile$notificationsArgs<ExtArgs>
    posts?: boolean | Profile$postsArgs<ExtArgs>
    postReactions?: boolean | Profile$postReactionsArgs<ExtArgs>
    product?: boolean | Profile$productArgs<ExtArgs>
    interests?: boolean | Profile$interestsArgs<ExtArgs>
    appInterests?: boolean | Profile$appInterestsArgs<ExtArgs>
    settings?: boolean | Profile$settingsArgs<ExtArgs>
    sentFriendRequests?: boolean | Profile$sentFriendRequestsArgs<ExtArgs>
    receivedFriendRequests?: boolean | Profile$receivedFriendRequestsArgs<ExtArgs>
    friendshipsA?: boolean | Profile$friendshipsAArgs<ExtArgs>
    friendshipsB?: boolean | Profile$friendshipsBArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      blocksAsBlocked: Prisma.$BlockPayload<ExtArgs>[]
      blocksAsBlocker: Prisma.$BlockPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      commentReactions: Prisma.$CommentReactionPayload<ExtArgs>[]
      conversationsOwned: Prisma.$ConversationPayload<ExtArgs>[]
      conversationMembers: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      clanTree: Prisma.$ProfileClanPayload<ExtArgs>[]
      kinshipsA: Prisma.$KinshipPayload<ExtArgs>[]
      kinshipsB: Prisma.$KinshipPayload<ExtArgs>[]
      lineagesCreated: Prisma.$LineagePayload<ExtArgs>[]
      lineageMembershipsAdded: Prisma.$LineageMembershipPayload<ExtArgs>[]
      lineageMemberships: Prisma.$LineageMembershipPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      messageReads: Prisma.$MessageReadPayload<ExtArgs>[]
      mutesAsMuted: Prisma.$MutePayload<ExtArgs>[]
      mutesAsMuter: Prisma.$MutePayload<ExtArgs>[]
      notificationsAsActor: Prisma.$NotificationPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      postReactions: Prisma.$PostReactionPayload<ExtArgs>[]
      product: Prisma.$ProductPayload<ExtArgs>[]
      interests: Prisma.$ProfileInterestPayload<ExtArgs>[]
      appInterests: Prisma.$ProfileAppInterestsPayload<ExtArgs>[]
      settings: Prisma.$ProfileSettingsPayload<ExtArgs> | null
      sentFriendRequests: Prisma.$FriendRequestPayload<ExtArgs>[]
      receivedFriendRequests: Prisma.$FriendRequestPayload<ExtArgs>[]
      friendshipsA: Prisma.$FriendshipPayload<ExtArgs>[]
      friendshipsB: Prisma.$FriendshipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string
      lastName: string
      fullName: string | null
      username: string
      gender: string | null
      dateOfBirth: Date | null
      email: string
      country: string | null
      city: string | null
      district: string | null
      location: string
      bio: string
      profession: string | null
      countryCode: string | null
      avatarUrl: string | null
      coverUrl: string | null
      lineageMainSurname: string | null
      lineageRootVillage: string | null
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
      ethnicity: string | null
      occupation: string | null
      isProfileComplete: boolean
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocksAsBlocked<T extends Profile$blocksAsBlockedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$blocksAsBlockedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocksAsBlocker<T extends Profile$blocksAsBlockerArgs<ExtArgs> = {}>(args?: Subset<T, Profile$blocksAsBlockerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Profile$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentReactions<T extends Profile$commentReactionsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$commentReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationsOwned<T extends Profile$conversationsOwnedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$conversationsOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationMembers<T extends Profile$conversationMembersArgs<ExtArgs> = {}>(args?: Subset<T, Profile$conversationMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clanTree<T extends Profile$clanTreeArgs<ExtArgs> = {}>(args?: Subset<T, Profile$clanTreeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kinshipsA<T extends Profile$kinshipsAArgs<ExtArgs> = {}>(args?: Subset<T, Profile$kinshipsAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kinshipsB<T extends Profile$kinshipsBArgs<ExtArgs> = {}>(args?: Subset<T, Profile$kinshipsBArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lineagesCreated<T extends Profile$lineagesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$lineagesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lineageMembershipsAdded<T extends Profile$lineageMembershipsAddedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$lineageMembershipsAddedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lineageMemberships<T extends Profile$lineageMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$lineageMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Profile$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messageReads<T extends Profile$messageReadsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$messageReadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mutesAsMuted<T extends Profile$mutesAsMutedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$mutesAsMutedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mutesAsMuter<T extends Profile$mutesAsMuterArgs<ExtArgs> = {}>(args?: Subset<T, Profile$mutesAsMuterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationsAsActor<T extends Profile$notificationsAsActorArgs<ExtArgs> = {}>(args?: Subset<T, Profile$notificationsAsActorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Profile$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Profile$postsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postReactions<T extends Profile$postReactionsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    product<T extends Profile$productArgs<ExtArgs> = {}>(args?: Subset<T, Profile$productArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interests<T extends Profile$interestsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    appInterests<T extends Profile$appInterestsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$appInterestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends Profile$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$settingsArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sentFriendRequests<T extends Profile$sentFriendRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$sentFriendRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedFriendRequests<T extends Profile$receivedFriendRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$receivedFriendRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friendshipsA<T extends Profile$friendshipsAArgs<ExtArgs> = {}>(args?: Subset<T, Profile$friendshipsAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    friendshipsB<T extends Profile$friendshipsBArgs<ExtArgs> = {}>(args?: Subset<T, Profile$friendshipsBArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly firstName: FieldRef<"Profile", 'String'>
    readonly lastName: FieldRef<"Profile", 'String'>
    readonly fullName: FieldRef<"Profile", 'String'>
    readonly username: FieldRef<"Profile", 'String'>
    readonly gender: FieldRef<"Profile", 'String'>
    readonly dateOfBirth: FieldRef<"Profile", 'DateTime'>
    readonly email: FieldRef<"Profile", 'String'>
    readonly country: FieldRef<"Profile", 'String'>
    readonly city: FieldRef<"Profile", 'String'>
    readonly district: FieldRef<"Profile", 'String'>
    readonly location: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly profession: FieldRef<"Profile", 'String'>
    readonly countryCode: FieldRef<"Profile", 'String'>
    readonly avatarUrl: FieldRef<"Profile", 'String'>
    readonly coverUrl: FieldRef<"Profile", 'String'>
    readonly lineageMainSurname: FieldRef<"Profile", 'String'>
    readonly lineageRootVillage: FieldRef<"Profile", 'String'>
    readonly isVerified: FieldRef<"Profile", 'Boolean'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
    readonly ethnicity: FieldRef<"Profile", 'String'>
    readonly occupation: FieldRef<"Profile", 'String'>
    readonly isProfileComplete: FieldRef<"Profile", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.blocksAsBlocked
   */
  export type Profile$blocksAsBlockedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Profile.blocksAsBlocker
   */
  export type Profile$blocksAsBlockerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Profile.comments
   */
  export type Profile$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Profile.commentReactions
   */
  export type Profile$commentReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    where?: CommentReactionWhereInput
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    cursor?: CommentReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * Profile.conversationsOwned
   */
  export type Profile$conversationsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Profile.conversationMembers
   */
  export type Profile$conversationMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Profile.clanTree
   */
  export type Profile$clanTreeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    where?: ProfileClanWhereInput
    orderBy?: ProfileClanOrderByWithRelationInput | ProfileClanOrderByWithRelationInput[]
    cursor?: ProfileClanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileClanScalarFieldEnum | ProfileClanScalarFieldEnum[]
  }

  /**
   * Profile.kinshipsA
   */
  export type Profile$kinshipsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    where?: KinshipWhereInput
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    cursor?: KinshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Profile.kinshipsB
   */
  export type Profile$kinshipsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    where?: KinshipWhereInput
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    cursor?: KinshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Profile.lineagesCreated
   */
  export type Profile$lineagesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    where?: LineageWhereInput
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    cursor?: LineageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineageScalarFieldEnum | LineageScalarFieldEnum[]
  }

  /**
   * Profile.lineageMembershipsAdded
   */
  export type Profile$lineageMembershipsAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    where?: LineageMembershipWhereInput
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    cursor?: LineageMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * Profile.lineageMemberships
   */
  export type Profile$lineageMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    where?: LineageMembershipWhereInput
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    cursor?: LineageMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * Profile.messages
   */
  export type Profile$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Profile.messageReads
   */
  export type Profile$messageReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    cursor?: MessageReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * Profile.mutesAsMuted
   */
  export type Profile$mutesAsMutedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    where?: MuteWhereInput
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    cursor?: MuteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Profile.mutesAsMuter
   */
  export type Profile$mutesAsMuterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    where?: MuteWhereInput
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    cursor?: MuteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Profile.notificationsAsActor
   */
  export type Profile$notificationsAsActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Profile.notifications
   */
  export type Profile$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Profile.posts
   */
  export type Profile$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Profile.postReactions
   */
  export type Profile$postReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    where?: PostReactionWhereInput
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    cursor?: PostReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * Profile.product
   */
  export type Profile$productArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Profile.interests
   */
  export type Profile$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    where?: ProfileInterestWhereInput
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    cursor?: ProfileInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * Profile.appInterests
   */
  export type Profile$appInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    where?: ProfileAppInterestsWhereInput
    orderBy?: ProfileAppInterestsOrderByWithRelationInput | ProfileAppInterestsOrderByWithRelationInput[]
    cursor?: ProfileAppInterestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileAppInterestsScalarFieldEnum | ProfileAppInterestsScalarFieldEnum[]
  }

  /**
   * Profile.settings
   */
  export type Profile$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    where?: ProfileSettingsWhereInput
  }

  /**
   * Profile.sentFriendRequests
   */
  export type Profile$sentFriendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    where?: FriendRequestWhereInput
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    cursor?: FriendRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendRequestScalarFieldEnum | FriendRequestScalarFieldEnum[]
  }

  /**
   * Profile.receivedFriendRequests
   */
  export type Profile$receivedFriendRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    where?: FriendRequestWhereInput
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    cursor?: FriendRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendRequestScalarFieldEnum | FriendRequestScalarFieldEnum[]
  }

  /**
   * Profile.friendshipsA
   */
  export type Profile$friendshipsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Profile.friendshipsB
   */
  export type Profile$friendshipsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    cursor?: FriendshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model ProfileSettings
   */

  export type AggregateProfileSettings = {
    _count: ProfileSettingsCountAggregateOutputType | null
    _min: ProfileSettingsMinAggregateOutputType | null
    _max: ProfileSettingsMaxAggregateOutputType | null
  }

  export type ProfileSettingsMinAggregateOutputType = {
    profileId: string | null
    isPrivate: boolean | null
    showLastSeen: boolean | null
    allowTagging: boolean | null
    allowMessagesFrom: string | null
    discoveryAllowLineage: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileSettingsMaxAggregateOutputType = {
    profileId: string | null
    isPrivate: boolean | null
    showLastSeen: boolean | null
    allowTagging: boolean | null
    allowMessagesFrom: string | null
    discoveryAllowLineage: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileSettingsCountAggregateOutputType = {
    profileId: number
    isPrivate: number
    showLastSeen: number
    allowTagging: number
    allowMessagesFrom: number
    discoveryAllowLineage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileSettingsMinAggregateInputType = {
    profileId?: true
    isPrivate?: true
    showLastSeen?: true
    allowTagging?: true
    allowMessagesFrom?: true
    discoveryAllowLineage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileSettingsMaxAggregateInputType = {
    profileId?: true
    isPrivate?: true
    showLastSeen?: true
    allowTagging?: true
    allowMessagesFrom?: true
    discoveryAllowLineage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileSettingsCountAggregateInputType = {
    profileId?: true
    isPrivate?: true
    showLastSeen?: true
    allowTagging?: true
    allowMessagesFrom?: true
    discoveryAllowLineage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileSettings to aggregate.
     */
    where?: ProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileSettings to fetch.
     */
    orderBy?: ProfileSettingsOrderByWithRelationInput | ProfileSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileSettings
    **/
    _count?: true | ProfileSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileSettingsMaxAggregateInputType
  }

  export type GetProfileSettingsAggregateType<T extends ProfileSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileSettings[P]>
      : GetScalarType<T[P], AggregateProfileSettings[P]>
  }




  export type ProfileSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileSettingsWhereInput
    orderBy?: ProfileSettingsOrderByWithAggregationInput | ProfileSettingsOrderByWithAggregationInput[]
    by: ProfileSettingsScalarFieldEnum[] | ProfileSettingsScalarFieldEnum
    having?: ProfileSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileSettingsCountAggregateInputType | true
    _min?: ProfileSettingsMinAggregateInputType
    _max?: ProfileSettingsMaxAggregateInputType
  }

  export type ProfileSettingsGroupByOutputType = {
    profileId: string
    isPrivate: boolean
    showLastSeen: boolean
    allowTagging: boolean
    allowMessagesFrom: string
    discoveryAllowLineage: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProfileSettingsCountAggregateOutputType | null
    _min: ProfileSettingsMinAggregateOutputType | null
    _max: ProfileSettingsMaxAggregateOutputType | null
  }

  type GetProfileSettingsGroupByPayload<T extends ProfileSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileSettingsGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: boolean
    discoveryAllowLineage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileSettings"]>

  export type ProfileSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: boolean
    discoveryAllowLineage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileSettings"]>

  export type ProfileSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: boolean
    discoveryAllowLineage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileSettings"]>

  export type ProfileSettingsSelectScalar = {
    profileId?: boolean
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: boolean
    discoveryAllowLineage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"profileId" | "isPrivate" | "showLastSeen" | "allowTagging" | "allowMessagesFrom" | "discoveryAllowLineage" | "createdAt" | "updatedAt", ExtArgs["result"]["profileSettings"]>
  export type ProfileSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfileSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileSettings"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      profileId: string
      isPrivate: boolean
      showLastSeen: boolean
      allowTagging: boolean
      allowMessagesFrom: string
      discoveryAllowLineage: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profileSettings"]>
    composites: {}
  }

  type ProfileSettingsGetPayload<S extends boolean | null | undefined | ProfileSettingsDefaultArgs> = $Result.GetResult<Prisma.$ProfileSettingsPayload, S>

  type ProfileSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileSettingsCountAggregateInputType | true
    }

  export interface ProfileSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileSettings'], meta: { name: 'ProfileSettings' } }
    /**
     * Find zero or one ProfileSettings that matches the filter.
     * @param {ProfileSettingsFindUniqueArgs} args - Arguments to find a ProfileSettings
     * @example
     * // Get one ProfileSettings
     * const profileSettings = await prisma.profileSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileSettingsFindUniqueArgs>(args: SelectSubset<T, ProfileSettingsFindUniqueArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileSettingsFindUniqueOrThrowArgs} args - Arguments to find a ProfileSettings
     * @example
     * // Get one ProfileSettings
     * const profileSettings = await prisma.profileSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsFindFirstArgs} args - Arguments to find a ProfileSettings
     * @example
     * // Get one ProfileSettings
     * const profileSettings = await prisma.profileSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileSettingsFindFirstArgs>(args?: SelectSubset<T, ProfileSettingsFindFirstArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsFindFirstOrThrowArgs} args - Arguments to find a ProfileSettings
     * @example
     * // Get one ProfileSettings
     * const profileSettings = await prisma.profileSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileSettings
     * const profileSettings = await prisma.profileSettings.findMany()
     * 
     * // Get first 10 ProfileSettings
     * const profileSettings = await prisma.profileSettings.findMany({ take: 10 })
     * 
     * // Only select the `profileId`
     * const profileSettingsWithProfileIdOnly = await prisma.profileSettings.findMany({ select: { profileId: true } })
     * 
     */
    findMany<T extends ProfileSettingsFindManyArgs>(args?: SelectSubset<T, ProfileSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileSettings.
     * @param {ProfileSettingsCreateArgs} args - Arguments to create a ProfileSettings.
     * @example
     * // Create one ProfileSettings
     * const ProfileSettings = await prisma.profileSettings.create({
     *   data: {
     *     // ... data to create a ProfileSettings
     *   }
     * })
     * 
     */
    create<T extends ProfileSettingsCreateArgs>(args: SelectSubset<T, ProfileSettingsCreateArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileSettings.
     * @param {ProfileSettingsCreateManyArgs} args - Arguments to create many ProfileSettings.
     * @example
     * // Create many ProfileSettings
     * const profileSettings = await prisma.profileSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileSettingsCreateManyArgs>(args?: SelectSubset<T, ProfileSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileSettings and returns the data saved in the database.
     * @param {ProfileSettingsCreateManyAndReturnArgs} args - Arguments to create many ProfileSettings.
     * @example
     * // Create many ProfileSettings
     * const profileSettings = await prisma.profileSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileSettings and only return the `profileId`
     * const profileSettingsWithProfileIdOnly = await prisma.profileSettings.createManyAndReturn({
     *   select: { profileId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfileSettings.
     * @param {ProfileSettingsDeleteArgs} args - Arguments to delete one ProfileSettings.
     * @example
     * // Delete one ProfileSettings
     * const ProfileSettings = await prisma.profileSettings.delete({
     *   where: {
     *     // ... filter to delete one ProfileSettings
     *   }
     * })
     * 
     */
    delete<T extends ProfileSettingsDeleteArgs>(args: SelectSubset<T, ProfileSettingsDeleteArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileSettings.
     * @param {ProfileSettingsUpdateArgs} args - Arguments to update one ProfileSettings.
     * @example
     * // Update one ProfileSettings
     * const profileSettings = await prisma.profileSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileSettingsUpdateArgs>(args: SelectSubset<T, ProfileSettingsUpdateArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileSettings.
     * @param {ProfileSettingsDeleteManyArgs} args - Arguments to filter ProfileSettings to delete.
     * @example
     * // Delete a few ProfileSettings
     * const { count } = await prisma.profileSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileSettingsDeleteManyArgs>(args?: SelectSubset<T, ProfileSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileSettings
     * const profileSettings = await prisma.profileSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileSettingsUpdateManyArgs>(args: SelectSubset<T, ProfileSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileSettings and returns the data updated in the database.
     * @param {ProfileSettingsUpdateManyAndReturnArgs} args - Arguments to update many ProfileSettings.
     * @example
     * // Update many ProfileSettings
     * const profileSettings = await prisma.profileSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfileSettings and only return the `profileId`
     * const profileSettingsWithProfileIdOnly = await prisma.profileSettings.updateManyAndReturn({
     *   select: { profileId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfileSettings.
     * @param {ProfileSettingsUpsertArgs} args - Arguments to update or create a ProfileSettings.
     * @example
     * // Update or create a ProfileSettings
     * const profileSettings = await prisma.profileSettings.upsert({
     *   create: {
     *     // ... data to create a ProfileSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileSettings we want to update
     *   }
     * })
     */
    upsert<T extends ProfileSettingsUpsertArgs>(args: SelectSubset<T, ProfileSettingsUpsertArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsCountArgs} args - Arguments to filter ProfileSettings to count.
     * @example
     * // Count the number of ProfileSettings
     * const count = await prisma.profileSettings.count({
     *   where: {
     *     // ... the filter for the ProfileSettings we want to count
     *   }
     * })
    **/
    count<T extends ProfileSettingsCountArgs>(
      args?: Subset<T, ProfileSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileSettingsAggregateArgs>(args: Subset<T, ProfileSettingsAggregateArgs>): Prisma.PrismaPromise<GetProfileSettingsAggregateType<T>>

    /**
     * Group by ProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileSettingsGroupByArgs['orderBy'] }
        : { orderBy?: ProfileSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileSettings model
   */
  readonly fields: ProfileSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileSettings model
   */
  interface ProfileSettingsFieldRefs {
    readonly profileId: FieldRef<"ProfileSettings", 'String'>
    readonly isPrivate: FieldRef<"ProfileSettings", 'Boolean'>
    readonly showLastSeen: FieldRef<"ProfileSettings", 'Boolean'>
    readonly allowTagging: FieldRef<"ProfileSettings", 'Boolean'>
    readonly allowMessagesFrom: FieldRef<"ProfileSettings", 'String'>
    readonly discoveryAllowLineage: FieldRef<"ProfileSettings", 'Boolean'>
    readonly createdAt: FieldRef<"ProfileSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfileSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileSettings findUnique
   */
  export type ProfileSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where: ProfileSettingsWhereUniqueInput
  }

  /**
   * ProfileSettings findUniqueOrThrow
   */
  export type ProfileSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where: ProfileSettingsWhereUniqueInput
  }

  /**
   * ProfileSettings findFirst
   */
  export type ProfileSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where?: ProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileSettings to fetch.
     */
    orderBy?: ProfileSettingsOrderByWithRelationInput | ProfileSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileSettings.
     */
    cursor?: ProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileSettings.
     */
    distinct?: ProfileSettingsScalarFieldEnum | ProfileSettingsScalarFieldEnum[]
  }

  /**
   * ProfileSettings findFirstOrThrow
   */
  export type ProfileSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where?: ProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileSettings to fetch.
     */
    orderBy?: ProfileSettingsOrderByWithRelationInput | ProfileSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileSettings.
     */
    cursor?: ProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileSettings.
     */
    distinct?: ProfileSettingsScalarFieldEnum | ProfileSettingsScalarFieldEnum[]
  }

  /**
   * ProfileSettings findMany
   */
  export type ProfileSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where?: ProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileSettings to fetch.
     */
    orderBy?: ProfileSettingsOrderByWithRelationInput | ProfileSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileSettings.
     */
    cursor?: ProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileSettings.
     */
    skip?: number
    distinct?: ProfileSettingsScalarFieldEnum | ProfileSettingsScalarFieldEnum[]
  }

  /**
   * ProfileSettings create
   */
  export type ProfileSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileSettings.
     */
    data: XOR<ProfileSettingsCreateInput, ProfileSettingsUncheckedCreateInput>
  }

  /**
   * ProfileSettings createMany
   */
  export type ProfileSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileSettings.
     */
    data: ProfileSettingsCreateManyInput | ProfileSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileSettings createManyAndReturn
   */
  export type ProfileSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many ProfileSettings.
     */
    data: ProfileSettingsCreateManyInput | ProfileSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileSettings update
   */
  export type ProfileSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileSettings.
     */
    data: XOR<ProfileSettingsUpdateInput, ProfileSettingsUncheckedUpdateInput>
    /**
     * Choose, which ProfileSettings to update.
     */
    where: ProfileSettingsWhereUniqueInput
  }

  /**
   * ProfileSettings updateMany
   */
  export type ProfileSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileSettings.
     */
    data: XOR<ProfileSettingsUpdateManyMutationInput, ProfileSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ProfileSettings to update
     */
    where?: ProfileSettingsWhereInput
    /**
     * Limit how many ProfileSettings to update.
     */
    limit?: number
  }

  /**
   * ProfileSettings updateManyAndReturn
   */
  export type ProfileSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * The data used to update ProfileSettings.
     */
    data: XOR<ProfileSettingsUpdateManyMutationInput, ProfileSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ProfileSettings to update
     */
    where?: ProfileSettingsWhereInput
    /**
     * Limit how many ProfileSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileSettings upsert
   */
  export type ProfileSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileSettings to update in case it exists.
     */
    where: ProfileSettingsWhereUniqueInput
    /**
     * In case the ProfileSettings found by the `where` argument doesn't exist, create a new ProfileSettings with this data.
     */
    create: XOR<ProfileSettingsCreateInput, ProfileSettingsUncheckedCreateInput>
    /**
     * In case the ProfileSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileSettingsUpdateInput, ProfileSettingsUncheckedUpdateInput>
  }

  /**
   * ProfileSettings delete
   */
  export type ProfileSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter which ProfileSettings to delete.
     */
    where: ProfileSettingsWhereUniqueInput
  }

  /**
   * ProfileSettings deleteMany
   */
  export type ProfileSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileSettings to delete
     */
    where?: ProfileSettingsWhereInput
    /**
     * Limit how many ProfileSettings to delete.
     */
    limit?: number
  }

  /**
   * ProfileSettings without action
   */
  export type ProfileSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
  }


  /**
   * Model FriendRequest
   */

  export type AggregateFriendRequest = {
    _count: FriendRequestCountAggregateOutputType | null
    _min: FriendRequestMinAggregateOutputType | null
    _max: FriendRequestMaxAggregateOutputType | null
  }

  export type FriendRequestMinAggregateOutputType = {
    id: string | null
    requesterId: string | null
    addresseeId: string | null
    status: $Enums.FriendRequestStatus | null
    createdAt: Date | null
    respondedAt: Date | null
  }

  export type FriendRequestMaxAggregateOutputType = {
    id: string | null
    requesterId: string | null
    addresseeId: string | null
    status: $Enums.FriendRequestStatus | null
    createdAt: Date | null
    respondedAt: Date | null
  }

  export type FriendRequestCountAggregateOutputType = {
    id: number
    requesterId: number
    addresseeId: number
    status: number
    createdAt: number
    respondedAt: number
    _all: number
  }


  export type FriendRequestMinAggregateInputType = {
    id?: true
    requesterId?: true
    addresseeId?: true
    status?: true
    createdAt?: true
    respondedAt?: true
  }

  export type FriendRequestMaxAggregateInputType = {
    id?: true
    requesterId?: true
    addresseeId?: true
    status?: true
    createdAt?: true
    respondedAt?: true
  }

  export type FriendRequestCountAggregateInputType = {
    id?: true
    requesterId?: true
    addresseeId?: true
    status?: true
    createdAt?: true
    respondedAt?: true
    _all?: true
  }

  export type FriendRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FriendRequest to aggregate.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FriendRequests
    **/
    _count?: true | FriendRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendRequestMaxAggregateInputType
  }

  export type GetFriendRequestAggregateType<T extends FriendRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendRequest[P]>
      : GetScalarType<T[P], AggregateFriendRequest[P]>
  }




  export type FriendRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendRequestWhereInput
    orderBy?: FriendRequestOrderByWithAggregationInput | FriendRequestOrderByWithAggregationInput[]
    by: FriendRequestScalarFieldEnum[] | FriendRequestScalarFieldEnum
    having?: FriendRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendRequestCountAggregateInputType | true
    _min?: FriendRequestMinAggregateInputType
    _max?: FriendRequestMaxAggregateInputType
  }

  export type FriendRequestGroupByOutputType = {
    id: string
    requesterId: string
    addresseeId: string
    status: $Enums.FriendRequestStatus
    createdAt: Date
    respondedAt: Date | null
    _count: FriendRequestCountAggregateOutputType | null
    _min: FriendRequestMinAggregateOutputType | null
    _max: FriendRequestMaxAggregateOutputType | null
  }

  type GetFriendRequestGroupByPayload<T extends FriendRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendRequestGroupByOutputType[P]>
            : GetScalarType<T[P], FriendRequestGroupByOutputType[P]>
        }
      >
    >


  export type FriendRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    addresseeId?: boolean
    status?: boolean
    createdAt?: boolean
    respondedAt?: boolean
    notifications?: boolean | FriendRequest$notificationsArgs<ExtArgs>
    requester?: boolean | ProfileDefaultArgs<ExtArgs>
    addressee?: boolean | ProfileDefaultArgs<ExtArgs>
    _count?: boolean | FriendRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendRequest"]>

  export type FriendRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    addresseeId?: boolean
    status?: boolean
    createdAt?: boolean
    respondedAt?: boolean
    requester?: boolean | ProfileDefaultArgs<ExtArgs>
    addressee?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendRequest"]>

  export type FriendRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requesterId?: boolean
    addresseeId?: boolean
    status?: boolean
    createdAt?: boolean
    respondedAt?: boolean
    requester?: boolean | ProfileDefaultArgs<ExtArgs>
    addressee?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendRequest"]>

  export type FriendRequestSelectScalar = {
    id?: boolean
    requesterId?: boolean
    addresseeId?: boolean
    status?: boolean
    createdAt?: boolean
    respondedAt?: boolean
  }

  export type FriendRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requesterId" | "addresseeId" | "status" | "createdAt" | "respondedAt", ExtArgs["result"]["friendRequest"]>
  export type FriendRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | FriendRequest$notificationsArgs<ExtArgs>
    requester?: boolean | ProfileDefaultArgs<ExtArgs>
    addressee?: boolean | ProfileDefaultArgs<ExtArgs>
    _count?: boolean | FriendRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FriendRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | ProfileDefaultArgs<ExtArgs>
    addressee?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type FriendRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | ProfileDefaultArgs<ExtArgs>
    addressee?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $FriendRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FriendRequest"
    objects: {
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      requester: Prisma.$ProfilePayload<ExtArgs>
      addressee: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requesterId: string
      addresseeId: string
      status: $Enums.FriendRequestStatus
      createdAt: Date
      respondedAt: Date | null
    }, ExtArgs["result"]["friendRequest"]>
    composites: {}
  }

  type FriendRequestGetPayload<S extends boolean | null | undefined | FriendRequestDefaultArgs> = $Result.GetResult<Prisma.$FriendRequestPayload, S>

  type FriendRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FriendRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendRequestCountAggregateInputType | true
    }

  export interface FriendRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FriendRequest'], meta: { name: 'FriendRequest' } }
    /**
     * Find zero or one FriendRequest that matches the filter.
     * @param {FriendRequestFindUniqueArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendRequestFindUniqueArgs>(args: SelectSubset<T, FriendRequestFindUniqueArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FriendRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FriendRequestFindUniqueOrThrowArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FriendRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestFindFirstArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendRequestFindFirstArgs>(args?: SelectSubset<T, FriendRequestFindFirstArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FriendRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestFindFirstOrThrowArgs} args - Arguments to find a FriendRequest
     * @example
     * // Get one FriendRequest
     * const friendRequest = await prisma.friendRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FriendRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FriendRequests
     * const friendRequests = await prisma.friendRequest.findMany()
     * 
     * // Get first 10 FriendRequests
     * const friendRequests = await prisma.friendRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendRequestWithIdOnly = await prisma.friendRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendRequestFindManyArgs>(args?: SelectSubset<T, FriendRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FriendRequest.
     * @param {FriendRequestCreateArgs} args - Arguments to create a FriendRequest.
     * @example
     * // Create one FriendRequest
     * const FriendRequest = await prisma.friendRequest.create({
     *   data: {
     *     // ... data to create a FriendRequest
     *   }
     * })
     * 
     */
    create<T extends FriendRequestCreateArgs>(args: SelectSubset<T, FriendRequestCreateArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FriendRequests.
     * @param {FriendRequestCreateManyArgs} args - Arguments to create many FriendRequests.
     * @example
     * // Create many FriendRequests
     * const friendRequest = await prisma.friendRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendRequestCreateManyArgs>(args?: SelectSubset<T, FriendRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FriendRequests and returns the data saved in the database.
     * @param {FriendRequestCreateManyAndReturnArgs} args - Arguments to create many FriendRequests.
     * @example
     * // Create many FriendRequests
     * const friendRequest = await prisma.friendRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FriendRequests and only return the `id`
     * const friendRequestWithIdOnly = await prisma.friendRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FriendRequest.
     * @param {FriendRequestDeleteArgs} args - Arguments to delete one FriendRequest.
     * @example
     * // Delete one FriendRequest
     * const FriendRequest = await prisma.friendRequest.delete({
     *   where: {
     *     // ... filter to delete one FriendRequest
     *   }
     * })
     * 
     */
    delete<T extends FriendRequestDeleteArgs>(args: SelectSubset<T, FriendRequestDeleteArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FriendRequest.
     * @param {FriendRequestUpdateArgs} args - Arguments to update one FriendRequest.
     * @example
     * // Update one FriendRequest
     * const friendRequest = await prisma.friendRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendRequestUpdateArgs>(args: SelectSubset<T, FriendRequestUpdateArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FriendRequests.
     * @param {FriendRequestDeleteManyArgs} args - Arguments to filter FriendRequests to delete.
     * @example
     * // Delete a few FriendRequests
     * const { count } = await prisma.friendRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendRequestDeleteManyArgs>(args?: SelectSubset<T, FriendRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FriendRequests
     * const friendRequest = await prisma.friendRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendRequestUpdateManyArgs>(args: SelectSubset<T, FriendRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FriendRequests and returns the data updated in the database.
     * @param {FriendRequestUpdateManyAndReturnArgs} args - Arguments to update many FriendRequests.
     * @example
     * // Update many FriendRequests
     * const friendRequest = await prisma.friendRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FriendRequests and only return the `id`
     * const friendRequestWithIdOnly = await prisma.friendRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FriendRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, FriendRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FriendRequest.
     * @param {FriendRequestUpsertArgs} args - Arguments to update or create a FriendRequest.
     * @example
     * // Update or create a FriendRequest
     * const friendRequest = await prisma.friendRequest.upsert({
     *   create: {
     *     // ... data to create a FriendRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FriendRequest we want to update
     *   }
     * })
     */
    upsert<T extends FriendRequestUpsertArgs>(args: SelectSubset<T, FriendRequestUpsertArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FriendRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestCountArgs} args - Arguments to filter FriendRequests to count.
     * @example
     * // Count the number of FriendRequests
     * const count = await prisma.friendRequest.count({
     *   where: {
     *     // ... the filter for the FriendRequests we want to count
     *   }
     * })
    **/
    count<T extends FriendRequestCountArgs>(
      args?: Subset<T, FriendRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FriendRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendRequestAggregateArgs>(args: Subset<T, FriendRequestAggregateArgs>): Prisma.PrismaPromise<GetFriendRequestAggregateType<T>>

    /**
     * Group by FriendRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendRequestGroupByArgs['orderBy'] }
        : { orderBy?: FriendRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FriendRequest model
   */
  readonly fields: FriendRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FriendRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notifications<T extends FriendRequest$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, FriendRequest$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requester<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addressee<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FriendRequest model
   */
  interface FriendRequestFieldRefs {
    readonly id: FieldRef<"FriendRequest", 'String'>
    readonly requesterId: FieldRef<"FriendRequest", 'String'>
    readonly addresseeId: FieldRef<"FriendRequest", 'String'>
    readonly status: FieldRef<"FriendRequest", 'FriendRequestStatus'>
    readonly createdAt: FieldRef<"FriendRequest", 'DateTime'>
    readonly respondedAt: FieldRef<"FriendRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FriendRequest findUnique
   */
  export type FriendRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where: FriendRequestWhereUniqueInput
  }

  /**
   * FriendRequest findUniqueOrThrow
   */
  export type FriendRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where: FriendRequestWhereUniqueInput
  }

  /**
   * FriendRequest findFirst
   */
  export type FriendRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendRequests.
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendRequests.
     */
    distinct?: FriendRequestScalarFieldEnum | FriendRequestScalarFieldEnum[]
  }

  /**
   * FriendRequest findFirstOrThrow
   */
  export type FriendRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    /**
     * Filter, which FriendRequest to fetch.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FriendRequests.
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FriendRequests.
     */
    distinct?: FriendRequestScalarFieldEnum | FriendRequestScalarFieldEnum[]
  }

  /**
   * FriendRequest findMany
   */
  export type FriendRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    /**
     * Filter, which FriendRequests to fetch.
     */
    where?: FriendRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FriendRequests to fetch.
     */
    orderBy?: FriendRequestOrderByWithRelationInput | FriendRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FriendRequests.
     */
    cursor?: FriendRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FriendRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FriendRequests.
     */
    skip?: number
    distinct?: FriendRequestScalarFieldEnum | FriendRequestScalarFieldEnum[]
  }

  /**
   * FriendRequest create
   */
  export type FriendRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a FriendRequest.
     */
    data: XOR<FriendRequestCreateInput, FriendRequestUncheckedCreateInput>
  }

  /**
   * FriendRequest createMany
   */
  export type FriendRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FriendRequests.
     */
    data: FriendRequestCreateManyInput | FriendRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FriendRequest createManyAndReturn
   */
  export type FriendRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * The data used to create many FriendRequests.
     */
    data: FriendRequestCreateManyInput | FriendRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FriendRequest update
   */
  export type FriendRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a FriendRequest.
     */
    data: XOR<FriendRequestUpdateInput, FriendRequestUncheckedUpdateInput>
    /**
     * Choose, which FriendRequest to update.
     */
    where: FriendRequestWhereUniqueInput
  }

  /**
   * FriendRequest updateMany
   */
  export type FriendRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FriendRequests.
     */
    data: XOR<FriendRequestUpdateManyMutationInput, FriendRequestUncheckedUpdateManyInput>
    /**
     * Filter which FriendRequests to update
     */
    where?: FriendRequestWhereInput
    /**
     * Limit how many FriendRequests to update.
     */
    limit?: number
  }

  /**
   * FriendRequest updateManyAndReturn
   */
  export type FriendRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * The data used to update FriendRequests.
     */
    data: XOR<FriendRequestUpdateManyMutationInput, FriendRequestUncheckedUpdateManyInput>
    /**
     * Filter which FriendRequests to update
     */
    where?: FriendRequestWhereInput
    /**
     * Limit how many FriendRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FriendRequest upsert
   */
  export type FriendRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the FriendRequest to update in case it exists.
     */
    where: FriendRequestWhereUniqueInput
    /**
     * In case the FriendRequest found by the `where` argument doesn't exist, create a new FriendRequest with this data.
     */
    create: XOR<FriendRequestCreateInput, FriendRequestUncheckedCreateInput>
    /**
     * In case the FriendRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendRequestUpdateInput, FriendRequestUncheckedUpdateInput>
  }

  /**
   * FriendRequest delete
   */
  export type FriendRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    /**
     * Filter which FriendRequest to delete.
     */
    where: FriendRequestWhereUniqueInput
  }

  /**
   * FriendRequest deleteMany
   */
  export type FriendRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FriendRequests to delete
     */
    where?: FriendRequestWhereInput
    /**
     * Limit how many FriendRequests to delete.
     */
    limit?: number
  }

  /**
   * FriendRequest.notifications
   */
  export type FriendRequest$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * FriendRequest without action
   */
  export type FriendRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
  }


  /**
   * Model Friendship
   */

  export type AggregateFriendship = {
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  export type FriendshipMinAggregateOutputType = {
    id: string | null
    userAId: string | null
    userBId: string | null
    createdAt: Date | null
  }

  export type FriendshipMaxAggregateOutputType = {
    id: string | null
    userAId: string | null
    userBId: string | null
    createdAt: Date | null
  }

  export type FriendshipCountAggregateOutputType = {
    id: number
    userAId: number
    userBId: number
    createdAt: number
    _all: number
  }


  export type FriendshipMinAggregateInputType = {
    id?: true
    userAId?: true
    userBId?: true
    createdAt?: true
  }

  export type FriendshipMaxAggregateInputType = {
    id?: true
    userAId?: true
    userBId?: true
    createdAt?: true
  }

  export type FriendshipCountAggregateInputType = {
    id?: true
    userAId?: true
    userBId?: true
    createdAt?: true
    _all?: true
  }

  export type FriendshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendship to aggregate.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friendships
    **/
    _count?: true | FriendshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendshipMaxAggregateInputType
  }

  export type GetFriendshipAggregateType<T extends FriendshipAggregateArgs> = {
        [P in keyof T & keyof AggregateFriendship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriendship[P]>
      : GetScalarType<T[P], AggregateFriendship[P]>
  }




  export type FriendshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendshipWhereInput
    orderBy?: FriendshipOrderByWithAggregationInput | FriendshipOrderByWithAggregationInput[]
    by: FriendshipScalarFieldEnum[] | FriendshipScalarFieldEnum
    having?: FriendshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendshipCountAggregateInputType | true
    _min?: FriendshipMinAggregateInputType
    _max?: FriendshipMaxAggregateInputType
  }

  export type FriendshipGroupByOutputType = {
    id: string
    userAId: string
    userBId: string
    createdAt: Date
    _count: FriendshipCountAggregateOutputType | null
    _min: FriendshipMinAggregateOutputType | null
    _max: FriendshipMaxAggregateOutputType | null
  }

  type GetFriendshipGroupByPayload<T extends FriendshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
            : GetScalarType<T[P], FriendshipGroupByOutputType[P]>
        }
      >
    >


  export type FriendshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userAId?: boolean
    userBId?: boolean
    createdAt?: boolean
    userA?: boolean | ProfileDefaultArgs<ExtArgs>
    userB?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userAId?: boolean
    userBId?: boolean
    createdAt?: boolean
    userA?: boolean | ProfileDefaultArgs<ExtArgs>
    userB?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userAId?: boolean
    userBId?: boolean
    createdAt?: boolean
    userA?: boolean | ProfileDefaultArgs<ExtArgs>
    userB?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friendship"]>

  export type FriendshipSelectScalar = {
    id?: boolean
    userAId?: boolean
    userBId?: boolean
    createdAt?: boolean
  }

  export type FriendshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userAId" | "userBId" | "createdAt", ExtArgs["result"]["friendship"]>
  export type FriendshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userA?: boolean | ProfileDefaultArgs<ExtArgs>
    userB?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userA?: boolean | ProfileDefaultArgs<ExtArgs>
    userB?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type FriendshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userA?: boolean | ProfileDefaultArgs<ExtArgs>
    userB?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $FriendshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friendship"
    objects: {
      userA: Prisma.$ProfilePayload<ExtArgs>
      userB: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userAId: string
      userBId: string
      createdAt: Date
    }, ExtArgs["result"]["friendship"]>
    composites: {}
  }

  type FriendshipGetPayload<S extends boolean | null | undefined | FriendshipDefaultArgs> = $Result.GetResult<Prisma.$FriendshipPayload, S>

  type FriendshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FriendshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendshipCountAggregateInputType | true
    }

  export interface FriendshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friendship'], meta: { name: 'Friendship' } }
    /**
     * Find zero or one Friendship that matches the filter.
     * @param {FriendshipFindUniqueArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendshipFindUniqueArgs>(args: SelectSubset<T, FriendshipFindUniqueArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Friendship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FriendshipFindUniqueOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendshipFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendshipFindFirstArgs>(args?: SelectSubset<T, FriendshipFindFirstArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friendship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindFirstOrThrowArgs} args - Arguments to find a Friendship
     * @example
     * // Get one Friendship
     * const friendship = await prisma.friendship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendshipFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Friendships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friendships
     * const friendships = await prisma.friendship.findMany()
     * 
     * // Get first 10 Friendships
     * const friendships = await prisma.friendship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const friendshipWithIdOnly = await prisma.friendship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FriendshipFindManyArgs>(args?: SelectSubset<T, FriendshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Friendship.
     * @param {FriendshipCreateArgs} args - Arguments to create a Friendship.
     * @example
     * // Create one Friendship
     * const Friendship = await prisma.friendship.create({
     *   data: {
     *     // ... data to create a Friendship
     *   }
     * })
     * 
     */
    create<T extends FriendshipCreateArgs>(args: SelectSubset<T, FriendshipCreateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Friendships.
     * @param {FriendshipCreateManyArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendshipCreateManyArgs>(args?: SelectSubset<T, FriendshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friendships and returns the data saved in the database.
     * @param {FriendshipCreateManyAndReturnArgs} args - Arguments to create many Friendships.
     * @example
     * // Create many Friendships
     * const friendship = await prisma.friendship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendshipCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Friendship.
     * @param {FriendshipDeleteArgs} args - Arguments to delete one Friendship.
     * @example
     * // Delete one Friendship
     * const Friendship = await prisma.friendship.delete({
     *   where: {
     *     // ... filter to delete one Friendship
     *   }
     * })
     * 
     */
    delete<T extends FriendshipDeleteArgs>(args: SelectSubset<T, FriendshipDeleteArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Friendship.
     * @param {FriendshipUpdateArgs} args - Arguments to update one Friendship.
     * @example
     * // Update one Friendship
     * const friendship = await prisma.friendship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendshipUpdateArgs>(args: SelectSubset<T, FriendshipUpdateArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Friendships.
     * @param {FriendshipDeleteManyArgs} args - Arguments to filter Friendships to delete.
     * @example
     * // Delete a few Friendships
     * const { count } = await prisma.friendship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendshipDeleteManyArgs>(args?: SelectSubset<T, FriendshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendshipUpdateManyArgs>(args: SelectSubset<T, FriendshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friendships and returns the data updated in the database.
     * @param {FriendshipUpdateManyAndReturnArgs} args - Arguments to update many Friendships.
     * @example
     * // Update many Friendships
     * const friendship = await prisma.friendship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Friendships and only return the `id`
     * const friendshipWithIdOnly = await prisma.friendship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FriendshipUpdateManyAndReturnArgs>(args: SelectSubset<T, FriendshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Friendship.
     * @param {FriendshipUpsertArgs} args - Arguments to update or create a Friendship.
     * @example
     * // Update or create a Friendship
     * const friendship = await prisma.friendship.upsert({
     *   create: {
     *     // ... data to create a Friendship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friendship we want to update
     *   }
     * })
     */
    upsert<T extends FriendshipUpsertArgs>(args: SelectSubset<T, FriendshipUpsertArgs<ExtArgs>>): Prisma__FriendshipClient<$Result.GetResult<Prisma.$FriendshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Friendships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipCountArgs} args - Arguments to filter Friendships to count.
     * @example
     * // Count the number of Friendships
     * const count = await prisma.friendship.count({
     *   where: {
     *     // ... the filter for the Friendships we want to count
     *   }
     * })
    **/
    count<T extends FriendshipCountArgs>(
      args?: Subset<T, FriendshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendshipAggregateArgs>(args: Subset<T, FriendshipAggregateArgs>): Prisma.PrismaPromise<GetFriendshipAggregateType<T>>

    /**
     * Group by Friendship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendshipGroupByArgs['orderBy'] }
        : { orderBy?: FriendshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friendship model
   */
  readonly fields: FriendshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friendship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userA<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    userB<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friendship model
   */
  interface FriendshipFieldRefs {
    readonly id: FieldRef<"Friendship", 'String'>
    readonly userAId: FieldRef<"Friendship", 'String'>
    readonly userBId: FieldRef<"Friendship", 'String'>
    readonly createdAt: FieldRef<"Friendship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Friendship findUnique
   */
  export type FriendshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findUniqueOrThrow
   */
  export type FriendshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship findFirst
   */
  export type FriendshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findFirstOrThrow
   */
  export type FriendshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendship to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friendships.
     */
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship findMany
   */
  export type FriendshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter, which Friendships to fetch.
     */
    where?: FriendshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friendships to fetch.
     */
    orderBy?: FriendshipOrderByWithRelationInput | FriendshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friendships.
     */
    cursor?: FriendshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friendships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friendships.
     */
    skip?: number
    distinct?: FriendshipScalarFieldEnum | FriendshipScalarFieldEnum[]
  }

  /**
   * Friendship create
   */
  export type FriendshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Friendship.
     */
    data: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
  }

  /**
   * Friendship createMany
   */
  export type FriendshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Friendship createManyAndReturn
   */
  export type FriendshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * The data used to create many Friendships.
     */
    data: FriendshipCreateManyInput | FriendshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship update
   */
  export type FriendshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Friendship.
     */
    data: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
    /**
     * Choose, which Friendship to update.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship updateMany
   */
  export type FriendshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
    /**
     * Limit how many Friendships to update.
     */
    limit?: number
  }

  /**
   * Friendship updateManyAndReturn
   */
  export type FriendshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * The data used to update Friendships.
     */
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyInput>
    /**
     * Filter which Friendships to update
     */
    where?: FriendshipWhereInput
    /**
     * Limit how many Friendships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friendship upsert
   */
  export type FriendshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Friendship to update in case it exists.
     */
    where: FriendshipWhereUniqueInput
    /**
     * In case the Friendship found by the `where` argument doesn't exist, create a new Friendship with this data.
     */
    create: XOR<FriendshipCreateInput, FriendshipUncheckedCreateInput>
    /**
     * In case the Friendship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendshipUpdateInput, FriendshipUncheckedUpdateInput>
  }

  /**
   * Friendship delete
   */
  export type FriendshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
    /**
     * Filter which Friendship to delete.
     */
    where: FriendshipWhereUniqueInput
  }

  /**
   * Friendship deleteMany
   */
  export type FriendshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friendships to delete
     */
    where?: FriendshipWhereInput
    /**
     * Limit how many Friendships to delete.
     */
    limit?: number
  }

  /**
   * Friendship without action
   */
  export type FriendshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friendship
     */
    select?: FriendshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friendship
     */
    omit?: FriendshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendshipInclude<ExtArgs> | null
  }


  /**
   * Model Clan
   */

  export type AggregateClan = {
    _count: ClanCountAggregateOutputType | null
    _min: ClanMinAggregateOutputType | null
    _max: ClanMaxAggregateOutputType | null
  }

  export type ClanMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ClanMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type ClanCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type ClanMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type ClanMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type ClanCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type ClanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clan to aggregate.
     */
    where?: ClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clans to fetch.
     */
    orderBy?: ClanOrderByWithRelationInput | ClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clans
    **/
    _count?: true | ClanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClanMaxAggregateInputType
  }

  export type GetClanAggregateType<T extends ClanAggregateArgs> = {
        [P in keyof T & keyof AggregateClan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClan[P]>
      : GetScalarType<T[P], AggregateClan[P]>
  }




  export type ClanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClanWhereInput
    orderBy?: ClanOrderByWithAggregationInput | ClanOrderByWithAggregationInput[]
    by: ClanScalarFieldEnum[] | ClanScalarFieldEnum
    having?: ClanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClanCountAggregateInputType | true
    _min?: ClanMinAggregateInputType
    _max?: ClanMaxAggregateInputType
  }

  export type ClanGroupByOutputType = {
    id: string
    name: string
    _count: ClanCountAggregateOutputType | null
    _min: ClanMinAggregateOutputType | null
    _max: ClanMaxAggregateOutputType | null
  }

  type GetClanGroupByPayload<T extends ClanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClanGroupByOutputType[P]>
            : GetScalarType<T[P], ClanGroupByOutputType[P]>
        }
      >
    >


  export type ClanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    members?: boolean | Clan$membersArgs<ExtArgs>
    _count?: boolean | ClanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clan"]>

  export type ClanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["clan"]>

  export type ClanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["clan"]>

  export type ClanSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type ClanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["clan"]>
  export type ClanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Clan$membersArgs<ExtArgs>
    _count?: boolean | ClanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ClanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clan"
    objects: {
      members: Prisma.$ProfileClanPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["clan"]>
    composites: {}
  }

  type ClanGetPayload<S extends boolean | null | undefined | ClanDefaultArgs> = $Result.GetResult<Prisma.$ClanPayload, S>

  type ClanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClanCountAggregateInputType | true
    }

  export interface ClanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clan'], meta: { name: 'Clan' } }
    /**
     * Find zero or one Clan that matches the filter.
     * @param {ClanFindUniqueArgs} args - Arguments to find a Clan
     * @example
     * // Get one Clan
     * const clan = await prisma.clan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClanFindUniqueArgs>(args: SelectSubset<T, ClanFindUniqueArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Clan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClanFindUniqueOrThrowArgs} args - Arguments to find a Clan
     * @example
     * // Get one Clan
     * const clan = await prisma.clan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClanFindUniqueOrThrowArgs>(args: SelectSubset<T, ClanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanFindFirstArgs} args - Arguments to find a Clan
     * @example
     * // Get one Clan
     * const clan = await prisma.clan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClanFindFirstArgs>(args?: SelectSubset<T, ClanFindFirstArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Clan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanFindFirstOrThrowArgs} args - Arguments to find a Clan
     * @example
     * // Get one Clan
     * const clan = await prisma.clan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClanFindFirstOrThrowArgs>(args?: SelectSubset<T, ClanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Clans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clans
     * const clans = await prisma.clan.findMany()
     * 
     * // Get first 10 Clans
     * const clans = await prisma.clan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clanWithIdOnly = await prisma.clan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClanFindManyArgs>(args?: SelectSubset<T, ClanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Clan.
     * @param {ClanCreateArgs} args - Arguments to create a Clan.
     * @example
     * // Create one Clan
     * const Clan = await prisma.clan.create({
     *   data: {
     *     // ... data to create a Clan
     *   }
     * })
     * 
     */
    create<T extends ClanCreateArgs>(args: SelectSubset<T, ClanCreateArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Clans.
     * @param {ClanCreateManyArgs} args - Arguments to create many Clans.
     * @example
     * // Create many Clans
     * const clan = await prisma.clan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClanCreateManyArgs>(args?: SelectSubset<T, ClanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clans and returns the data saved in the database.
     * @param {ClanCreateManyAndReturnArgs} args - Arguments to create many Clans.
     * @example
     * // Create many Clans
     * const clan = await prisma.clan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clans and only return the `id`
     * const clanWithIdOnly = await prisma.clan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClanCreateManyAndReturnArgs>(args?: SelectSubset<T, ClanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Clan.
     * @param {ClanDeleteArgs} args - Arguments to delete one Clan.
     * @example
     * // Delete one Clan
     * const Clan = await prisma.clan.delete({
     *   where: {
     *     // ... filter to delete one Clan
     *   }
     * })
     * 
     */
    delete<T extends ClanDeleteArgs>(args: SelectSubset<T, ClanDeleteArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Clan.
     * @param {ClanUpdateArgs} args - Arguments to update one Clan.
     * @example
     * // Update one Clan
     * const clan = await prisma.clan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClanUpdateArgs>(args: SelectSubset<T, ClanUpdateArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Clans.
     * @param {ClanDeleteManyArgs} args - Arguments to filter Clans to delete.
     * @example
     * // Delete a few Clans
     * const { count } = await prisma.clan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClanDeleteManyArgs>(args?: SelectSubset<T, ClanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clans
     * const clan = await prisma.clan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClanUpdateManyArgs>(args: SelectSubset<T, ClanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clans and returns the data updated in the database.
     * @param {ClanUpdateManyAndReturnArgs} args - Arguments to update many Clans.
     * @example
     * // Update many Clans
     * const clan = await prisma.clan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Clans and only return the `id`
     * const clanWithIdOnly = await prisma.clan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClanUpdateManyAndReturnArgs>(args: SelectSubset<T, ClanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Clan.
     * @param {ClanUpsertArgs} args - Arguments to update or create a Clan.
     * @example
     * // Update or create a Clan
     * const clan = await prisma.clan.upsert({
     *   create: {
     *     // ... data to create a Clan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clan we want to update
     *   }
     * })
     */
    upsert<T extends ClanUpsertArgs>(args: SelectSubset<T, ClanUpsertArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Clans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanCountArgs} args - Arguments to filter Clans to count.
     * @example
     * // Count the number of Clans
     * const count = await prisma.clan.count({
     *   where: {
     *     // ... the filter for the Clans we want to count
     *   }
     * })
    **/
    count<T extends ClanCountArgs>(
      args?: Subset<T, ClanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClanAggregateArgs>(args: Subset<T, ClanAggregateArgs>): Prisma.PrismaPromise<GetClanAggregateType<T>>

    /**
     * Group by Clan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClanGroupByArgs['orderBy'] }
        : { orderBy?: ClanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clan model
   */
  readonly fields: ClanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Clan$membersArgs<ExtArgs> = {}>(args?: Subset<T, Clan$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clan model
   */
  interface ClanFieldRefs {
    readonly id: FieldRef<"Clan", 'String'>
    readonly name: FieldRef<"Clan", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Clan findUnique
   */
  export type ClanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clan to fetch.
     */
    where: ClanWhereUniqueInput
  }

  /**
   * Clan findUniqueOrThrow
   */
  export type ClanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clan to fetch.
     */
    where: ClanWhereUniqueInput
  }

  /**
   * Clan findFirst
   */
  export type ClanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clan to fetch.
     */
    where?: ClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clans to fetch.
     */
    orderBy?: ClanOrderByWithRelationInput | ClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clans.
     */
    cursor?: ClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clans.
     */
    distinct?: ClanScalarFieldEnum | ClanScalarFieldEnum[]
  }

  /**
   * Clan findFirstOrThrow
   */
  export type ClanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clan to fetch.
     */
    where?: ClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clans to fetch.
     */
    orderBy?: ClanOrderByWithRelationInput | ClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clans.
     */
    cursor?: ClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clans.
     */
    distinct?: ClanScalarFieldEnum | ClanScalarFieldEnum[]
  }

  /**
   * Clan findMany
   */
  export type ClanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter, which Clans to fetch.
     */
    where?: ClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clans to fetch.
     */
    orderBy?: ClanOrderByWithRelationInput | ClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clans.
     */
    cursor?: ClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clans.
     */
    skip?: number
    distinct?: ClanScalarFieldEnum | ClanScalarFieldEnum[]
  }

  /**
   * Clan create
   */
  export type ClanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * The data needed to create a Clan.
     */
    data: XOR<ClanCreateInput, ClanUncheckedCreateInput>
  }

  /**
   * Clan createMany
   */
  export type ClanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clans.
     */
    data: ClanCreateManyInput | ClanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clan createManyAndReturn
   */
  export type ClanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * The data used to create many Clans.
     */
    data: ClanCreateManyInput | ClanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clan update
   */
  export type ClanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * The data needed to update a Clan.
     */
    data: XOR<ClanUpdateInput, ClanUncheckedUpdateInput>
    /**
     * Choose, which Clan to update.
     */
    where: ClanWhereUniqueInput
  }

  /**
   * Clan updateMany
   */
  export type ClanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clans.
     */
    data: XOR<ClanUpdateManyMutationInput, ClanUncheckedUpdateManyInput>
    /**
     * Filter which Clans to update
     */
    where?: ClanWhereInput
    /**
     * Limit how many Clans to update.
     */
    limit?: number
  }

  /**
   * Clan updateManyAndReturn
   */
  export type ClanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * The data used to update Clans.
     */
    data: XOR<ClanUpdateManyMutationInput, ClanUncheckedUpdateManyInput>
    /**
     * Filter which Clans to update
     */
    where?: ClanWhereInput
    /**
     * Limit how many Clans to update.
     */
    limit?: number
  }

  /**
   * Clan upsert
   */
  export type ClanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * The filter to search for the Clan to update in case it exists.
     */
    where: ClanWhereUniqueInput
    /**
     * In case the Clan found by the `where` argument doesn't exist, create a new Clan with this data.
     */
    create: XOR<ClanCreateInput, ClanUncheckedCreateInput>
    /**
     * In case the Clan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClanUpdateInput, ClanUncheckedUpdateInput>
  }

  /**
   * Clan delete
   */
  export type ClanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
    /**
     * Filter which Clan to delete.
     */
    where: ClanWhereUniqueInput
  }

  /**
   * Clan deleteMany
   */
  export type ClanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clans to delete
     */
    where?: ClanWhereInput
    /**
     * Limit how many Clans to delete.
     */
    limit?: number
  }

  /**
   * Clan.members
   */
  export type Clan$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    where?: ProfileClanWhereInput
    orderBy?: ProfileClanOrderByWithRelationInput | ProfileClanOrderByWithRelationInput[]
    cursor?: ProfileClanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileClanScalarFieldEnum | ProfileClanScalarFieldEnum[]
  }

  /**
   * Clan without action
   */
  export type ClanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clan
     */
    select?: ClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Clan
     */
    omit?: ClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClanInclude<ExtArgs> | null
  }


  /**
   * Model ProfileClan
   */

  export type AggregateProfileClan = {
    _count: ProfileClanCountAggregateOutputType | null
    _avg: ProfileClanAvgAggregateOutputType | null
    _sum: ProfileClanSumAggregateOutputType | null
    _min: ProfileClanMinAggregateOutputType | null
    _max: ProfileClanMaxAggregateOutputType | null
  }

  export type ProfileClanAvgAggregateOutputType = {
    order: number | null
  }

  export type ProfileClanSumAggregateOutputType = {
    order: number | null
  }

  export type ProfileClanMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    clanId: string | null
    order: number | null
  }

  export type ProfileClanMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    clanId: string | null
    order: number | null
  }

  export type ProfileClanCountAggregateOutputType = {
    id: number
    profileId: number
    clanId: number
    order: number
    _all: number
  }


  export type ProfileClanAvgAggregateInputType = {
    order?: true
  }

  export type ProfileClanSumAggregateInputType = {
    order?: true
  }

  export type ProfileClanMinAggregateInputType = {
    id?: true
    profileId?: true
    clanId?: true
    order?: true
  }

  export type ProfileClanMaxAggregateInputType = {
    id?: true
    profileId?: true
    clanId?: true
    order?: true
  }

  export type ProfileClanCountAggregateInputType = {
    id?: true
    profileId?: true
    clanId?: true
    order?: true
    _all?: true
  }

  export type ProfileClanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileClan to aggregate.
     */
    where?: ProfileClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileClans to fetch.
     */
    orderBy?: ProfileClanOrderByWithRelationInput | ProfileClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileClans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileClans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileClans
    **/
    _count?: true | ProfileClanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileClanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileClanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileClanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileClanMaxAggregateInputType
  }

  export type GetProfileClanAggregateType<T extends ProfileClanAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileClan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileClan[P]>
      : GetScalarType<T[P], AggregateProfileClan[P]>
  }




  export type ProfileClanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileClanWhereInput
    orderBy?: ProfileClanOrderByWithAggregationInput | ProfileClanOrderByWithAggregationInput[]
    by: ProfileClanScalarFieldEnum[] | ProfileClanScalarFieldEnum
    having?: ProfileClanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileClanCountAggregateInputType | true
    _avg?: ProfileClanAvgAggregateInputType
    _sum?: ProfileClanSumAggregateInputType
    _min?: ProfileClanMinAggregateInputType
    _max?: ProfileClanMaxAggregateInputType
  }

  export type ProfileClanGroupByOutputType = {
    id: string
    profileId: string
    clanId: string
    order: number
    _count: ProfileClanCountAggregateOutputType | null
    _avg: ProfileClanAvgAggregateOutputType | null
    _sum: ProfileClanSumAggregateOutputType | null
    _min: ProfileClanMinAggregateOutputType | null
    _max: ProfileClanMaxAggregateOutputType | null
  }

  type GetProfileClanGroupByPayload<T extends ProfileClanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileClanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileClanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileClanGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileClanGroupByOutputType[P]>
        }
      >
    >


  export type ProfileClanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    clanId?: boolean
    order?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    clan?: boolean | ClanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileClan"]>

  export type ProfileClanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    clanId?: boolean
    order?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    clan?: boolean | ClanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileClan"]>

  export type ProfileClanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    clanId?: boolean
    order?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    clan?: boolean | ClanDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileClan"]>

  export type ProfileClanSelectScalar = {
    id?: boolean
    profileId?: boolean
    clanId?: boolean
    order?: boolean
  }

  export type ProfileClanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "clanId" | "order", ExtArgs["result"]["profileClan"]>
  export type ProfileClanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    clan?: boolean | ClanDefaultArgs<ExtArgs>
  }
  export type ProfileClanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    clan?: boolean | ClanDefaultArgs<ExtArgs>
  }
  export type ProfileClanIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    clan?: boolean | ClanDefaultArgs<ExtArgs>
  }

  export type $ProfileClanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileClan"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
      clan: Prisma.$ClanPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      clanId: string
      order: number
    }, ExtArgs["result"]["profileClan"]>
    composites: {}
  }

  type ProfileClanGetPayload<S extends boolean | null | undefined | ProfileClanDefaultArgs> = $Result.GetResult<Prisma.$ProfileClanPayload, S>

  type ProfileClanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileClanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileClanCountAggregateInputType | true
    }

  export interface ProfileClanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileClan'], meta: { name: 'ProfileClan' } }
    /**
     * Find zero or one ProfileClan that matches the filter.
     * @param {ProfileClanFindUniqueArgs} args - Arguments to find a ProfileClan
     * @example
     * // Get one ProfileClan
     * const profileClan = await prisma.profileClan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileClanFindUniqueArgs>(args: SelectSubset<T, ProfileClanFindUniqueArgs<ExtArgs>>): Prisma__ProfileClanClient<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileClan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileClanFindUniqueOrThrowArgs} args - Arguments to find a ProfileClan
     * @example
     * // Get one ProfileClan
     * const profileClan = await prisma.profileClan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileClanFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileClanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClanClient<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileClan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileClanFindFirstArgs} args - Arguments to find a ProfileClan
     * @example
     * // Get one ProfileClan
     * const profileClan = await prisma.profileClan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileClanFindFirstArgs>(args?: SelectSubset<T, ProfileClanFindFirstArgs<ExtArgs>>): Prisma__ProfileClanClient<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileClan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileClanFindFirstOrThrowArgs} args - Arguments to find a ProfileClan
     * @example
     * // Get one ProfileClan
     * const profileClan = await prisma.profileClan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileClanFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileClanFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClanClient<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileClans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileClanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileClans
     * const profileClans = await prisma.profileClan.findMany()
     * 
     * // Get first 10 ProfileClans
     * const profileClans = await prisma.profileClan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileClanWithIdOnly = await prisma.profileClan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileClanFindManyArgs>(args?: SelectSubset<T, ProfileClanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileClan.
     * @param {ProfileClanCreateArgs} args - Arguments to create a ProfileClan.
     * @example
     * // Create one ProfileClan
     * const ProfileClan = await prisma.profileClan.create({
     *   data: {
     *     // ... data to create a ProfileClan
     *   }
     * })
     * 
     */
    create<T extends ProfileClanCreateArgs>(args: SelectSubset<T, ProfileClanCreateArgs<ExtArgs>>): Prisma__ProfileClanClient<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileClans.
     * @param {ProfileClanCreateManyArgs} args - Arguments to create many ProfileClans.
     * @example
     * // Create many ProfileClans
     * const profileClan = await prisma.profileClan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileClanCreateManyArgs>(args?: SelectSubset<T, ProfileClanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileClans and returns the data saved in the database.
     * @param {ProfileClanCreateManyAndReturnArgs} args - Arguments to create many ProfileClans.
     * @example
     * // Create many ProfileClans
     * const profileClan = await prisma.profileClan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileClans and only return the `id`
     * const profileClanWithIdOnly = await prisma.profileClan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileClanCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileClanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfileClan.
     * @param {ProfileClanDeleteArgs} args - Arguments to delete one ProfileClan.
     * @example
     * // Delete one ProfileClan
     * const ProfileClan = await prisma.profileClan.delete({
     *   where: {
     *     // ... filter to delete one ProfileClan
     *   }
     * })
     * 
     */
    delete<T extends ProfileClanDeleteArgs>(args: SelectSubset<T, ProfileClanDeleteArgs<ExtArgs>>): Prisma__ProfileClanClient<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileClan.
     * @param {ProfileClanUpdateArgs} args - Arguments to update one ProfileClan.
     * @example
     * // Update one ProfileClan
     * const profileClan = await prisma.profileClan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileClanUpdateArgs>(args: SelectSubset<T, ProfileClanUpdateArgs<ExtArgs>>): Prisma__ProfileClanClient<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileClans.
     * @param {ProfileClanDeleteManyArgs} args - Arguments to filter ProfileClans to delete.
     * @example
     * // Delete a few ProfileClans
     * const { count } = await prisma.profileClan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileClanDeleteManyArgs>(args?: SelectSubset<T, ProfileClanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileClans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileClanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileClans
     * const profileClan = await prisma.profileClan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileClanUpdateManyArgs>(args: SelectSubset<T, ProfileClanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileClans and returns the data updated in the database.
     * @param {ProfileClanUpdateManyAndReturnArgs} args - Arguments to update many ProfileClans.
     * @example
     * // Update many ProfileClans
     * const profileClan = await prisma.profileClan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfileClans and only return the `id`
     * const profileClanWithIdOnly = await prisma.profileClan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileClanUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileClanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfileClan.
     * @param {ProfileClanUpsertArgs} args - Arguments to update or create a ProfileClan.
     * @example
     * // Update or create a ProfileClan
     * const profileClan = await prisma.profileClan.upsert({
     *   create: {
     *     // ... data to create a ProfileClan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileClan we want to update
     *   }
     * })
     */
    upsert<T extends ProfileClanUpsertArgs>(args: SelectSubset<T, ProfileClanUpsertArgs<ExtArgs>>): Prisma__ProfileClanClient<$Result.GetResult<Prisma.$ProfileClanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileClans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileClanCountArgs} args - Arguments to filter ProfileClans to count.
     * @example
     * // Count the number of ProfileClans
     * const count = await prisma.profileClan.count({
     *   where: {
     *     // ... the filter for the ProfileClans we want to count
     *   }
     * })
    **/
    count<T extends ProfileClanCountArgs>(
      args?: Subset<T, ProfileClanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileClanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileClan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileClanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileClanAggregateArgs>(args: Subset<T, ProfileClanAggregateArgs>): Prisma.PrismaPromise<GetProfileClanAggregateType<T>>

    /**
     * Group by ProfileClan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileClanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileClanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileClanGroupByArgs['orderBy'] }
        : { orderBy?: ProfileClanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileClanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileClanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileClan model
   */
  readonly fields: ProfileClanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileClan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clan<T extends ClanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClanDefaultArgs<ExtArgs>>): Prisma__ClanClient<$Result.GetResult<Prisma.$ClanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileClan model
   */
  interface ProfileClanFieldRefs {
    readonly id: FieldRef<"ProfileClan", 'String'>
    readonly profileId: FieldRef<"ProfileClan", 'String'>
    readonly clanId: FieldRef<"ProfileClan", 'String'>
    readonly order: FieldRef<"ProfileClan", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProfileClan findUnique
   */
  export type ProfileClanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    /**
     * Filter, which ProfileClan to fetch.
     */
    where: ProfileClanWhereUniqueInput
  }

  /**
   * ProfileClan findUniqueOrThrow
   */
  export type ProfileClanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    /**
     * Filter, which ProfileClan to fetch.
     */
    where: ProfileClanWhereUniqueInput
  }

  /**
   * ProfileClan findFirst
   */
  export type ProfileClanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    /**
     * Filter, which ProfileClan to fetch.
     */
    where?: ProfileClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileClans to fetch.
     */
    orderBy?: ProfileClanOrderByWithRelationInput | ProfileClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileClans.
     */
    cursor?: ProfileClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileClans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileClans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileClans.
     */
    distinct?: ProfileClanScalarFieldEnum | ProfileClanScalarFieldEnum[]
  }

  /**
   * ProfileClan findFirstOrThrow
   */
  export type ProfileClanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    /**
     * Filter, which ProfileClan to fetch.
     */
    where?: ProfileClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileClans to fetch.
     */
    orderBy?: ProfileClanOrderByWithRelationInput | ProfileClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileClans.
     */
    cursor?: ProfileClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileClans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileClans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileClans.
     */
    distinct?: ProfileClanScalarFieldEnum | ProfileClanScalarFieldEnum[]
  }

  /**
   * ProfileClan findMany
   */
  export type ProfileClanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    /**
     * Filter, which ProfileClans to fetch.
     */
    where?: ProfileClanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileClans to fetch.
     */
    orderBy?: ProfileClanOrderByWithRelationInput | ProfileClanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileClans.
     */
    cursor?: ProfileClanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileClans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileClans.
     */
    skip?: number
    distinct?: ProfileClanScalarFieldEnum | ProfileClanScalarFieldEnum[]
  }

  /**
   * ProfileClan create
   */
  export type ProfileClanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileClan.
     */
    data: XOR<ProfileClanCreateInput, ProfileClanUncheckedCreateInput>
  }

  /**
   * ProfileClan createMany
   */
  export type ProfileClanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileClans.
     */
    data: ProfileClanCreateManyInput | ProfileClanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileClan createManyAndReturn
   */
  export type ProfileClanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * The data used to create many ProfileClans.
     */
    data: ProfileClanCreateManyInput | ProfileClanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileClan update
   */
  export type ProfileClanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileClan.
     */
    data: XOR<ProfileClanUpdateInput, ProfileClanUncheckedUpdateInput>
    /**
     * Choose, which ProfileClan to update.
     */
    where: ProfileClanWhereUniqueInput
  }

  /**
   * ProfileClan updateMany
   */
  export type ProfileClanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileClans.
     */
    data: XOR<ProfileClanUpdateManyMutationInput, ProfileClanUncheckedUpdateManyInput>
    /**
     * Filter which ProfileClans to update
     */
    where?: ProfileClanWhereInput
    /**
     * Limit how many ProfileClans to update.
     */
    limit?: number
  }

  /**
   * ProfileClan updateManyAndReturn
   */
  export type ProfileClanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * The data used to update ProfileClans.
     */
    data: XOR<ProfileClanUpdateManyMutationInput, ProfileClanUncheckedUpdateManyInput>
    /**
     * Filter which ProfileClans to update
     */
    where?: ProfileClanWhereInput
    /**
     * Limit how many ProfileClans to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileClan upsert
   */
  export type ProfileClanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileClan to update in case it exists.
     */
    where: ProfileClanWhereUniqueInput
    /**
     * In case the ProfileClan found by the `where` argument doesn't exist, create a new ProfileClan with this data.
     */
    create: XOR<ProfileClanCreateInput, ProfileClanUncheckedCreateInput>
    /**
     * In case the ProfileClan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileClanUpdateInput, ProfileClanUncheckedUpdateInput>
  }

  /**
   * ProfileClan delete
   */
  export type ProfileClanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
    /**
     * Filter which ProfileClan to delete.
     */
    where: ProfileClanWhereUniqueInput
  }

  /**
   * ProfileClan deleteMany
   */
  export type ProfileClanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileClans to delete
     */
    where?: ProfileClanWhereInput
    /**
     * Limit how many ProfileClans to delete.
     */
    limit?: number
  }

  /**
   * ProfileClan without action
   */
  export type ProfileClanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileClan
     */
    select?: ProfileClanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileClan
     */
    omit?: ProfileClanOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileClanInclude<ExtArgs> | null
  }


  /**
   * Model Lineage
   */

  export type AggregateLineage = {
    _count: LineageCountAggregateOutputType | null
    _min: LineageMinAggregateOutputType | null
    _max: LineageMaxAggregateOutputType | null
  }

  export type LineageMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.LineageType | null
    primarySurname: string | null
    rootVillage: string | null
    rootRegion: string | null
    description: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LineageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.LineageType | null
    primarySurname: string | null
    rootVillage: string | null
    rootRegion: string | null
    description: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LineageCountAggregateOutputType = {
    id: number
    name: number
    type: number
    primarySurname: number
    rootVillage: number
    rootRegion: number
    description: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LineageMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    primarySurname?: true
    rootVillage?: true
    rootRegion?: true
    description?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LineageMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    primarySurname?: true
    rootVillage?: true
    rootRegion?: true
    description?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LineageCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    primarySurname?: true
    rootVillage?: true
    rootRegion?: true
    description?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LineageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lineage to aggregate.
     */
    where?: LineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineages to fetch.
     */
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lineages
    **/
    _count?: true | LineageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LineageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LineageMaxAggregateInputType
  }

  export type GetLineageAggregateType<T extends LineageAggregateArgs> = {
        [P in keyof T & keyof AggregateLineage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineage[P]>
      : GetScalarType<T[P], AggregateLineage[P]>
  }




  export type LineageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageWhereInput
    orderBy?: LineageOrderByWithAggregationInput | LineageOrderByWithAggregationInput[]
    by: LineageScalarFieldEnum[] | LineageScalarFieldEnum
    having?: LineageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LineageCountAggregateInputType | true
    _min?: LineageMinAggregateInputType
    _max?: LineageMaxAggregateInputType
  }

  export type LineageGroupByOutputType = {
    id: string
    name: string
    type: $Enums.LineageType
    primarySurname: string | null
    rootVillage: string | null
    rootRegion: string | null
    description: string | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: LineageCountAggregateOutputType | null
    _min: LineageMinAggregateOutputType | null
    _max: LineageMaxAggregateOutputType | null
  }

  type GetLineageGroupByPayload<T extends LineageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LineageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LineageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineageGroupByOutputType[P]>
            : GetScalarType<T[P], LineageGroupByOutputType[P]>
        }
      >
    >


  export type LineageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    primarySurname?: boolean
    rootVillage?: boolean
    rootRegion?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
    memberships?: boolean | Lineage$membershipsArgs<ExtArgs>
    notifications?: boolean | Lineage$notificationsArgs<ExtArgs>
    posts?: boolean | Lineage$postsArgs<ExtArgs>
    _count?: boolean | LineageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineage"]>

  export type LineageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    primarySurname?: boolean
    rootVillage?: boolean
    rootRegion?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["lineage"]>

  export type LineageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    primarySurname?: boolean
    rootVillage?: boolean
    rootRegion?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["lineage"]>

  export type LineageSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    primarySurname?: boolean
    rootVillage?: boolean
    rootRegion?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LineageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "primarySurname" | "rootVillage" | "rootRegion" | "description" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["lineage"]>
  export type LineageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
    memberships?: boolean | Lineage$membershipsArgs<ExtArgs>
    notifications?: boolean | Lineage$notificationsArgs<ExtArgs>
    posts?: boolean | Lineage$postsArgs<ExtArgs>
    _count?: boolean | LineageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LineageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
  }
  export type LineageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
  }

  export type $LineagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lineage"
    objects: {
      createdBy: Prisma.$ProfilePayload<ExtArgs> | null
      memberships: Prisma.$LineageMembershipPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.LineageType
      primarySurname: string | null
      rootVillage: string | null
      rootRegion: string | null
      description: string | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lineage"]>
    composites: {}
  }

  type LineageGetPayload<S extends boolean | null | undefined | LineageDefaultArgs> = $Result.GetResult<Prisma.$LineagePayload, S>

  type LineageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LineageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LineageCountAggregateInputType | true
    }

  export interface LineageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lineage'], meta: { name: 'Lineage' } }
    /**
     * Find zero or one Lineage that matches the filter.
     * @param {LineageFindUniqueArgs} args - Arguments to find a Lineage
     * @example
     * // Get one Lineage
     * const lineage = await prisma.lineage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LineageFindUniqueArgs>(args: SelectSubset<T, LineageFindUniqueArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lineage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LineageFindUniqueOrThrowArgs} args - Arguments to find a Lineage
     * @example
     * // Get one Lineage
     * const lineage = await prisma.lineage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LineageFindUniqueOrThrowArgs>(args: SelectSubset<T, LineageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lineage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageFindFirstArgs} args - Arguments to find a Lineage
     * @example
     * // Get one Lineage
     * const lineage = await prisma.lineage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LineageFindFirstArgs>(args?: SelectSubset<T, LineageFindFirstArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lineage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageFindFirstOrThrowArgs} args - Arguments to find a Lineage
     * @example
     * // Get one Lineage
     * const lineage = await prisma.lineage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LineageFindFirstOrThrowArgs>(args?: SelectSubset<T, LineageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lineages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lineages
     * const lineages = await prisma.lineage.findMany()
     * 
     * // Get first 10 Lineages
     * const lineages = await prisma.lineage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lineageWithIdOnly = await prisma.lineage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LineageFindManyArgs>(args?: SelectSubset<T, LineageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lineage.
     * @param {LineageCreateArgs} args - Arguments to create a Lineage.
     * @example
     * // Create one Lineage
     * const Lineage = await prisma.lineage.create({
     *   data: {
     *     // ... data to create a Lineage
     *   }
     * })
     * 
     */
    create<T extends LineageCreateArgs>(args: SelectSubset<T, LineageCreateArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lineages.
     * @param {LineageCreateManyArgs} args - Arguments to create many Lineages.
     * @example
     * // Create many Lineages
     * const lineage = await prisma.lineage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LineageCreateManyArgs>(args?: SelectSubset<T, LineageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lineages and returns the data saved in the database.
     * @param {LineageCreateManyAndReturnArgs} args - Arguments to create many Lineages.
     * @example
     * // Create many Lineages
     * const lineage = await prisma.lineage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lineages and only return the `id`
     * const lineageWithIdOnly = await prisma.lineage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LineageCreateManyAndReturnArgs>(args?: SelectSubset<T, LineageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lineage.
     * @param {LineageDeleteArgs} args - Arguments to delete one Lineage.
     * @example
     * // Delete one Lineage
     * const Lineage = await prisma.lineage.delete({
     *   where: {
     *     // ... filter to delete one Lineage
     *   }
     * })
     * 
     */
    delete<T extends LineageDeleteArgs>(args: SelectSubset<T, LineageDeleteArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lineage.
     * @param {LineageUpdateArgs} args - Arguments to update one Lineage.
     * @example
     * // Update one Lineage
     * const lineage = await prisma.lineage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LineageUpdateArgs>(args: SelectSubset<T, LineageUpdateArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lineages.
     * @param {LineageDeleteManyArgs} args - Arguments to filter Lineages to delete.
     * @example
     * // Delete a few Lineages
     * const { count } = await prisma.lineage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LineageDeleteManyArgs>(args?: SelectSubset<T, LineageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lineages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lineages
     * const lineage = await prisma.lineage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LineageUpdateManyArgs>(args: SelectSubset<T, LineageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lineages and returns the data updated in the database.
     * @param {LineageUpdateManyAndReturnArgs} args - Arguments to update many Lineages.
     * @example
     * // Update many Lineages
     * const lineage = await prisma.lineage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lineages and only return the `id`
     * const lineageWithIdOnly = await prisma.lineage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LineageUpdateManyAndReturnArgs>(args: SelectSubset<T, LineageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lineage.
     * @param {LineageUpsertArgs} args - Arguments to update or create a Lineage.
     * @example
     * // Update or create a Lineage
     * const lineage = await prisma.lineage.upsert({
     *   create: {
     *     // ... data to create a Lineage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lineage we want to update
     *   }
     * })
     */
    upsert<T extends LineageUpsertArgs>(args: SelectSubset<T, LineageUpsertArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lineages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageCountArgs} args - Arguments to filter Lineages to count.
     * @example
     * // Count the number of Lineages
     * const count = await prisma.lineage.count({
     *   where: {
     *     // ... the filter for the Lineages we want to count
     *   }
     * })
    **/
    count<T extends LineageCountArgs>(
      args?: Subset<T, LineageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LineageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lineage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LineageAggregateArgs>(args: Subset<T, LineageAggregateArgs>): Prisma.PrismaPromise<GetLineageAggregateType<T>>

    /**
     * Group by Lineage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LineageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineageGroupByArgs['orderBy'] }
        : { orderBy?: LineageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LineageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLineageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lineage model
   */
  readonly fields: LineageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lineage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Lineage$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Lineage$createdByArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    memberships<T extends Lineage$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Lineage$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Lineage$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Lineage$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Lineage$postsArgs<ExtArgs> = {}>(args?: Subset<T, Lineage$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lineage model
   */
  interface LineageFieldRefs {
    readonly id: FieldRef<"Lineage", 'String'>
    readonly name: FieldRef<"Lineage", 'String'>
    readonly type: FieldRef<"Lineage", 'LineageType'>
    readonly primarySurname: FieldRef<"Lineage", 'String'>
    readonly rootVillage: FieldRef<"Lineage", 'String'>
    readonly rootRegion: FieldRef<"Lineage", 'String'>
    readonly description: FieldRef<"Lineage", 'String'>
    readonly createdById: FieldRef<"Lineage", 'String'>
    readonly createdAt: FieldRef<"Lineage", 'DateTime'>
    readonly updatedAt: FieldRef<"Lineage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lineage findUnique
   */
  export type LineageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineage to fetch.
     */
    where: LineageWhereUniqueInput
  }

  /**
   * Lineage findUniqueOrThrow
   */
  export type LineageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineage to fetch.
     */
    where: LineageWhereUniqueInput
  }

  /**
   * Lineage findFirst
   */
  export type LineageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineage to fetch.
     */
    where?: LineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineages to fetch.
     */
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lineages.
     */
    cursor?: LineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lineages.
     */
    distinct?: LineageScalarFieldEnum | LineageScalarFieldEnum[]
  }

  /**
   * Lineage findFirstOrThrow
   */
  export type LineageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineage to fetch.
     */
    where?: LineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineages to fetch.
     */
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lineages.
     */
    cursor?: LineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lineages.
     */
    distinct?: LineageScalarFieldEnum | LineageScalarFieldEnum[]
  }

  /**
   * Lineage findMany
   */
  export type LineageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineages to fetch.
     */
    where?: LineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineages to fetch.
     */
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lineages.
     */
    cursor?: LineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineages.
     */
    skip?: number
    distinct?: LineageScalarFieldEnum | LineageScalarFieldEnum[]
  }

  /**
   * Lineage create
   */
  export type LineageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * The data needed to create a Lineage.
     */
    data: XOR<LineageCreateInput, LineageUncheckedCreateInput>
  }

  /**
   * Lineage createMany
   */
  export type LineageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lineages.
     */
    data: LineageCreateManyInput | LineageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lineage createManyAndReturn
   */
  export type LineageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * The data used to create many Lineages.
     */
    data: LineageCreateManyInput | LineageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lineage update
   */
  export type LineageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * The data needed to update a Lineage.
     */
    data: XOR<LineageUpdateInput, LineageUncheckedUpdateInput>
    /**
     * Choose, which Lineage to update.
     */
    where: LineageWhereUniqueInput
  }

  /**
   * Lineage updateMany
   */
  export type LineageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lineages.
     */
    data: XOR<LineageUpdateManyMutationInput, LineageUncheckedUpdateManyInput>
    /**
     * Filter which Lineages to update
     */
    where?: LineageWhereInput
    /**
     * Limit how many Lineages to update.
     */
    limit?: number
  }

  /**
   * Lineage updateManyAndReturn
   */
  export type LineageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * The data used to update Lineages.
     */
    data: XOR<LineageUpdateManyMutationInput, LineageUncheckedUpdateManyInput>
    /**
     * Filter which Lineages to update
     */
    where?: LineageWhereInput
    /**
     * Limit how many Lineages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lineage upsert
   */
  export type LineageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * The filter to search for the Lineage to update in case it exists.
     */
    where: LineageWhereUniqueInput
    /**
     * In case the Lineage found by the `where` argument doesn't exist, create a new Lineage with this data.
     */
    create: XOR<LineageCreateInput, LineageUncheckedCreateInput>
    /**
     * In case the Lineage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineageUpdateInput, LineageUncheckedUpdateInput>
  }

  /**
   * Lineage delete
   */
  export type LineageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter which Lineage to delete.
     */
    where: LineageWhereUniqueInput
  }

  /**
   * Lineage deleteMany
   */
  export type LineageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lineages to delete
     */
    where?: LineageWhereInput
    /**
     * Limit how many Lineages to delete.
     */
    limit?: number
  }

  /**
   * Lineage.createdBy
   */
  export type Lineage$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Lineage.memberships
   */
  export type Lineage$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    where?: LineageMembershipWhereInput
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    cursor?: LineageMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * Lineage.notifications
   */
  export type Lineage$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Lineage.posts
   */
  export type Lineage$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Lineage without action
   */
  export type LineageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
  }


  /**
   * Model LineageMembership
   */

  export type AggregateLineageMembership = {
    _count: LineageMembershipCountAggregateOutputType | null
    _avg: LineageMembershipAvgAggregateOutputType | null
    _sum: LineageMembershipSumAggregateOutputType | null
    _min: LineageMembershipMinAggregateOutputType | null
    _max: LineageMembershipMaxAggregateOutputType | null
  }

  export type LineageMembershipAvgAggregateOutputType = {
    generation: number | null
  }

  export type LineageMembershipSumAggregateOutputType = {
    generation: number | null
  }

  export type LineageMembershipMinAggregateOutputType = {
    id: string | null
    lineageId: string | null
    profileId: string | null
    role: $Enums.LineageRole | null
    generation: number | null
    isPrimaryLineage: boolean | null
    addedById: string | null
    createdAt: Date | null
  }

  export type LineageMembershipMaxAggregateOutputType = {
    id: string | null
    lineageId: string | null
    profileId: string | null
    role: $Enums.LineageRole | null
    generation: number | null
    isPrimaryLineage: boolean | null
    addedById: string | null
    createdAt: Date | null
  }

  export type LineageMembershipCountAggregateOutputType = {
    id: number
    lineageId: number
    profileId: number
    role: number
    generation: number
    isPrimaryLineage: number
    addedById: number
    createdAt: number
    _all: number
  }


  export type LineageMembershipAvgAggregateInputType = {
    generation?: true
  }

  export type LineageMembershipSumAggregateInputType = {
    generation?: true
  }

  export type LineageMembershipMinAggregateInputType = {
    id?: true
    lineageId?: true
    profileId?: true
    role?: true
    generation?: true
    isPrimaryLineage?: true
    addedById?: true
    createdAt?: true
  }

  export type LineageMembershipMaxAggregateInputType = {
    id?: true
    lineageId?: true
    profileId?: true
    role?: true
    generation?: true
    isPrimaryLineage?: true
    addedById?: true
    createdAt?: true
  }

  export type LineageMembershipCountAggregateInputType = {
    id?: true
    lineageId?: true
    profileId?: true
    role?: true
    generation?: true
    isPrimaryLineage?: true
    addedById?: true
    createdAt?: true
    _all?: true
  }

  export type LineageMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineageMembership to aggregate.
     */
    where?: LineageMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineageMemberships to fetch.
     */
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LineageMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineageMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineageMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LineageMemberships
    **/
    _count?: true | LineageMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LineageMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LineageMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LineageMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LineageMembershipMaxAggregateInputType
  }

  export type GetLineageMembershipAggregateType<T extends LineageMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateLineageMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineageMembership[P]>
      : GetScalarType<T[P], AggregateLineageMembership[P]>
  }




  export type LineageMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageMembershipWhereInput
    orderBy?: LineageMembershipOrderByWithAggregationInput | LineageMembershipOrderByWithAggregationInput[]
    by: LineageMembershipScalarFieldEnum[] | LineageMembershipScalarFieldEnum
    having?: LineageMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LineageMembershipCountAggregateInputType | true
    _avg?: LineageMembershipAvgAggregateInputType
    _sum?: LineageMembershipSumAggregateInputType
    _min?: LineageMembershipMinAggregateInputType
    _max?: LineageMembershipMaxAggregateInputType
  }

  export type LineageMembershipGroupByOutputType = {
    id: string
    lineageId: string
    profileId: string
    role: $Enums.LineageRole
    generation: number | null
    isPrimaryLineage: boolean
    addedById: string | null
    createdAt: Date
    _count: LineageMembershipCountAggregateOutputType | null
    _avg: LineageMembershipAvgAggregateOutputType | null
    _sum: LineageMembershipSumAggregateOutputType | null
    _min: LineageMembershipMinAggregateOutputType | null
    _max: LineageMembershipMaxAggregateOutputType | null
  }

  type GetLineageMembershipGroupByPayload<T extends LineageMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LineageMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LineageMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineageMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], LineageMembershipGroupByOutputType[P]>
        }
      >
    >


  export type LineageMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineageId?: boolean
    profileId?: boolean
    role?: boolean
    generation?: boolean
    isPrimaryLineage?: boolean
    addedById?: boolean
    createdAt?: boolean
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineageMembership"]>

  export type LineageMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineageId?: boolean
    profileId?: boolean
    role?: boolean
    generation?: boolean
    isPrimaryLineage?: boolean
    addedById?: boolean
    createdAt?: boolean
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineageMembership"]>

  export type LineageMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineageId?: boolean
    profileId?: boolean
    role?: boolean
    generation?: boolean
    isPrimaryLineage?: boolean
    addedById?: boolean
    createdAt?: boolean
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineageMembership"]>

  export type LineageMembershipSelectScalar = {
    id?: boolean
    lineageId?: boolean
    profileId?: boolean
    role?: boolean
    generation?: boolean
    isPrimaryLineage?: boolean
    addedById?: boolean
    createdAt?: boolean
  }

  export type LineageMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lineageId" | "profileId" | "role" | "generation" | "isPrimaryLineage" | "addedById" | "createdAt", ExtArgs["result"]["lineageMembership"]>
  export type LineageMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type LineageMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type LineageMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $LineageMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LineageMembership"
    objects: {
      addedBy: Prisma.$ProfilePayload<ExtArgs> | null
      lineage: Prisma.$LineagePayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lineageId: string
      profileId: string
      role: $Enums.LineageRole
      generation: number | null
      isPrimaryLineage: boolean
      addedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["lineageMembership"]>
    composites: {}
  }

  type LineageMembershipGetPayload<S extends boolean | null | undefined | LineageMembershipDefaultArgs> = $Result.GetResult<Prisma.$LineageMembershipPayload, S>

  type LineageMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LineageMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LineageMembershipCountAggregateInputType | true
    }

  export interface LineageMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LineageMembership'], meta: { name: 'LineageMembership' } }
    /**
     * Find zero or one LineageMembership that matches the filter.
     * @param {LineageMembershipFindUniqueArgs} args - Arguments to find a LineageMembership
     * @example
     * // Get one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LineageMembershipFindUniqueArgs>(args: SelectSubset<T, LineageMembershipFindUniqueArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LineageMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LineageMembershipFindUniqueOrThrowArgs} args - Arguments to find a LineageMembership
     * @example
     * // Get one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LineageMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, LineageMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LineageMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipFindFirstArgs} args - Arguments to find a LineageMembership
     * @example
     * // Get one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LineageMembershipFindFirstArgs>(args?: SelectSubset<T, LineageMembershipFindFirstArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LineageMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipFindFirstOrThrowArgs} args - Arguments to find a LineageMembership
     * @example
     * // Get one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LineageMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, LineageMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LineageMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineageMemberships
     * const lineageMemberships = await prisma.lineageMembership.findMany()
     * 
     * // Get first 10 LineageMemberships
     * const lineageMemberships = await prisma.lineageMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lineageMembershipWithIdOnly = await prisma.lineageMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LineageMembershipFindManyArgs>(args?: SelectSubset<T, LineageMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LineageMembership.
     * @param {LineageMembershipCreateArgs} args - Arguments to create a LineageMembership.
     * @example
     * // Create one LineageMembership
     * const LineageMembership = await prisma.lineageMembership.create({
     *   data: {
     *     // ... data to create a LineageMembership
     *   }
     * })
     * 
     */
    create<T extends LineageMembershipCreateArgs>(args: SelectSubset<T, LineageMembershipCreateArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LineageMemberships.
     * @param {LineageMembershipCreateManyArgs} args - Arguments to create many LineageMemberships.
     * @example
     * // Create many LineageMemberships
     * const lineageMembership = await prisma.lineageMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LineageMembershipCreateManyArgs>(args?: SelectSubset<T, LineageMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LineageMemberships and returns the data saved in the database.
     * @param {LineageMembershipCreateManyAndReturnArgs} args - Arguments to create many LineageMemberships.
     * @example
     * // Create many LineageMemberships
     * const lineageMembership = await prisma.lineageMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LineageMemberships and only return the `id`
     * const lineageMembershipWithIdOnly = await prisma.lineageMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LineageMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, LineageMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LineageMembership.
     * @param {LineageMembershipDeleteArgs} args - Arguments to delete one LineageMembership.
     * @example
     * // Delete one LineageMembership
     * const LineageMembership = await prisma.lineageMembership.delete({
     *   where: {
     *     // ... filter to delete one LineageMembership
     *   }
     * })
     * 
     */
    delete<T extends LineageMembershipDeleteArgs>(args: SelectSubset<T, LineageMembershipDeleteArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LineageMembership.
     * @param {LineageMembershipUpdateArgs} args - Arguments to update one LineageMembership.
     * @example
     * // Update one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LineageMembershipUpdateArgs>(args: SelectSubset<T, LineageMembershipUpdateArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LineageMemberships.
     * @param {LineageMembershipDeleteManyArgs} args - Arguments to filter LineageMemberships to delete.
     * @example
     * // Delete a few LineageMemberships
     * const { count } = await prisma.lineageMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LineageMembershipDeleteManyArgs>(args?: SelectSubset<T, LineageMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LineageMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineageMemberships
     * const lineageMembership = await prisma.lineageMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LineageMembershipUpdateManyArgs>(args: SelectSubset<T, LineageMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LineageMemberships and returns the data updated in the database.
     * @param {LineageMembershipUpdateManyAndReturnArgs} args - Arguments to update many LineageMemberships.
     * @example
     * // Update many LineageMemberships
     * const lineageMembership = await prisma.lineageMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LineageMemberships and only return the `id`
     * const lineageMembershipWithIdOnly = await prisma.lineageMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LineageMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, LineageMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LineageMembership.
     * @param {LineageMembershipUpsertArgs} args - Arguments to update or create a LineageMembership.
     * @example
     * // Update or create a LineageMembership
     * const lineageMembership = await prisma.lineageMembership.upsert({
     *   create: {
     *     // ... data to create a LineageMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineageMembership we want to update
     *   }
     * })
     */
    upsert<T extends LineageMembershipUpsertArgs>(args: SelectSubset<T, LineageMembershipUpsertArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LineageMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipCountArgs} args - Arguments to filter LineageMemberships to count.
     * @example
     * // Count the number of LineageMemberships
     * const count = await prisma.lineageMembership.count({
     *   where: {
     *     // ... the filter for the LineageMemberships we want to count
     *   }
     * })
    **/
    count<T extends LineageMembershipCountArgs>(
      args?: Subset<T, LineageMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LineageMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LineageMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LineageMembershipAggregateArgs>(args: Subset<T, LineageMembershipAggregateArgs>): Prisma.PrismaPromise<GetLineageMembershipAggregateType<T>>

    /**
     * Group by LineageMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LineageMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineageMembershipGroupByArgs['orderBy'] }
        : { orderBy?: LineageMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LineageMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLineageMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LineageMembership model
   */
  readonly fields: LineageMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LineageMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineageMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    addedBy<T extends LineageMembership$addedByArgs<ExtArgs> = {}>(args?: Subset<T, LineageMembership$addedByArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lineage<T extends LineageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LineageDefaultArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LineageMembership model
   */
  interface LineageMembershipFieldRefs {
    readonly id: FieldRef<"LineageMembership", 'String'>
    readonly lineageId: FieldRef<"LineageMembership", 'String'>
    readonly profileId: FieldRef<"LineageMembership", 'String'>
    readonly role: FieldRef<"LineageMembership", 'LineageRole'>
    readonly generation: FieldRef<"LineageMembership", 'Int'>
    readonly isPrimaryLineage: FieldRef<"LineageMembership", 'Boolean'>
    readonly addedById: FieldRef<"LineageMembership", 'String'>
    readonly createdAt: FieldRef<"LineageMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LineageMembership findUnique
   */
  export type LineageMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMembership to fetch.
     */
    where: LineageMembershipWhereUniqueInput
  }

  /**
   * LineageMembership findUniqueOrThrow
   */
  export type LineageMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMembership to fetch.
     */
    where: LineageMembershipWhereUniqueInput
  }

  /**
   * LineageMembership findFirst
   */
  export type LineageMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMembership to fetch.
     */
    where?: LineageMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineageMemberships to fetch.
     */
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineageMemberships.
     */
    cursor?: LineageMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineageMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineageMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineageMemberships.
     */
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * LineageMembership findFirstOrThrow
   */
  export type LineageMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMembership to fetch.
     */
    where?: LineageMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineageMemberships to fetch.
     */
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineageMemberships.
     */
    cursor?: LineageMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineageMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineageMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineageMemberships.
     */
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * LineageMembership findMany
   */
  export type LineageMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMemberships to fetch.
     */
    where?: LineageMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineageMemberships to fetch.
     */
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LineageMemberships.
     */
    cursor?: LineageMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineageMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineageMemberships.
     */
    skip?: number
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * LineageMembership create
   */
  export type LineageMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a LineageMembership.
     */
    data: XOR<LineageMembershipCreateInput, LineageMembershipUncheckedCreateInput>
  }

  /**
   * LineageMembership createMany
   */
  export type LineageMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LineageMemberships.
     */
    data: LineageMembershipCreateManyInput | LineageMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LineageMembership createManyAndReturn
   */
  export type LineageMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many LineageMemberships.
     */
    data: LineageMembershipCreateManyInput | LineageMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LineageMembership update
   */
  export type LineageMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a LineageMembership.
     */
    data: XOR<LineageMembershipUpdateInput, LineageMembershipUncheckedUpdateInput>
    /**
     * Choose, which LineageMembership to update.
     */
    where: LineageMembershipWhereUniqueInput
  }

  /**
   * LineageMembership updateMany
   */
  export type LineageMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LineageMemberships.
     */
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyInput>
    /**
     * Filter which LineageMemberships to update
     */
    where?: LineageMembershipWhereInput
    /**
     * Limit how many LineageMemberships to update.
     */
    limit?: number
  }

  /**
   * LineageMembership updateManyAndReturn
   */
  export type LineageMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * The data used to update LineageMemberships.
     */
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyInput>
    /**
     * Filter which LineageMemberships to update
     */
    where?: LineageMembershipWhereInput
    /**
     * Limit how many LineageMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LineageMembership upsert
   */
  export type LineageMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the LineageMembership to update in case it exists.
     */
    where: LineageMembershipWhereUniqueInput
    /**
     * In case the LineageMembership found by the `where` argument doesn't exist, create a new LineageMembership with this data.
     */
    create: XOR<LineageMembershipCreateInput, LineageMembershipUncheckedCreateInput>
    /**
     * In case the LineageMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineageMembershipUpdateInput, LineageMembershipUncheckedUpdateInput>
  }

  /**
   * LineageMembership delete
   */
  export type LineageMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter which LineageMembership to delete.
     */
    where: LineageMembershipWhereUniqueInput
  }

  /**
   * LineageMembership deleteMany
   */
  export type LineageMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineageMemberships to delete
     */
    where?: LineageMembershipWhereInput
    /**
     * Limit how many LineageMemberships to delete.
     */
    limit?: number
  }

  /**
   * LineageMembership.addedBy
   */
  export type LineageMembership$addedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * LineageMembership without action
   */
  export type LineageMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
  }


  /**
   * Model Kinship
   */

  export type AggregateKinship = {
    _count: KinshipCountAggregateOutputType | null
    _min: KinshipMinAggregateOutputType | null
    _max: KinshipMaxAggregateOutputType | null
  }

  export type KinshipMinAggregateOutputType = {
    id: string | null
    profileIdA: string | null
    profileIdB: string | null
    relationAtoB: $Enums.KinshipType | null
    verified: boolean | null
    verifiedById: string | null
    createdAt: Date | null
  }

  export type KinshipMaxAggregateOutputType = {
    id: string | null
    profileIdA: string | null
    profileIdB: string | null
    relationAtoB: $Enums.KinshipType | null
    verified: boolean | null
    verifiedById: string | null
    createdAt: Date | null
  }

  export type KinshipCountAggregateOutputType = {
    id: number
    profileIdA: number
    profileIdB: number
    relationAtoB: number
    verified: number
    verifiedById: number
    createdAt: number
    _all: number
  }


  export type KinshipMinAggregateInputType = {
    id?: true
    profileIdA?: true
    profileIdB?: true
    relationAtoB?: true
    verified?: true
    verifiedById?: true
    createdAt?: true
  }

  export type KinshipMaxAggregateInputType = {
    id?: true
    profileIdA?: true
    profileIdB?: true
    relationAtoB?: true
    verified?: true
    verifiedById?: true
    createdAt?: true
  }

  export type KinshipCountAggregateInputType = {
    id?: true
    profileIdA?: true
    profileIdB?: true
    relationAtoB?: true
    verified?: true
    verifiedById?: true
    createdAt?: true
    _all?: true
  }

  export type KinshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kinship to aggregate.
     */
    where?: KinshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kinships to fetch.
     */
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KinshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kinships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kinships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kinships
    **/
    _count?: true | KinshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KinshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KinshipMaxAggregateInputType
  }

  export type GetKinshipAggregateType<T extends KinshipAggregateArgs> = {
        [P in keyof T & keyof AggregateKinship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKinship[P]>
      : GetScalarType<T[P], AggregateKinship[P]>
  }




  export type KinshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KinshipWhereInput
    orderBy?: KinshipOrderByWithAggregationInput | KinshipOrderByWithAggregationInput[]
    by: KinshipScalarFieldEnum[] | KinshipScalarFieldEnum
    having?: KinshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KinshipCountAggregateInputType | true
    _min?: KinshipMinAggregateInputType
    _max?: KinshipMaxAggregateInputType
  }

  export type KinshipGroupByOutputType = {
    id: string
    profileIdA: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified: boolean
    verifiedById: string | null
    createdAt: Date
    _count: KinshipCountAggregateOutputType | null
    _min: KinshipMinAggregateOutputType | null
    _max: KinshipMaxAggregateOutputType | null
  }

  type GetKinshipGroupByPayload<T extends KinshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KinshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KinshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KinshipGroupByOutputType[P]>
            : GetScalarType<T[P], KinshipGroupByOutputType[P]>
        }
      >
    >


  export type KinshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileIdA?: boolean
    profileIdB?: boolean
    relationAtoB?: boolean
    verified?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kinship"]>

  export type KinshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileIdA?: boolean
    profileIdB?: boolean
    relationAtoB?: boolean
    verified?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kinship"]>

  export type KinshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileIdA?: boolean
    profileIdB?: boolean
    relationAtoB?: boolean
    verified?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kinship"]>

  export type KinshipSelectScalar = {
    id?: boolean
    profileIdA?: boolean
    profileIdB?: boolean
    relationAtoB?: boolean
    verified?: boolean
    verifiedById?: boolean
    createdAt?: boolean
  }

  export type KinshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileIdA" | "profileIdB" | "relationAtoB" | "verified" | "verifiedById" | "createdAt", ExtArgs["result"]["kinship"]>
  export type KinshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type KinshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type KinshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $KinshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kinship"
    objects: {
      profileA: Prisma.$ProfilePayload<ExtArgs>
      profileB: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileIdA: string
      profileIdB: string
      relationAtoB: $Enums.KinshipType
      verified: boolean
      verifiedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["kinship"]>
    composites: {}
  }

  type KinshipGetPayload<S extends boolean | null | undefined | KinshipDefaultArgs> = $Result.GetResult<Prisma.$KinshipPayload, S>

  type KinshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KinshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KinshipCountAggregateInputType | true
    }

  export interface KinshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kinship'], meta: { name: 'Kinship' } }
    /**
     * Find zero or one Kinship that matches the filter.
     * @param {KinshipFindUniqueArgs} args - Arguments to find a Kinship
     * @example
     * // Get one Kinship
     * const kinship = await prisma.kinship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KinshipFindUniqueArgs>(args: SelectSubset<T, KinshipFindUniqueArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kinship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KinshipFindUniqueOrThrowArgs} args - Arguments to find a Kinship
     * @example
     * // Get one Kinship
     * const kinship = await prisma.kinship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KinshipFindUniqueOrThrowArgs>(args: SelectSubset<T, KinshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kinship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipFindFirstArgs} args - Arguments to find a Kinship
     * @example
     * // Get one Kinship
     * const kinship = await prisma.kinship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KinshipFindFirstArgs>(args?: SelectSubset<T, KinshipFindFirstArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kinship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipFindFirstOrThrowArgs} args - Arguments to find a Kinship
     * @example
     * // Get one Kinship
     * const kinship = await prisma.kinship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KinshipFindFirstOrThrowArgs>(args?: SelectSubset<T, KinshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kinships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kinships
     * const kinships = await prisma.kinship.findMany()
     * 
     * // Get first 10 Kinships
     * const kinships = await prisma.kinship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kinshipWithIdOnly = await prisma.kinship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KinshipFindManyArgs>(args?: SelectSubset<T, KinshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kinship.
     * @param {KinshipCreateArgs} args - Arguments to create a Kinship.
     * @example
     * // Create one Kinship
     * const Kinship = await prisma.kinship.create({
     *   data: {
     *     // ... data to create a Kinship
     *   }
     * })
     * 
     */
    create<T extends KinshipCreateArgs>(args: SelectSubset<T, KinshipCreateArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kinships.
     * @param {KinshipCreateManyArgs} args - Arguments to create many Kinships.
     * @example
     * // Create many Kinships
     * const kinship = await prisma.kinship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KinshipCreateManyArgs>(args?: SelectSubset<T, KinshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kinships and returns the data saved in the database.
     * @param {KinshipCreateManyAndReturnArgs} args - Arguments to create many Kinships.
     * @example
     * // Create many Kinships
     * const kinship = await prisma.kinship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kinships and only return the `id`
     * const kinshipWithIdOnly = await prisma.kinship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KinshipCreateManyAndReturnArgs>(args?: SelectSubset<T, KinshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kinship.
     * @param {KinshipDeleteArgs} args - Arguments to delete one Kinship.
     * @example
     * // Delete one Kinship
     * const Kinship = await prisma.kinship.delete({
     *   where: {
     *     // ... filter to delete one Kinship
     *   }
     * })
     * 
     */
    delete<T extends KinshipDeleteArgs>(args: SelectSubset<T, KinshipDeleteArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kinship.
     * @param {KinshipUpdateArgs} args - Arguments to update one Kinship.
     * @example
     * // Update one Kinship
     * const kinship = await prisma.kinship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KinshipUpdateArgs>(args: SelectSubset<T, KinshipUpdateArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kinships.
     * @param {KinshipDeleteManyArgs} args - Arguments to filter Kinships to delete.
     * @example
     * // Delete a few Kinships
     * const { count } = await prisma.kinship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KinshipDeleteManyArgs>(args?: SelectSubset<T, KinshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kinships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kinships
     * const kinship = await prisma.kinship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KinshipUpdateManyArgs>(args: SelectSubset<T, KinshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kinships and returns the data updated in the database.
     * @param {KinshipUpdateManyAndReturnArgs} args - Arguments to update many Kinships.
     * @example
     * // Update many Kinships
     * const kinship = await prisma.kinship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kinships and only return the `id`
     * const kinshipWithIdOnly = await prisma.kinship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KinshipUpdateManyAndReturnArgs>(args: SelectSubset<T, KinshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kinship.
     * @param {KinshipUpsertArgs} args - Arguments to update or create a Kinship.
     * @example
     * // Update or create a Kinship
     * const kinship = await prisma.kinship.upsert({
     *   create: {
     *     // ... data to create a Kinship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kinship we want to update
     *   }
     * })
     */
    upsert<T extends KinshipUpsertArgs>(args: SelectSubset<T, KinshipUpsertArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kinships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipCountArgs} args - Arguments to filter Kinships to count.
     * @example
     * // Count the number of Kinships
     * const count = await prisma.kinship.count({
     *   where: {
     *     // ... the filter for the Kinships we want to count
     *   }
     * })
    **/
    count<T extends KinshipCountArgs>(
      args?: Subset<T, KinshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KinshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kinship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KinshipAggregateArgs>(args: Subset<T, KinshipAggregateArgs>): Prisma.PrismaPromise<GetKinshipAggregateType<T>>

    /**
     * Group by Kinship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KinshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KinshipGroupByArgs['orderBy'] }
        : { orderBy?: KinshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KinshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKinshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kinship model
   */
  readonly fields: KinshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kinship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KinshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profileA<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profileB<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kinship model
   */
  interface KinshipFieldRefs {
    readonly id: FieldRef<"Kinship", 'String'>
    readonly profileIdA: FieldRef<"Kinship", 'String'>
    readonly profileIdB: FieldRef<"Kinship", 'String'>
    readonly relationAtoB: FieldRef<"Kinship", 'KinshipType'>
    readonly verified: FieldRef<"Kinship", 'Boolean'>
    readonly verifiedById: FieldRef<"Kinship", 'String'>
    readonly createdAt: FieldRef<"Kinship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kinship findUnique
   */
  export type KinshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinship to fetch.
     */
    where: KinshipWhereUniqueInput
  }

  /**
   * Kinship findUniqueOrThrow
   */
  export type KinshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinship to fetch.
     */
    where: KinshipWhereUniqueInput
  }

  /**
   * Kinship findFirst
   */
  export type KinshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinship to fetch.
     */
    where?: KinshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kinships to fetch.
     */
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kinships.
     */
    cursor?: KinshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kinships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kinships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kinships.
     */
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Kinship findFirstOrThrow
   */
  export type KinshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinship to fetch.
     */
    where?: KinshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kinships to fetch.
     */
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kinships.
     */
    cursor?: KinshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kinships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kinships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kinships.
     */
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Kinship findMany
   */
  export type KinshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinships to fetch.
     */
    where?: KinshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kinships to fetch.
     */
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kinships.
     */
    cursor?: KinshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kinships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kinships.
     */
    skip?: number
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Kinship create
   */
  export type KinshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Kinship.
     */
    data: XOR<KinshipCreateInput, KinshipUncheckedCreateInput>
  }

  /**
   * Kinship createMany
   */
  export type KinshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kinships.
     */
    data: KinshipCreateManyInput | KinshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kinship createManyAndReturn
   */
  export type KinshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * The data used to create many Kinships.
     */
    data: KinshipCreateManyInput | KinshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kinship update
   */
  export type KinshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Kinship.
     */
    data: XOR<KinshipUpdateInput, KinshipUncheckedUpdateInput>
    /**
     * Choose, which Kinship to update.
     */
    where: KinshipWhereUniqueInput
  }

  /**
   * Kinship updateMany
   */
  export type KinshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kinships.
     */
    data: XOR<KinshipUpdateManyMutationInput, KinshipUncheckedUpdateManyInput>
    /**
     * Filter which Kinships to update
     */
    where?: KinshipWhereInput
    /**
     * Limit how many Kinships to update.
     */
    limit?: number
  }

  /**
   * Kinship updateManyAndReturn
   */
  export type KinshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * The data used to update Kinships.
     */
    data: XOR<KinshipUpdateManyMutationInput, KinshipUncheckedUpdateManyInput>
    /**
     * Filter which Kinships to update
     */
    where?: KinshipWhereInput
    /**
     * Limit how many Kinships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kinship upsert
   */
  export type KinshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Kinship to update in case it exists.
     */
    where: KinshipWhereUniqueInput
    /**
     * In case the Kinship found by the `where` argument doesn't exist, create a new Kinship with this data.
     */
    create: XOR<KinshipCreateInput, KinshipUncheckedCreateInput>
    /**
     * In case the Kinship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KinshipUpdateInput, KinshipUncheckedUpdateInput>
  }

  /**
   * Kinship delete
   */
  export type KinshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter which Kinship to delete.
     */
    where: KinshipWhereUniqueInput
  }

  /**
   * Kinship deleteMany
   */
  export type KinshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kinships to delete
     */
    where?: KinshipWhereInput
    /**
     * Limit how many Kinships to delete.
     */
    limit?: number
  }

  /**
   * Kinship without action
   */
  export type KinshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
  }


  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockMinAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedId: string | null
    createdAt: Date | null
  }

  export type BlockMaxAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedId: string | null
    createdAt: Date | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    blockerId: number
    blockedId: number
    createdAt: number
    _all: number
  }


  export type BlockMinAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: string
    blockerId: string
    blockedId: string
    createdAt: Date
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
  }

  export type BlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "blockerId" | "blockedId" | "createdAt", ExtArgs["result"]["block"]>
  export type BlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type BlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type BlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      blocked: Prisma.$ProfilePayload<ExtArgs>
      blocker: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockerId: string
      blockedId: string
      createdAt: Date
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {BlockUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocked<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blocker<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'String'>
    readonly blockerId: FieldRef<"Block", 'String'>
    readonly blockedId: FieldRef<"Block", 'String'>
    readonly createdAt: FieldRef<"Block", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block createManyAndReturn
   */
  export type BlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
  }

  /**
   * Block updateManyAndReturn
   */
  export type BlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to delete.
     */
    limit?: number
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
  }


  /**
   * Model Mute
   */

  export type AggregateMute = {
    _count: MuteCountAggregateOutputType | null
    _min: MuteMinAggregateOutputType | null
    _max: MuteMaxAggregateOutputType | null
  }

  export type MuteMinAggregateOutputType = {
    id: string | null
    muterId: string | null
    mutedId: string | null
    createdAt: Date | null
  }

  export type MuteMaxAggregateOutputType = {
    id: string | null
    muterId: string | null
    mutedId: string | null
    createdAt: Date | null
  }

  export type MuteCountAggregateOutputType = {
    id: number
    muterId: number
    mutedId: number
    createdAt: number
    _all: number
  }


  export type MuteMinAggregateInputType = {
    id?: true
    muterId?: true
    mutedId?: true
    createdAt?: true
  }

  export type MuteMaxAggregateInputType = {
    id?: true
    muterId?: true
    mutedId?: true
    createdAt?: true
  }

  export type MuteCountAggregateInputType = {
    id?: true
    muterId?: true
    mutedId?: true
    createdAt?: true
    _all?: true
  }

  export type MuteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mute to aggregate.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mutes
    **/
    _count?: true | MuteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuteMaxAggregateInputType
  }

  export type GetMuteAggregateType<T extends MuteAggregateArgs> = {
        [P in keyof T & keyof AggregateMute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMute[P]>
      : GetScalarType<T[P], AggregateMute[P]>
  }




  export type MuteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuteWhereInput
    orderBy?: MuteOrderByWithAggregationInput | MuteOrderByWithAggregationInput[]
    by: MuteScalarFieldEnum[] | MuteScalarFieldEnum
    having?: MuteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuteCountAggregateInputType | true
    _min?: MuteMinAggregateInputType
    _max?: MuteMaxAggregateInputType
  }

  export type MuteGroupByOutputType = {
    id: string
    muterId: string
    mutedId: string
    createdAt: Date
    _count: MuteCountAggregateOutputType | null
    _min: MuteMinAggregateOutputType | null
    _max: MuteMaxAggregateOutputType | null
  }

  type GetMuteGroupByPayload<T extends MuteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MuteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MuteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MuteGroupByOutputType[P]>
            : GetScalarType<T[P], MuteGroupByOutputType[P]>
        }
      >
    >


  export type MuteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    muterId?: boolean
    mutedId?: boolean
    createdAt?: boolean
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mute"]>

  export type MuteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    muterId?: boolean
    mutedId?: boolean
    createdAt?: boolean
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mute"]>

  export type MuteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    muterId?: boolean
    mutedId?: boolean
    createdAt?: boolean
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mute"]>

  export type MuteSelectScalar = {
    id?: boolean
    muterId?: boolean
    mutedId?: boolean
    createdAt?: boolean
  }

  export type MuteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "muterId" | "mutedId" | "createdAt", ExtArgs["result"]["mute"]>
  export type MuteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MuteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MuteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $MutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mute"
    objects: {
      muted: Prisma.$ProfilePayload<ExtArgs>
      muter: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      muterId: string
      mutedId: string
      createdAt: Date
    }, ExtArgs["result"]["mute"]>
    composites: {}
  }

  type MuteGetPayload<S extends boolean | null | undefined | MuteDefaultArgs> = $Result.GetResult<Prisma.$MutePayload, S>

  type MuteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MuteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MuteCountAggregateInputType | true
    }

  export interface MuteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mute'], meta: { name: 'Mute' } }
    /**
     * Find zero or one Mute that matches the filter.
     * @param {MuteFindUniqueArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MuteFindUniqueArgs>(args: SelectSubset<T, MuteFindUniqueArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MuteFindUniqueOrThrowArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MuteFindUniqueOrThrowArgs>(args: SelectSubset<T, MuteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteFindFirstArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MuteFindFirstArgs>(args?: SelectSubset<T, MuteFindFirstArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteFindFirstOrThrowArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MuteFindFirstOrThrowArgs>(args?: SelectSubset<T, MuteFindFirstOrThrowArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mutes
     * const mutes = await prisma.mute.findMany()
     * 
     * // Get first 10 Mutes
     * const mutes = await prisma.mute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const muteWithIdOnly = await prisma.mute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MuteFindManyArgs>(args?: SelectSubset<T, MuteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mute.
     * @param {MuteCreateArgs} args - Arguments to create a Mute.
     * @example
     * // Create one Mute
     * const Mute = await prisma.mute.create({
     *   data: {
     *     // ... data to create a Mute
     *   }
     * })
     * 
     */
    create<T extends MuteCreateArgs>(args: SelectSubset<T, MuteCreateArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mutes.
     * @param {MuteCreateManyArgs} args - Arguments to create many Mutes.
     * @example
     * // Create many Mutes
     * const mute = await prisma.mute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MuteCreateManyArgs>(args?: SelectSubset<T, MuteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mutes and returns the data saved in the database.
     * @param {MuteCreateManyAndReturnArgs} args - Arguments to create many Mutes.
     * @example
     * // Create many Mutes
     * const mute = await prisma.mute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mutes and only return the `id`
     * const muteWithIdOnly = await prisma.mute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MuteCreateManyAndReturnArgs>(args?: SelectSubset<T, MuteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mute.
     * @param {MuteDeleteArgs} args - Arguments to delete one Mute.
     * @example
     * // Delete one Mute
     * const Mute = await prisma.mute.delete({
     *   where: {
     *     // ... filter to delete one Mute
     *   }
     * })
     * 
     */
    delete<T extends MuteDeleteArgs>(args: SelectSubset<T, MuteDeleteArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mute.
     * @param {MuteUpdateArgs} args - Arguments to update one Mute.
     * @example
     * // Update one Mute
     * const mute = await prisma.mute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MuteUpdateArgs>(args: SelectSubset<T, MuteUpdateArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mutes.
     * @param {MuteDeleteManyArgs} args - Arguments to filter Mutes to delete.
     * @example
     * // Delete a few Mutes
     * const { count } = await prisma.mute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MuteDeleteManyArgs>(args?: SelectSubset<T, MuteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mutes
     * const mute = await prisma.mute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MuteUpdateManyArgs>(args: SelectSubset<T, MuteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mutes and returns the data updated in the database.
     * @param {MuteUpdateManyAndReturnArgs} args - Arguments to update many Mutes.
     * @example
     * // Update many Mutes
     * const mute = await prisma.mute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mutes and only return the `id`
     * const muteWithIdOnly = await prisma.mute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MuteUpdateManyAndReturnArgs>(args: SelectSubset<T, MuteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mute.
     * @param {MuteUpsertArgs} args - Arguments to update or create a Mute.
     * @example
     * // Update or create a Mute
     * const mute = await prisma.mute.upsert({
     *   create: {
     *     // ... data to create a Mute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mute we want to update
     *   }
     * })
     */
    upsert<T extends MuteUpsertArgs>(args: SelectSubset<T, MuteUpsertArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteCountArgs} args - Arguments to filter Mutes to count.
     * @example
     * // Count the number of Mutes
     * const count = await prisma.mute.count({
     *   where: {
     *     // ... the filter for the Mutes we want to count
     *   }
     * })
    **/
    count<T extends MuteCountArgs>(
      args?: Subset<T, MuteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuteAggregateArgs>(args: Subset<T, MuteAggregateArgs>): Prisma.PrismaPromise<GetMuteAggregateType<T>>

    /**
     * Group by Mute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuteGroupByArgs['orderBy'] }
        : { orderBy?: MuteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mute model
   */
  readonly fields: MuteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MuteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    muted<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    muter<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mute model
   */
  interface MuteFieldRefs {
    readonly id: FieldRef<"Mute", 'String'>
    readonly muterId: FieldRef<"Mute", 'String'>
    readonly mutedId: FieldRef<"Mute", 'String'>
    readonly createdAt: FieldRef<"Mute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mute findUnique
   */
  export type MuteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute findUniqueOrThrow
   */
  export type MuteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute findFirst
   */
  export type MuteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mutes.
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mutes.
     */
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Mute findFirstOrThrow
   */
  export type MuteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mutes.
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mutes.
     */
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Mute findMany
   */
  export type MuteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mutes to fetch.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mutes.
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Mute create
   */
  export type MuteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * The data needed to create a Mute.
     */
    data: XOR<MuteCreateInput, MuteUncheckedCreateInput>
  }

  /**
   * Mute createMany
   */
  export type MuteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mutes.
     */
    data: MuteCreateManyInput | MuteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mute createManyAndReturn
   */
  export type MuteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * The data used to create many Mutes.
     */
    data: MuteCreateManyInput | MuteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mute update
   */
  export type MuteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * The data needed to update a Mute.
     */
    data: XOR<MuteUpdateInput, MuteUncheckedUpdateInput>
    /**
     * Choose, which Mute to update.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute updateMany
   */
  export type MuteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mutes.
     */
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyInput>
    /**
     * Filter which Mutes to update
     */
    where?: MuteWhereInput
    /**
     * Limit how many Mutes to update.
     */
    limit?: number
  }

  /**
   * Mute updateManyAndReturn
   */
  export type MuteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * The data used to update Mutes.
     */
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyInput>
    /**
     * Filter which Mutes to update
     */
    where?: MuteWhereInput
    /**
     * Limit how many Mutes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mute upsert
   */
  export type MuteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * The filter to search for the Mute to update in case it exists.
     */
    where: MuteWhereUniqueInput
    /**
     * In case the Mute found by the `where` argument doesn't exist, create a new Mute with this data.
     */
    create: XOR<MuteCreateInput, MuteUncheckedCreateInput>
    /**
     * In case the Mute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MuteUpdateInput, MuteUncheckedUpdateInput>
  }

  /**
   * Mute delete
   */
  export type MuteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter which Mute to delete.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute deleteMany
   */
  export type MuteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mutes to delete
     */
    where?: MuteWhereInput
    /**
     * Limit how many Mutes to delete.
     */
    limit?: number
  }

  /**
   * Mute without action
   */
  export type MuteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    commentCount: number | null
    likeCount: number | null
    shareCount: number | null
  }

  export type PostSumAggregateOutputType = {
    commentCount: number | null
    likeCount: number | null
    shareCount: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    content: string | null
    visibility: $Enums.PostVisibility | null
    locationText: string | null
    lineageId: string | null
    commentCount: number | null
    likeCount: number | null
    shareCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    content: string | null
    visibility: $Enums.PostVisibility | null
    locationText: string | null
    lineageId: string | null
    commentCount: number | null
    likeCount: number | null
    shareCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    profileId: number
    content: number
    visibility: number
    locationText: number
    lineageId: number
    commentCount: number
    likeCount: number
    shareCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    commentCount?: true
    likeCount?: true
    shareCount?: true
  }

  export type PostSumAggregateInputType = {
    commentCount?: true
    likeCount?: true
    shareCount?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    profileId?: true
    content?: true
    visibility?: true
    locationText?: true
    lineageId?: true
    commentCount?: true
    likeCount?: true
    shareCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    profileId?: true
    content?: true
    visibility?: true
    locationText?: true
    lineageId?: true
    commentCount?: true
    likeCount?: true
    shareCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    profileId?: true
    content?: true
    visibility?: true
    locationText?: true
    lineageId?: true
    commentCount?: true
    likeCount?: true
    shareCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    profileId: string
    content: string | null
    visibility: $Enums.PostVisibility
    locationText: string | null
    lineageId: string | null
    commentCount: number
    likeCount: number
    shareCount: number
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    content?: boolean
    visibility?: boolean
    locationText?: boolean
    lineageId?: boolean
    commentCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    comments?: boolean | Post$commentsArgs<ExtArgs>
    mediaFiles?: boolean | Post$mediaFilesArgs<ExtArgs>
    notifications?: boolean | Post$notificationsArgs<ExtArgs>
    lineage?: boolean | Post$lineageArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    content?: boolean
    visibility?: boolean
    locationText?: boolean
    lineageId?: boolean
    commentCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lineage?: boolean | Post$lineageArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    content?: boolean
    visibility?: boolean
    locationText?: boolean
    lineageId?: boolean
    commentCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lineage?: boolean | Post$lineageArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    profileId?: boolean
    content?: boolean
    visibility?: boolean
    locationText?: boolean
    lineageId?: boolean
    commentCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "content" | "visibility" | "locationText" | "lineageId" | "commentCount" | "likeCount" | "shareCount" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | Post$commentsArgs<ExtArgs>
    mediaFiles?: boolean | Post$mediaFilesArgs<ExtArgs>
    notifications?: boolean | Post$notificationsArgs<ExtArgs>
    lineage?: boolean | Post$lineageArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineage?: boolean | Post$lineageArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineage?: boolean | Post$lineageArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      comments: Prisma.$CommentPayload<ExtArgs>[]
      mediaFiles: Prisma.$MediaFilePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      lineage: Prisma.$LineagePayload<ExtArgs> | null
      author: Prisma.$ProfilePayload<ExtArgs>
      reactions: Prisma.$PostReactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      content: string | null
      visibility: $Enums.PostVisibility
      locationText: string | null
      lineageId: string | null
      commentCount: number
      likeCount: number
      shareCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mediaFiles<T extends Post$mediaFilesArgs<ExtArgs> = {}>(args?: Subset<T, Post$mediaFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Post$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Post$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lineage<T extends Post$lineageArgs<ExtArgs> = {}>(args?: Subset<T, Post$lineageArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    author<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reactions<T extends Post$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Post$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly profileId: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly visibility: FieldRef<"Post", 'PostVisibility'>
    readonly locationText: FieldRef<"Post", 'String'>
    readonly lineageId: FieldRef<"Post", 'String'>
    readonly commentCount: FieldRef<"Post", 'Int'>
    readonly likeCount: FieldRef<"Post", 'Int'>
    readonly shareCount: FieldRef<"Post", 'Int'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.mediaFiles
   */
  export type Post$mediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    where?: MediaFileWhereInput
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    cursor?: MediaFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * Post.notifications
   */
  export type Post$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Post.lineage
   */
  export type Post$lineageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    where?: LineageWhereInput
  }

  /**
   * Post.reactions
   */
  export type Post$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    where?: PostReactionWhereInput
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    cursor?: PostReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model MediaFile
   */

  export type AggregateMediaFile = {
    _count: MediaFileCountAggregateOutputType | null
    _avg: MediaFileAvgAggregateOutputType | null
    _sum: MediaFileSumAggregateOutputType | null
    _min: MediaFileMinAggregateOutputType | null
    _max: MediaFileMaxAggregateOutputType | null
  }

  export type MediaFileAvgAggregateOutputType = {
    width: number | null
    height: number | null
    sizeBytes: number | null
  }

  export type MediaFileSumAggregateOutputType = {
    width: number | null
    height: number | null
    sizeBytes: number | null
  }

  export type MediaFileMinAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.MediaType | null
    url: string | null
    mimeType: string | null
    width: number | null
    height: number | null
    sizeBytes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaFileMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.MediaType | null
    url: string | null
    mimeType: string | null
    width: number | null
    height: number | null
    sizeBytes: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaFileCountAggregateOutputType = {
    id: number
    postId: number
    type: number
    url: number
    mimeType: number
    width: number
    height: number
    sizeBytes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaFileAvgAggregateInputType = {
    width?: true
    height?: true
    sizeBytes?: true
  }

  export type MediaFileSumAggregateInputType = {
    width?: true
    height?: true
    sizeBytes?: true
  }

  export type MediaFileMinAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    url?: true
    mimeType?: true
    width?: true
    height?: true
    sizeBytes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaFileMaxAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    url?: true
    mimeType?: true
    width?: true
    height?: true
    sizeBytes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaFileCountAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    url?: true
    mimeType?: true
    width?: true
    height?: true
    sizeBytes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFile to aggregate.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaFiles
    **/
    _count?: true | MediaFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaFileMaxAggregateInputType
  }

  export type GetMediaFileAggregateType<T extends MediaFileAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaFile[P]>
      : GetScalarType<T[P], AggregateMediaFile[P]>
  }




  export type MediaFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFileWhereInput
    orderBy?: MediaFileOrderByWithAggregationInput | MediaFileOrderByWithAggregationInput[]
    by: MediaFileScalarFieldEnum[] | MediaFileScalarFieldEnum
    having?: MediaFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaFileCountAggregateInputType | true
    _avg?: MediaFileAvgAggregateInputType
    _sum?: MediaFileSumAggregateInputType
    _min?: MediaFileMinAggregateInputType
    _max?: MediaFileMaxAggregateInputType
  }

  export type MediaFileGroupByOutputType = {
    id: string
    postId: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width: number | null
    height: number | null
    sizeBytes: number
    createdAt: Date
    updatedAt: Date
    _count: MediaFileCountAggregateOutputType | null
    _avg: MediaFileAvgAggregateOutputType | null
    _sum: MediaFileSumAggregateOutputType | null
    _min: MediaFileMinAggregateOutputType | null
    _max: MediaFileMaxAggregateOutputType | null
  }

  type GetMediaFileGroupByPayload<T extends MediaFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaFileGroupByOutputType[P]>
            : GetScalarType<T[P], MediaFileGroupByOutputType[P]>
        }
      >
    >


  export type MediaFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectScalar = {
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "type" | "url" | "mimeType" | "width" | "height" | "sizeBytes" | "createdAt" | "updatedAt", ExtArgs["result"]["mediaFile"]>
  export type MediaFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type MediaFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type MediaFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $MediaFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaFile"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      type: $Enums.MediaType
      url: string
      mimeType: string
      width: number | null
      height: number | null
      sizeBytes: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mediaFile"]>
    composites: {}
  }

  type MediaFileGetPayload<S extends boolean | null | undefined | MediaFileDefaultArgs> = $Result.GetResult<Prisma.$MediaFilePayload, S>

  type MediaFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaFileCountAggregateInputType | true
    }

  export interface MediaFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaFile'], meta: { name: 'MediaFile' } }
    /**
     * Find zero or one MediaFile that matches the filter.
     * @param {MediaFileFindUniqueArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFileFindUniqueArgs>(args: SelectSubset<T, MediaFileFindUniqueArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFileFindUniqueOrThrowArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFileFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindFirstArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFileFindFirstArgs>(args?: SelectSubset<T, MediaFileFindFirstArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindFirstOrThrowArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFileFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaFiles
     * const mediaFiles = await prisma.mediaFile.findMany()
     * 
     * // Get first 10 MediaFiles
     * const mediaFiles = await prisma.mediaFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFileFindManyArgs>(args?: SelectSubset<T, MediaFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaFile.
     * @param {MediaFileCreateArgs} args - Arguments to create a MediaFile.
     * @example
     * // Create one MediaFile
     * const MediaFile = await prisma.mediaFile.create({
     *   data: {
     *     // ... data to create a MediaFile
     *   }
     * })
     * 
     */
    create<T extends MediaFileCreateArgs>(args: SelectSubset<T, MediaFileCreateArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaFiles.
     * @param {MediaFileCreateManyArgs} args - Arguments to create many MediaFiles.
     * @example
     * // Create many MediaFiles
     * const mediaFile = await prisma.mediaFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaFileCreateManyArgs>(args?: SelectSubset<T, MediaFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaFiles and returns the data saved in the database.
     * @param {MediaFileCreateManyAndReturnArgs} args - Arguments to create many MediaFiles.
     * @example
     * // Create many MediaFiles
     * const mediaFile = await prisma.mediaFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaFiles and only return the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaFileCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaFile.
     * @param {MediaFileDeleteArgs} args - Arguments to delete one MediaFile.
     * @example
     * // Delete one MediaFile
     * const MediaFile = await prisma.mediaFile.delete({
     *   where: {
     *     // ... filter to delete one MediaFile
     *   }
     * })
     * 
     */
    delete<T extends MediaFileDeleteArgs>(args: SelectSubset<T, MediaFileDeleteArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaFile.
     * @param {MediaFileUpdateArgs} args - Arguments to update one MediaFile.
     * @example
     * // Update one MediaFile
     * const mediaFile = await prisma.mediaFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaFileUpdateArgs>(args: SelectSubset<T, MediaFileUpdateArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaFiles.
     * @param {MediaFileDeleteManyArgs} args - Arguments to filter MediaFiles to delete.
     * @example
     * // Delete a few MediaFiles
     * const { count } = await prisma.mediaFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaFileDeleteManyArgs>(args?: SelectSubset<T, MediaFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaFiles
     * const mediaFile = await prisma.mediaFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaFileUpdateManyArgs>(args: SelectSubset<T, MediaFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaFiles and returns the data updated in the database.
     * @param {MediaFileUpdateManyAndReturnArgs} args - Arguments to update many MediaFiles.
     * @example
     * // Update many MediaFiles
     * const mediaFile = await prisma.mediaFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaFiles and only return the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaFileUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaFile.
     * @param {MediaFileUpsertArgs} args - Arguments to update or create a MediaFile.
     * @example
     * // Update or create a MediaFile
     * const mediaFile = await prisma.mediaFile.upsert({
     *   create: {
     *     // ... data to create a MediaFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaFile we want to update
     *   }
     * })
     */
    upsert<T extends MediaFileUpsertArgs>(args: SelectSubset<T, MediaFileUpsertArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileCountArgs} args - Arguments to filter MediaFiles to count.
     * @example
     * // Count the number of MediaFiles
     * const count = await prisma.mediaFile.count({
     *   where: {
     *     // ... the filter for the MediaFiles we want to count
     *   }
     * })
    **/
    count<T extends MediaFileCountArgs>(
      args?: Subset<T, MediaFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaFileAggregateArgs>(args: Subset<T, MediaFileAggregateArgs>): Prisma.PrismaPromise<GetMediaFileAggregateType<T>>

    /**
     * Group by MediaFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaFileGroupByArgs['orderBy'] }
        : { orderBy?: MediaFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaFile model
   */
  readonly fields: MediaFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaFile model
   */
  interface MediaFileFieldRefs {
    readonly id: FieldRef<"MediaFile", 'String'>
    readonly postId: FieldRef<"MediaFile", 'String'>
    readonly type: FieldRef<"MediaFile", 'MediaType'>
    readonly url: FieldRef<"MediaFile", 'String'>
    readonly mimeType: FieldRef<"MediaFile", 'String'>
    readonly width: FieldRef<"MediaFile", 'Int'>
    readonly height: FieldRef<"MediaFile", 'Int'>
    readonly sizeBytes: FieldRef<"MediaFile", 'Int'>
    readonly createdAt: FieldRef<"MediaFile", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaFile findUnique
   */
  export type MediaFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile findUniqueOrThrow
   */
  export type MediaFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile findFirst
   */
  export type MediaFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFiles.
     */
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile findFirstOrThrow
   */
  export type MediaFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFiles.
     */
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile findMany
   */
  export type MediaFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFiles to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile create
   */
  export type MediaFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaFile.
     */
    data: XOR<MediaFileCreateInput, MediaFileUncheckedCreateInput>
  }

  /**
   * MediaFile createMany
   */
  export type MediaFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaFiles.
     */
    data: MediaFileCreateManyInput | MediaFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaFile createManyAndReturn
   */
  export type MediaFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * The data used to create many MediaFiles.
     */
    data: MediaFileCreateManyInput | MediaFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaFile update
   */
  export type MediaFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaFile.
     */
    data: XOR<MediaFileUpdateInput, MediaFileUncheckedUpdateInput>
    /**
     * Choose, which MediaFile to update.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile updateMany
   */
  export type MediaFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaFiles.
     */
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyInput>
    /**
     * Filter which MediaFiles to update
     */
    where?: MediaFileWhereInput
    /**
     * Limit how many MediaFiles to update.
     */
    limit?: number
  }

  /**
   * MediaFile updateManyAndReturn
   */
  export type MediaFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * The data used to update MediaFiles.
     */
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyInput>
    /**
     * Filter which MediaFiles to update
     */
    where?: MediaFileWhereInput
    /**
     * Limit how many MediaFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaFile upsert
   */
  export type MediaFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaFile to update in case it exists.
     */
    where: MediaFileWhereUniqueInput
    /**
     * In case the MediaFile found by the `where` argument doesn't exist, create a new MediaFile with this data.
     */
    create: XOR<MediaFileCreateInput, MediaFileUncheckedCreateInput>
    /**
     * In case the MediaFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaFileUpdateInput, MediaFileUncheckedUpdateInput>
  }

  /**
   * MediaFile delete
   */
  export type MediaFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter which MediaFile to delete.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile deleteMany
   */
  export type MediaFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFiles to delete
     */
    where?: MediaFileWhereInput
    /**
     * Limit how many MediaFiles to delete.
     */
    limit?: number
  }

  /**
   * MediaFile without action
   */
  export type MediaFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    likeCount: number | null
  }

  export type CommentSumAggregateOutputType = {
    likeCount: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    profileId: string | null
    parentCommentId: string | null
    content: string | null
    likeCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    profileId: string | null
    parentCommentId: string | null
    content: string | null
    likeCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    profileId: number
    parentCommentId: number
    content: number
    likeCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    likeCount?: true
  }

  export type CommentSumAggregateInputType = {
    likeCount?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    parentCommentId?: true
    content?: true
    likeCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    parentCommentId?: true
    content?: true
    likeCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    parentCommentId?: true
    content?: true
    likeCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    profileId: string
    parentCommentId: string | null
    content: string
    likeCount: number
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    parentCommentId?: boolean
    content?: boolean
    likeCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    reactions?: boolean | Comment$reactionsArgs<ExtArgs>
    notifications?: boolean | Comment$notificationsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    parentCommentId?: boolean
    content?: boolean
    likeCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    parentCommentId?: boolean
    content?: boolean
    likeCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    profileId?: boolean
    parentCommentId?: boolean
    content?: boolean
    likeCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "profileId" | "parentCommentId" | "content" | "likeCount" | "createdAt" | "updatedAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    reactions?: boolean | Comment$reactionsArgs<ExtArgs>
    notifications?: boolean | Comment$notificationsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      parentComment: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
      post: Prisma.$PostPayload<ExtArgs>
      author: Prisma.$ProfilePayload<ExtArgs>
      reactions: Prisma.$CommentReactionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      profileId: string
      parentCommentId: string | null
      content: string
      likeCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parentComment<T extends Comment$parentCommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentCommentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reactions<T extends Comment$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Comment$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly profileId: FieldRef<"Comment", 'String'>
    readonly parentCommentId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly likeCount: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parentComment
   */
  export type Comment$parentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.reactions
   */
  export type Comment$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    where?: CommentReactionWhereInput
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    cursor?: CommentReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * Comment.notifications
   */
  export type Comment$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model PostReaction
   */

  export type AggregatePostReaction = {
    _count: PostReactionCountAggregateOutputType | null
    _min: PostReactionMinAggregateOutputType | null
    _max: PostReactionMaxAggregateOutputType | null
  }

  export type PostReactionMinAggregateOutputType = {
    id: string | null
    postId: string | null
    profileId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type PostReactionMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    profileId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type PostReactionCountAggregateOutputType = {
    id: number
    postId: number
    profileId: number
    type: number
    createdAt: number
    _all: number
  }


  export type PostReactionMinAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type PostReactionMaxAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type PostReactionCountAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type PostReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostReaction to aggregate.
     */
    where?: PostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReactions to fetch.
     */
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostReactions
    **/
    _count?: true | PostReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostReactionMaxAggregateInputType
  }

  export type GetPostReactionAggregateType<T extends PostReactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePostReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostReaction[P]>
      : GetScalarType<T[P], AggregatePostReaction[P]>
  }




  export type PostReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostReactionWhereInput
    orderBy?: PostReactionOrderByWithAggregationInput | PostReactionOrderByWithAggregationInput[]
    by: PostReactionScalarFieldEnum[] | PostReactionScalarFieldEnum
    having?: PostReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostReactionCountAggregateInputType | true
    _min?: PostReactionMinAggregateInputType
    _max?: PostReactionMaxAggregateInputType
  }

  export type PostReactionGroupByOutputType = {
    id: string
    postId: string
    profileId: string
    type: $Enums.ReactionType
    createdAt: Date
    _count: PostReactionCountAggregateOutputType | null
    _min: PostReactionMinAggregateOutputType | null
    _max: PostReactionMaxAggregateOutputType | null
  }

  type GetPostReactionGroupByPayload<T extends PostReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostReactionGroupByOutputType[P]>
            : GetScalarType<T[P], PostReactionGroupByOutputType[P]>
        }
      >
    >


  export type PostReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postReaction"]>

  export type PostReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postReaction"]>

  export type PostReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postReaction"]>

  export type PostReactionSelectScalar = {
    id?: boolean
    postId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type PostReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "profileId" | "type" | "createdAt", ExtArgs["result"]["postReaction"]>
  export type PostReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type PostReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type PostReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $PostReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostReaction"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      profileId: string
      type: $Enums.ReactionType
      createdAt: Date
    }, ExtArgs["result"]["postReaction"]>
    composites: {}
  }

  type PostReactionGetPayload<S extends boolean | null | undefined | PostReactionDefaultArgs> = $Result.GetResult<Prisma.$PostReactionPayload, S>

  type PostReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostReactionCountAggregateInputType | true
    }

  export interface PostReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostReaction'], meta: { name: 'PostReaction' } }
    /**
     * Find zero or one PostReaction that matches the filter.
     * @param {PostReactionFindUniqueArgs} args - Arguments to find a PostReaction
     * @example
     * // Get one PostReaction
     * const postReaction = await prisma.postReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostReactionFindUniqueArgs>(args: SelectSubset<T, PostReactionFindUniqueArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostReaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostReactionFindUniqueOrThrowArgs} args - Arguments to find a PostReaction
     * @example
     * // Get one PostReaction
     * const postReaction = await prisma.postReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PostReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionFindFirstArgs} args - Arguments to find a PostReaction
     * @example
     * // Get one PostReaction
     * const postReaction = await prisma.postReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostReactionFindFirstArgs>(args?: SelectSubset<T, PostReactionFindFirstArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionFindFirstOrThrowArgs} args - Arguments to find a PostReaction
     * @example
     * // Get one PostReaction
     * const postReaction = await prisma.postReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PostReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostReactions
     * const postReactions = await prisma.postReaction.findMany()
     * 
     * // Get first 10 PostReactions
     * const postReactions = await prisma.postReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postReactionWithIdOnly = await prisma.postReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostReactionFindManyArgs>(args?: SelectSubset<T, PostReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostReaction.
     * @param {PostReactionCreateArgs} args - Arguments to create a PostReaction.
     * @example
     * // Create one PostReaction
     * const PostReaction = await prisma.postReaction.create({
     *   data: {
     *     // ... data to create a PostReaction
     *   }
     * })
     * 
     */
    create<T extends PostReactionCreateArgs>(args: SelectSubset<T, PostReactionCreateArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostReactions.
     * @param {PostReactionCreateManyArgs} args - Arguments to create many PostReactions.
     * @example
     * // Create many PostReactions
     * const postReaction = await prisma.postReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostReactionCreateManyArgs>(args?: SelectSubset<T, PostReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostReactions and returns the data saved in the database.
     * @param {PostReactionCreateManyAndReturnArgs} args - Arguments to create many PostReactions.
     * @example
     * // Create many PostReactions
     * const postReaction = await prisma.postReaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostReactions and only return the `id`
     * const postReactionWithIdOnly = await prisma.postReaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PostReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostReaction.
     * @param {PostReactionDeleteArgs} args - Arguments to delete one PostReaction.
     * @example
     * // Delete one PostReaction
     * const PostReaction = await prisma.postReaction.delete({
     *   where: {
     *     // ... filter to delete one PostReaction
     *   }
     * })
     * 
     */
    delete<T extends PostReactionDeleteArgs>(args: SelectSubset<T, PostReactionDeleteArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostReaction.
     * @param {PostReactionUpdateArgs} args - Arguments to update one PostReaction.
     * @example
     * // Update one PostReaction
     * const postReaction = await prisma.postReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostReactionUpdateArgs>(args: SelectSubset<T, PostReactionUpdateArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostReactions.
     * @param {PostReactionDeleteManyArgs} args - Arguments to filter PostReactions to delete.
     * @example
     * // Delete a few PostReactions
     * const { count } = await prisma.postReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostReactionDeleteManyArgs>(args?: SelectSubset<T, PostReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostReactions
     * const postReaction = await prisma.postReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostReactionUpdateManyArgs>(args: SelectSubset<T, PostReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostReactions and returns the data updated in the database.
     * @param {PostReactionUpdateManyAndReturnArgs} args - Arguments to update many PostReactions.
     * @example
     * // Update many PostReactions
     * const postReaction = await prisma.postReaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostReactions and only return the `id`
     * const postReactionWithIdOnly = await prisma.postReaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, PostReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostReaction.
     * @param {PostReactionUpsertArgs} args - Arguments to update or create a PostReaction.
     * @example
     * // Update or create a PostReaction
     * const postReaction = await prisma.postReaction.upsert({
     *   create: {
     *     // ... data to create a PostReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostReaction we want to update
     *   }
     * })
     */
    upsert<T extends PostReactionUpsertArgs>(args: SelectSubset<T, PostReactionUpsertArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionCountArgs} args - Arguments to filter PostReactions to count.
     * @example
     * // Count the number of PostReactions
     * const count = await prisma.postReaction.count({
     *   where: {
     *     // ... the filter for the PostReactions we want to count
     *   }
     * })
    **/
    count<T extends PostReactionCountArgs>(
      args?: Subset<T, PostReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostReactionAggregateArgs>(args: Subset<T, PostReactionAggregateArgs>): Prisma.PrismaPromise<GetPostReactionAggregateType<T>>

    /**
     * Group by PostReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostReactionGroupByArgs['orderBy'] }
        : { orderBy?: PostReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostReaction model
   */
  readonly fields: PostReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostReaction model
   */
  interface PostReactionFieldRefs {
    readonly id: FieldRef<"PostReaction", 'String'>
    readonly postId: FieldRef<"PostReaction", 'String'>
    readonly profileId: FieldRef<"PostReaction", 'String'>
    readonly type: FieldRef<"PostReaction", 'ReactionType'>
    readonly createdAt: FieldRef<"PostReaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostReaction findUnique
   */
  export type PostReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReaction to fetch.
     */
    where: PostReactionWhereUniqueInput
  }

  /**
   * PostReaction findUniqueOrThrow
   */
  export type PostReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReaction to fetch.
     */
    where: PostReactionWhereUniqueInput
  }

  /**
   * PostReaction findFirst
   */
  export type PostReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReaction to fetch.
     */
    where?: PostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReactions to fetch.
     */
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostReactions.
     */
    cursor?: PostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostReactions.
     */
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * PostReaction findFirstOrThrow
   */
  export type PostReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReaction to fetch.
     */
    where?: PostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReactions to fetch.
     */
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostReactions.
     */
    cursor?: PostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostReactions.
     */
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * PostReaction findMany
   */
  export type PostReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReactions to fetch.
     */
    where?: PostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReactions to fetch.
     */
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostReactions.
     */
    cursor?: PostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReactions.
     */
    skip?: number
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * PostReaction create
   */
  export type PostReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PostReaction.
     */
    data: XOR<PostReactionCreateInput, PostReactionUncheckedCreateInput>
  }

  /**
   * PostReaction createMany
   */
  export type PostReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostReactions.
     */
    data: PostReactionCreateManyInput | PostReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostReaction createManyAndReturn
   */
  export type PostReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * The data used to create many PostReactions.
     */
    data: PostReactionCreateManyInput | PostReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostReaction update
   */
  export type PostReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PostReaction.
     */
    data: XOR<PostReactionUpdateInput, PostReactionUncheckedUpdateInput>
    /**
     * Choose, which PostReaction to update.
     */
    where: PostReactionWhereUniqueInput
  }

  /**
   * PostReaction updateMany
   */
  export type PostReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostReactions.
     */
    data: XOR<PostReactionUpdateManyMutationInput, PostReactionUncheckedUpdateManyInput>
    /**
     * Filter which PostReactions to update
     */
    where?: PostReactionWhereInput
    /**
     * Limit how many PostReactions to update.
     */
    limit?: number
  }

  /**
   * PostReaction updateManyAndReturn
   */
  export type PostReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * The data used to update PostReactions.
     */
    data: XOR<PostReactionUpdateManyMutationInput, PostReactionUncheckedUpdateManyInput>
    /**
     * Filter which PostReactions to update
     */
    where?: PostReactionWhereInput
    /**
     * Limit how many PostReactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostReaction upsert
   */
  export type PostReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PostReaction to update in case it exists.
     */
    where: PostReactionWhereUniqueInput
    /**
     * In case the PostReaction found by the `where` argument doesn't exist, create a new PostReaction with this data.
     */
    create: XOR<PostReactionCreateInput, PostReactionUncheckedCreateInput>
    /**
     * In case the PostReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostReactionUpdateInput, PostReactionUncheckedUpdateInput>
  }

  /**
   * PostReaction delete
   */
  export type PostReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter which PostReaction to delete.
     */
    where: PostReactionWhereUniqueInput
  }

  /**
   * PostReaction deleteMany
   */
  export type PostReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostReactions to delete
     */
    where?: PostReactionWhereInput
    /**
     * Limit how many PostReactions to delete.
     */
    limit?: number
  }

  /**
   * PostReaction without action
   */
  export type PostReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
  }


  /**
   * Model CommentReaction
   */

  export type AggregateCommentReaction = {
    _count: CommentReactionCountAggregateOutputType | null
    _min: CommentReactionMinAggregateOutputType | null
    _max: CommentReactionMaxAggregateOutputType | null
  }

  export type CommentReactionMinAggregateOutputType = {
    id: string | null
    commentId: string | null
    profileId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type CommentReactionMaxAggregateOutputType = {
    id: string | null
    commentId: string | null
    profileId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type CommentReactionCountAggregateOutputType = {
    id: number
    commentId: number
    profileId: number
    type: number
    createdAt: number
    _all: number
  }


  export type CommentReactionMinAggregateInputType = {
    id?: true
    commentId?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type CommentReactionMaxAggregateInputType = {
    id?: true
    commentId?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type CommentReactionCountAggregateInputType = {
    id?: true
    commentId?: true
    profileId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type CommentReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReaction to aggregate.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentReactions
    **/
    _count?: true | CommentReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentReactionMaxAggregateInputType
  }

  export type GetCommentReactionAggregateType<T extends CommentReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentReaction[P]>
      : GetScalarType<T[P], AggregateCommentReaction[P]>
  }




  export type CommentReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReactionWhereInput
    orderBy?: CommentReactionOrderByWithAggregationInput | CommentReactionOrderByWithAggregationInput[]
    by: CommentReactionScalarFieldEnum[] | CommentReactionScalarFieldEnum
    having?: CommentReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentReactionCountAggregateInputType | true
    _min?: CommentReactionMinAggregateInputType
    _max?: CommentReactionMaxAggregateInputType
  }

  export type CommentReactionGroupByOutputType = {
    id: string
    commentId: string
    profileId: string
    type: $Enums.ReactionType
    createdAt: Date
    _count: CommentReactionCountAggregateOutputType | null
    _min: CommentReactionMinAggregateOutputType | null
    _max: CommentReactionMaxAggregateOutputType | null
  }

  type GetCommentReactionGroupByPayload<T extends CommentReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentReactionGroupByOutputType[P]>
            : GetScalarType<T[P], CommentReactionGroupByOutputType[P]>
        }
      >
    >


  export type CommentReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReaction"]>

  export type CommentReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReaction"]>

  export type CommentReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReaction"]>

  export type CommentReactionSelectScalar = {
    id?: boolean
    commentId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type CommentReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commentId" | "profileId" | "type" | "createdAt", ExtArgs["result"]["commentReaction"]>
  export type CommentReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type CommentReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type CommentReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $CommentReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentReaction"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commentId: string
      profileId: string
      type: $Enums.ReactionType
      createdAt: Date
    }, ExtArgs["result"]["commentReaction"]>
    composites: {}
  }

  type CommentReactionGetPayload<S extends boolean | null | undefined | CommentReactionDefaultArgs> = $Result.GetResult<Prisma.$CommentReactionPayload, S>

  type CommentReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentReactionCountAggregateInputType | true
    }

  export interface CommentReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentReaction'], meta: { name: 'CommentReaction' } }
    /**
     * Find zero or one CommentReaction that matches the filter.
     * @param {CommentReactionFindUniqueArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentReactionFindUniqueArgs>(args: SelectSubset<T, CommentReactionFindUniqueArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentReaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentReactionFindUniqueOrThrowArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionFindFirstArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentReactionFindFirstArgs>(args?: SelectSubset<T, CommentReactionFindFirstArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionFindFirstOrThrowArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentReactions
     * const commentReactions = await prisma.commentReaction.findMany()
     * 
     * // Get first 10 CommentReactions
     * const commentReactions = await prisma.commentReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentReactionWithIdOnly = await prisma.commentReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentReactionFindManyArgs>(args?: SelectSubset<T, CommentReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentReaction.
     * @param {CommentReactionCreateArgs} args - Arguments to create a CommentReaction.
     * @example
     * // Create one CommentReaction
     * const CommentReaction = await prisma.commentReaction.create({
     *   data: {
     *     // ... data to create a CommentReaction
     *   }
     * })
     * 
     */
    create<T extends CommentReactionCreateArgs>(args: SelectSubset<T, CommentReactionCreateArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentReactions.
     * @param {CommentReactionCreateManyArgs} args - Arguments to create many CommentReactions.
     * @example
     * // Create many CommentReactions
     * const commentReaction = await prisma.commentReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentReactionCreateManyArgs>(args?: SelectSubset<T, CommentReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentReactions and returns the data saved in the database.
     * @param {CommentReactionCreateManyAndReturnArgs} args - Arguments to create many CommentReactions.
     * @example
     * // Create many CommentReactions
     * const commentReaction = await prisma.commentReaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentReactions and only return the `id`
     * const commentReactionWithIdOnly = await prisma.commentReaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentReaction.
     * @param {CommentReactionDeleteArgs} args - Arguments to delete one CommentReaction.
     * @example
     * // Delete one CommentReaction
     * const CommentReaction = await prisma.commentReaction.delete({
     *   where: {
     *     // ... filter to delete one CommentReaction
     *   }
     * })
     * 
     */
    delete<T extends CommentReactionDeleteArgs>(args: SelectSubset<T, CommentReactionDeleteArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentReaction.
     * @param {CommentReactionUpdateArgs} args - Arguments to update one CommentReaction.
     * @example
     * // Update one CommentReaction
     * const commentReaction = await prisma.commentReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentReactionUpdateArgs>(args: SelectSubset<T, CommentReactionUpdateArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentReactions.
     * @param {CommentReactionDeleteManyArgs} args - Arguments to filter CommentReactions to delete.
     * @example
     * // Delete a few CommentReactions
     * const { count } = await prisma.commentReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentReactionDeleteManyArgs>(args?: SelectSubset<T, CommentReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentReactions
     * const commentReaction = await prisma.commentReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentReactionUpdateManyArgs>(args: SelectSubset<T, CommentReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentReactions and returns the data updated in the database.
     * @param {CommentReactionUpdateManyAndReturnArgs} args - Arguments to update many CommentReactions.
     * @example
     * // Update many CommentReactions
     * const commentReaction = await prisma.commentReaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentReactions and only return the `id`
     * const commentReactionWithIdOnly = await prisma.commentReaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentReaction.
     * @param {CommentReactionUpsertArgs} args - Arguments to update or create a CommentReaction.
     * @example
     * // Update or create a CommentReaction
     * const commentReaction = await prisma.commentReaction.upsert({
     *   create: {
     *     // ... data to create a CommentReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentReaction we want to update
     *   }
     * })
     */
    upsert<T extends CommentReactionUpsertArgs>(args: SelectSubset<T, CommentReactionUpsertArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionCountArgs} args - Arguments to filter CommentReactions to count.
     * @example
     * // Count the number of CommentReactions
     * const count = await prisma.commentReaction.count({
     *   where: {
     *     // ... the filter for the CommentReactions we want to count
     *   }
     * })
    **/
    count<T extends CommentReactionCountArgs>(
      args?: Subset<T, CommentReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentReactionAggregateArgs>(args: Subset<T, CommentReactionAggregateArgs>): Prisma.PrismaPromise<GetCommentReactionAggregateType<T>>

    /**
     * Group by CommentReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentReactionGroupByArgs['orderBy'] }
        : { orderBy?: CommentReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentReaction model
   */
  readonly fields: CommentReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentReaction model
   */
  interface CommentReactionFieldRefs {
    readonly id: FieldRef<"CommentReaction", 'String'>
    readonly commentId: FieldRef<"CommentReaction", 'String'>
    readonly profileId: FieldRef<"CommentReaction", 'String'>
    readonly type: FieldRef<"CommentReaction", 'ReactionType'>
    readonly createdAt: FieldRef<"CommentReaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommentReaction findUnique
   */
  export type CommentReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction findUniqueOrThrow
   */
  export type CommentReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction findFirst
   */
  export type CommentReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReactions.
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReactions.
     */
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * CommentReaction findFirstOrThrow
   */
  export type CommentReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReactions.
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReactions.
     */
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * CommentReaction findMany
   */
  export type CommentReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReactions to fetch.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentReactions.
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * CommentReaction create
   */
  export type CommentReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentReaction.
     */
    data: XOR<CommentReactionCreateInput, CommentReactionUncheckedCreateInput>
  }

  /**
   * CommentReaction createMany
   */
  export type CommentReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentReactions.
     */
    data: CommentReactionCreateManyInput | CommentReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentReaction createManyAndReturn
   */
  export type CommentReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * The data used to create many CommentReactions.
     */
    data: CommentReactionCreateManyInput | CommentReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentReaction update
   */
  export type CommentReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentReaction.
     */
    data: XOR<CommentReactionUpdateInput, CommentReactionUncheckedUpdateInput>
    /**
     * Choose, which CommentReaction to update.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction updateMany
   */
  export type CommentReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentReactions.
     */
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyInput>
    /**
     * Filter which CommentReactions to update
     */
    where?: CommentReactionWhereInput
    /**
     * Limit how many CommentReactions to update.
     */
    limit?: number
  }

  /**
   * CommentReaction updateManyAndReturn
   */
  export type CommentReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * The data used to update CommentReactions.
     */
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyInput>
    /**
     * Filter which CommentReactions to update
     */
    where?: CommentReactionWhereInput
    /**
     * Limit how many CommentReactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentReaction upsert
   */
  export type CommentReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentReaction to update in case it exists.
     */
    where: CommentReactionWhereUniqueInput
    /**
     * In case the CommentReaction found by the `where` argument doesn't exist, create a new CommentReaction with this data.
     */
    create: XOR<CommentReactionCreateInput, CommentReactionUncheckedCreateInput>
    /**
     * In case the CommentReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentReactionUpdateInput, CommentReactionUncheckedUpdateInput>
  }

  /**
   * CommentReaction delete
   */
  export type CommentReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter which CommentReaction to delete.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction deleteMany
   */
  export type CommentReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReactions to delete
     */
    where?: CommentReactionWhereInput
    /**
     * Limit how many CommentReactions to delete.
     */
    limit?: number
  }

  /**
   * CommentReaction without action
   */
  export type CommentReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    isGroup: boolean | null
    title: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    isGroup: boolean | null
    title: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    isGroup: number
    title: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    isGroup?: true
    title?: true
    createdById?: true
    createdAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    isGroup?: true
    title?: true
    createdById?: true
    createdAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    isGroup?: true
    title?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    isGroup: boolean
    title: string | null
    createdById: string | null
    createdAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    createdAt?: boolean
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    createdAt?: boolean
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    createdAt?: boolean
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isGroup" | "title" | "createdById" | "createdAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      createdBy: Prisma.$ProfilePayload<ExtArgs> | null
      participants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isGroup: boolean
      title: string | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Conversation$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$createdByArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly isGroup: FieldRef<"Conversation", 'Boolean'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly createdById: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data?: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.createdBy
   */
  export type Conversation$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    profileId: string | null
    role: string | null
    lastReadAt: Date | null
    joinedAt: Date | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    profileId: string | null
    role: string | null
    lastReadAt: Date | null
    joinedAt: Date | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    id: number
    conversationId: number
    profileId: number
    role: number
    lastReadAt: number
    joinedAt: number
    _all: number
  }


  export type ConversationParticipantMinAggregateInputType = {
    id?: true
    conversationId?: true
    profileId?: true
    role?: true
    lastReadAt?: true
    joinedAt?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    id?: true
    conversationId?: true
    profileId?: true
    role?: true
    lastReadAt?: true
    joinedAt?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    id?: true
    conversationId?: true
    profileId?: true
    role?: true
    lastReadAt?: true
    joinedAt?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipant to aggregate.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type ConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithAggregationInput | ConversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: ConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    id: string
    conversationId: string
    profileId: string
    role: string
    lastReadAt: Date | null
    joinedAt: Date
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends ConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    profileId?: boolean
    role?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    profileId?: boolean
    role?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    profileId?: boolean
    role?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectScalar = {
    id?: boolean
    conversationId?: boolean
    profileId?: boolean
    role?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
  }

  export type ConversationParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "profileId" | "role" | "lastReadAt" | "joinedAt", ExtArgs["result"]["conversationParticipant"]>
  export type ConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationParticipant"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      profileId: string
      role: string
      lastReadAt: Date | null
      joinedAt: Date
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }

  type ConversationParticipantGetPayload<S extends boolean | null | undefined | ConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$ConversationParticipantPayload, S>

  type ConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface ConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationParticipant'], meta: { name: 'ConversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {ConversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationParticipantFindUniqueArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationParticipantFindFirstArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationParticipantFindManyArgs>(args?: SelectSubset<T, ConversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationParticipant.
     * @param {ConversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends ConversationParticipantCreateArgs>(args: SelectSubset<T, ConversationParticipantCreateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationParticipants.
     * @param {ConversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationParticipantCreateManyArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationParticipants and returns the data saved in the database.
     * @param {ConversationParticipantCreateManyAndReturnArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationParticipant.
     * @param {ConversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends ConversationParticipantDeleteArgs>(args: SelectSubset<T, ConversationParticipantDeleteArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationParticipant.
     * @param {ConversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationParticipantUpdateArgs>(args: SelectSubset<T, ConversationParticipantUpdateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {ConversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationParticipantDeleteManyArgs>(args?: SelectSubset<T, ConversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationParticipantUpdateManyArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants and returns the data updated in the database.
     * @param {ConversationParticipantUpdateManyAndReturnArgs} args - Arguments to update many ConversationParticipants.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationParticipant.
     * @param {ConversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ConversationParticipantUpsertArgs>(args: SelectSubset<T, ConversationParticipantUpsertArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends ConversationParticipantCountArgs>(
      args?: Subset<T, ConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationParticipant model
   */
  readonly fields: ConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationParticipant model
   */
  interface ConversationParticipantFieldRefs {
    readonly id: FieldRef<"ConversationParticipant", 'String'>
    readonly conversationId: FieldRef<"ConversationParticipant", 'String'>
    readonly profileId: FieldRef<"ConversationParticipant", 'String'>
    readonly role: FieldRef<"ConversationParticipant", 'String'>
    readonly lastReadAt: FieldRef<"ConversationParticipant", 'DateTime'>
    readonly joinedAt: FieldRef<"ConversationParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationParticipant findUnique
   */
  export type ConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findUniqueOrThrow
   */
  export type ConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findFirst
   */
  export type ConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findFirstOrThrow
   */
  export type ConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findMany
   */
  export type ConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipants to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant create
   */
  export type ConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationParticipant.
     */
    data: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
  }

  /**
   * ConversationParticipant createMany
   */
  export type ConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationParticipant createManyAndReturn
   */
  export type ConversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant update
   */
  export type ConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationParticipant.
     */
    data: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which ConversationParticipant to update.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant updateMany
   */
  export type ConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to update.
     */
    limit?: number
  }

  /**
   * ConversationParticipant updateManyAndReturn
   */
  export type ConversationParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant upsert
   */
  export type ConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationParticipant to update in case it exists.
     */
    where: ConversationParticipantWhereUniqueInput
    /**
     * In case the ConversationParticipant found by the `where` argument doesn't exist, create a new ConversationParticipant with this data.
     */
    create: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
    /**
     * In case the ConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
  }

  /**
   * ConversationParticipant delete
   */
  export type ConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which ConversationParticipant to delete.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant deleteMany
   */
  export type ConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipants to delete
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to delete.
     */
    limit?: number
  }

  /**
   * ConversationParticipant without action
   */
  export type ConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    mediaUrl: string | null
    createdAt: Date | null
    deletedAt: Date | null
    timestamp: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    mediaUrl: string | null
    createdAt: Date | null
    deletedAt: Date | null
    timestamp: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    mediaUrl: number
    createdAt: number
    deletedAt: number
    timestamp: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    mediaUrl?: true
    createdAt?: true
    deletedAt?: true
    timestamp?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    mediaUrl?: true
    createdAt?: true
    deletedAt?: true
    timestamp?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    mediaUrl?: true
    createdAt?: true
    deletedAt?: true
    timestamp?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    content: string | null
    mediaUrl: string | null
    createdAt: Date
    deletedAt: Date | null
    timestamp: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    timestamp?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
    reads?: boolean | Message$readsArgs<ExtArgs>
    notifications?: boolean | Message$notificationsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    timestamp?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    timestamp?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    timestamp?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "content" | "mediaUrl" | "createdAt" | "deletedAt" | "timestamp", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
    reads?: boolean | Message$readsArgs<ExtArgs>
    notifications?: boolean | Message$notificationsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$ProfilePayload<ExtArgs>
      reads: Prisma.$MessageReadPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      content: string | null
      mediaUrl: string | null
      createdAt: Date
      deletedAt: Date | null
      timestamp: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reads<T extends Message$readsArgs<ExtArgs> = {}>(args?: Subset<T, Message$readsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Message$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Message$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly mediaUrl: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly deletedAt: FieldRef<"Message", 'DateTime'>
    readonly timestamp: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.reads
   */
  export type Message$readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    cursor?: MessageReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * Message.notifications
   */
  export type Message$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    recipientId: string | null
    senderId: string | null
    type: $Enums.NotificationType | null
    postId: string | null
    commentId: string | null
    requestId: string | null
    lineageId: string | null
    messageId: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    recipientId: string | null
    senderId: string | null
    type: $Enums.NotificationType | null
    postId: string | null
    commentId: string | null
    requestId: string | null
    lineageId: string | null
    messageId: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    recipientId: number
    senderId: number
    type: number
    postId: number
    commentId: number
    requestId: number
    lineageId: number
    messageId: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
    type?: true
    postId?: true
    commentId?: true
    requestId?: true
    lineageId?: true
    messageId?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
    type?: true
    postId?: true
    commentId?: true
    requestId?: true
    lineageId?: true
    messageId?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    recipientId?: true
    senderId?: true
    type?: true
    postId?: true
    commentId?: true
    requestId?: true
    lineageId?: true
    messageId?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    recipientId: string
    senderId: string | null
    type: $Enums.NotificationType
    postId: string | null
    commentId: string | null
    requestId: string | null
    lineageId: string | null
    messageId: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    requestId?: boolean
    lineageId?: boolean
    messageId?: boolean
    isRead?: boolean
    createdAt?: boolean
    sender?: boolean | Notification$senderArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    requestId?: boolean
    lineageId?: boolean
    messageId?: boolean
    isRead?: boolean
    createdAt?: boolean
    sender?: boolean | Notification$senderArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    requestId?: boolean
    lineageId?: boolean
    messageId?: boolean
    isRead?: boolean
    createdAt?: boolean
    sender?: boolean | Notification$senderArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    recipientId?: boolean
    senderId?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    requestId?: boolean
    lineageId?: boolean
    messageId?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipientId" | "senderId" | "type" | "postId" | "commentId" | "requestId" | "lineageId" | "messageId" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Notification$senderArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Notification$senderArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Notification$senderArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    request?: boolean | Notification$requestArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      sender: Prisma.$ProfilePayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
      lineage: Prisma.$LineagePayload<ExtArgs> | null
      request: Prisma.$FriendRequestPayload<ExtArgs> | null
      message: Prisma.$MessagePayload<ExtArgs> | null
      post: Prisma.$PostPayload<ExtArgs> | null
      recipient: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipientId: string
      senderId: string | null
      type: $Enums.NotificationType
      postId: string | null
      commentId: string | null
      requestId: string | null
      lineageId: string | null
      messageId: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends Notification$senderArgs<ExtArgs> = {}>(args?: Subset<T, Notification$senderArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comment<T extends Notification$commentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lineage<T extends Notification$lineageArgs<ExtArgs> = {}>(args?: Subset<T, Notification$lineageArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    request<T extends Notification$requestArgs<ExtArgs> = {}>(args?: Subset<T, Notification$requestArgs<ExtArgs>>): Prisma__FriendRequestClient<$Result.GetResult<Prisma.$FriendRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    message<T extends Notification$messageArgs<ExtArgs> = {}>(args?: Subset<T, Notification$messageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    post<T extends Notification$postArgs<ExtArgs> = {}>(args?: Subset<T, Notification$postArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recipient<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly senderId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly postId: FieldRef<"Notification", 'String'>
    readonly commentId: FieldRef<"Notification", 'String'>
    readonly requestId: FieldRef<"Notification", 'String'>
    readonly lineageId: FieldRef<"Notification", 'String'>
    readonly messageId: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.sender
   */
  export type Notification$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Notification.comment
   */
  export type Notification$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Notification.lineage
   */
  export type Notification$lineageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    where?: LineageWhereInput
  }

  /**
   * Notification.request
   */
  export type Notification$requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FriendRequest
     */
    select?: FriendRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FriendRequest
     */
    omit?: FriendRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendRequestInclude<ExtArgs> | null
    where?: FriendRequestWhereInput
  }

  /**
   * Notification.message
   */
  export type Notification$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Notification.post
   */
  export type Notification$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Interest
   */

  export type AggregateInterest = {
    _count: InterestCountAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  export type InterestMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type InterestMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type InterestCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type InterestMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type InterestMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type InterestCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type InterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interest to aggregate.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interests
    **/
    _count?: true | InterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestMaxAggregateInputType
  }

  export type GetInterestAggregateType<T extends InterestAggregateArgs> = {
        [P in keyof T & keyof AggregateInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterest[P]>
      : GetScalarType<T[P], AggregateInterest[P]>
  }




  export type InterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithAggregationInput | InterestOrderByWithAggregationInput[]
    by: InterestScalarFieldEnum[] | InterestScalarFieldEnum
    having?: InterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestCountAggregateInputType | true
    _min?: InterestMinAggregateInputType
    _max?: InterestMaxAggregateInputType
  }

  export type InterestGroupByOutputType = {
    id: string
    name: string
    _count: InterestCountAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  type GetInterestGroupByPayload<T extends InterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestGroupByOutputType[P]>
            : GetScalarType<T[P], InterestGroupByOutputType[P]>
        }
      >
    >


  export type InterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Interest$usersArgs<ExtArgs>
    _count?: boolean | InterestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type InterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["interest"]>
  export type InterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Interest$usersArgs<ExtArgs>
    _count?: boolean | InterestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interest"
    objects: {
      users: Prisma.$ProfileInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["interest"]>
    composites: {}
  }

  type InterestGetPayload<S extends boolean | null | undefined | InterestDefaultArgs> = $Result.GetResult<Prisma.$InterestPayload, S>

  type InterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestCountAggregateInputType | true
    }

  export interface InterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interest'], meta: { name: 'Interest' } }
    /**
     * Find zero or one Interest that matches the filter.
     * @param {InterestFindUniqueArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestFindUniqueArgs>(args: SelectSubset<T, InterestFindUniqueArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestFindUniqueOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestFindFirstArgs>(args?: SelectSubset<T, InterestFindFirstArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interests
     * const interests = await prisma.interest.findMany()
     * 
     * // Get first 10 Interests
     * const interests = await prisma.interest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestWithIdOnly = await prisma.interest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestFindManyArgs>(args?: SelectSubset<T, InterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interest.
     * @param {InterestCreateArgs} args - Arguments to create a Interest.
     * @example
     * // Create one Interest
     * const Interest = await prisma.interest.create({
     *   data: {
     *     // ... data to create a Interest
     *   }
     * })
     * 
     */
    create<T extends InterestCreateArgs>(args: SelectSubset<T, InterestCreateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interests.
     * @param {InterestCreateManyArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestCreateManyArgs>(args?: SelectSubset<T, InterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interests and returns the data saved in the database.
     * @param {InterestCreateManyAndReturnArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interests and only return the `id`
     * const interestWithIdOnly = await prisma.interest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Interest.
     * @param {InterestDeleteArgs} args - Arguments to delete one Interest.
     * @example
     * // Delete one Interest
     * const Interest = await prisma.interest.delete({
     *   where: {
     *     // ... filter to delete one Interest
     *   }
     * })
     * 
     */
    delete<T extends InterestDeleteArgs>(args: SelectSubset<T, InterestDeleteArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interest.
     * @param {InterestUpdateArgs} args - Arguments to update one Interest.
     * @example
     * // Update one Interest
     * const interest = await prisma.interest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestUpdateArgs>(args: SelectSubset<T, InterestUpdateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interests.
     * @param {InterestDeleteManyArgs} args - Arguments to filter Interests to delete.
     * @example
     * // Delete a few Interests
     * const { count } = await prisma.interest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestDeleteManyArgs>(args?: SelectSubset<T, InterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interests
     * const interest = await prisma.interest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestUpdateManyArgs>(args: SelectSubset<T, InterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interests and returns the data updated in the database.
     * @param {InterestUpdateManyAndReturnArgs} args - Arguments to update many Interests.
     * @example
     * // Update many Interests
     * const interest = await prisma.interest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interests and only return the `id`
     * const interestWithIdOnly = await prisma.interest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Interest.
     * @param {InterestUpsertArgs} args - Arguments to update or create a Interest.
     * @example
     * // Update or create a Interest
     * const interest = await prisma.interest.upsert({
     *   create: {
     *     // ... data to create a Interest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interest we want to update
     *   }
     * })
     */
    upsert<T extends InterestUpsertArgs>(args: SelectSubset<T, InterestUpsertArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestCountArgs} args - Arguments to filter Interests to count.
     * @example
     * // Count the number of Interests
     * const count = await prisma.interest.count({
     *   where: {
     *     // ... the filter for the Interests we want to count
     *   }
     * })
    **/
    count<T extends InterestCountArgs>(
      args?: Subset<T, InterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestAggregateArgs>(args: Subset<T, InterestAggregateArgs>): Prisma.PrismaPromise<GetInterestAggregateType<T>>

    /**
     * Group by Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestGroupByArgs['orderBy'] }
        : { orderBy?: InterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interest model
   */
  readonly fields: InterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Interest$usersArgs<ExtArgs> = {}>(args?: Subset<T, Interest$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interest model
   */
  interface InterestFieldRefs {
    readonly id: FieldRef<"Interest", 'String'>
    readonly name: FieldRef<"Interest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Interest findUnique
   */
  export type InterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findUniqueOrThrow
   */
  export type InterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findFirst
   */
  export type InterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findFirstOrThrow
   */
  export type InterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findMany
   */
  export type InterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interests to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest create
   */
  export type InterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to create a Interest.
     */
    data: XOR<InterestCreateInput, InterestUncheckedCreateInput>
  }

  /**
   * Interest createMany
   */
  export type InterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest createManyAndReturn
   */
  export type InterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest update
   */
  export type InterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to update a Interest.
     */
    data: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
    /**
     * Choose, which Interest to update.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest updateMany
   */
  export type InterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interests.
     */
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyInput>
    /**
     * Filter which Interests to update
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to update.
     */
    limit?: number
  }

  /**
   * Interest updateManyAndReturn
   */
  export type InterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * The data used to update Interests.
     */
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyInput>
    /**
     * Filter which Interests to update
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to update.
     */
    limit?: number
  }

  /**
   * Interest upsert
   */
  export type InterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The filter to search for the Interest to update in case it exists.
     */
    where: InterestWhereUniqueInput
    /**
     * In case the Interest found by the `where` argument doesn't exist, create a new Interest with this data.
     */
    create: XOR<InterestCreateInput, InterestUncheckedCreateInput>
    /**
     * In case the Interest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
  }

  /**
   * Interest delete
   */
  export type InterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter which Interest to delete.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest deleteMany
   */
  export type InterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interests to delete
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to delete.
     */
    limit?: number
  }

  /**
   * Interest.users
   */
  export type Interest$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    where?: ProfileInterestWhereInput
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    cursor?: ProfileInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * Interest without action
   */
  export type InterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
  }


  /**
   * Model AppInterest
   */

  export type AggregateAppInterest = {
    _count: AppInterestCountAggregateOutputType | null
    _min: AppInterestMinAggregateOutputType | null
    _max: AppInterestMaxAggregateOutputType | null
  }

  export type AppInterestMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type AppInterestMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type AppInterestCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type AppInterestMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type AppInterestMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type AppInterestCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type AppInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppInterest to aggregate.
     */
    where?: AppInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppInterests to fetch.
     */
    orderBy?: AppInterestOrderByWithRelationInput | AppInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppInterests
    **/
    _count?: true | AppInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppInterestMaxAggregateInputType
  }

  export type GetAppInterestAggregateType<T extends AppInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateAppInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppInterest[P]>
      : GetScalarType<T[P], AggregateAppInterest[P]>
  }




  export type AppInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppInterestWhereInput
    orderBy?: AppInterestOrderByWithAggregationInput | AppInterestOrderByWithAggregationInput[]
    by: AppInterestScalarFieldEnum[] | AppInterestScalarFieldEnum
    having?: AppInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppInterestCountAggregateInputType | true
    _min?: AppInterestMinAggregateInputType
    _max?: AppInterestMaxAggregateInputType
  }

  export type AppInterestGroupByOutputType = {
    id: string
    name: string
    _count: AppInterestCountAggregateOutputType | null
    _min: AppInterestMinAggregateOutputType | null
    _max: AppInterestMaxAggregateOutputType | null
  }

  type GetAppInterestGroupByPayload<T extends AppInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppInterestGroupByOutputType[P]>
            : GetScalarType<T[P], AppInterestGroupByOutputType[P]>
        }
      >
    >


  export type AppInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | AppInterest$usersArgs<ExtArgs>
    _count?: boolean | AppInterestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appInterest"]>

  export type AppInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["appInterest"]>

  export type AppInterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["appInterest"]>

  export type AppInterestSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type AppInterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["appInterest"]>
  export type AppInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | AppInterest$usersArgs<ExtArgs>
    _count?: boolean | AppInterestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AppInterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AppInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppInterest"
    objects: {
      users: Prisma.$ProfileAppInterestsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["appInterest"]>
    composites: {}
  }

  type AppInterestGetPayload<S extends boolean | null | undefined | AppInterestDefaultArgs> = $Result.GetResult<Prisma.$AppInterestPayload, S>

  type AppInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppInterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppInterestCountAggregateInputType | true
    }

  export interface AppInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppInterest'], meta: { name: 'AppInterest' } }
    /**
     * Find zero or one AppInterest that matches the filter.
     * @param {AppInterestFindUniqueArgs} args - Arguments to find a AppInterest
     * @example
     * // Get one AppInterest
     * const appInterest = await prisma.appInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppInterestFindUniqueArgs>(args: SelectSubset<T, AppInterestFindUniqueArgs<ExtArgs>>): Prisma__AppInterestClient<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppInterest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppInterestFindUniqueOrThrowArgs} args - Arguments to find a AppInterest
     * @example
     * // Get one AppInterest
     * const appInterest = await prisma.appInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, AppInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppInterestClient<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppInterestFindFirstArgs} args - Arguments to find a AppInterest
     * @example
     * // Get one AppInterest
     * const appInterest = await prisma.appInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppInterestFindFirstArgs>(args?: SelectSubset<T, AppInterestFindFirstArgs<ExtArgs>>): Prisma__AppInterestClient<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppInterestFindFirstOrThrowArgs} args - Arguments to find a AppInterest
     * @example
     * // Get one AppInterest
     * const appInterest = await prisma.appInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, AppInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppInterestClient<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppInterests
     * const appInterests = await prisma.appInterest.findMany()
     * 
     * // Get first 10 AppInterests
     * const appInterests = await prisma.appInterest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appInterestWithIdOnly = await prisma.appInterest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppInterestFindManyArgs>(args?: SelectSubset<T, AppInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppInterest.
     * @param {AppInterestCreateArgs} args - Arguments to create a AppInterest.
     * @example
     * // Create one AppInterest
     * const AppInterest = await prisma.appInterest.create({
     *   data: {
     *     // ... data to create a AppInterest
     *   }
     * })
     * 
     */
    create<T extends AppInterestCreateArgs>(args: SelectSubset<T, AppInterestCreateArgs<ExtArgs>>): Prisma__AppInterestClient<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppInterests.
     * @param {AppInterestCreateManyArgs} args - Arguments to create many AppInterests.
     * @example
     * // Create many AppInterests
     * const appInterest = await prisma.appInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppInterestCreateManyArgs>(args?: SelectSubset<T, AppInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppInterests and returns the data saved in the database.
     * @param {AppInterestCreateManyAndReturnArgs} args - Arguments to create many AppInterests.
     * @example
     * // Create many AppInterests
     * const appInterest = await prisma.appInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppInterests and only return the `id`
     * const appInterestWithIdOnly = await prisma.appInterest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, AppInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppInterest.
     * @param {AppInterestDeleteArgs} args - Arguments to delete one AppInterest.
     * @example
     * // Delete one AppInterest
     * const AppInterest = await prisma.appInterest.delete({
     *   where: {
     *     // ... filter to delete one AppInterest
     *   }
     * })
     * 
     */
    delete<T extends AppInterestDeleteArgs>(args: SelectSubset<T, AppInterestDeleteArgs<ExtArgs>>): Prisma__AppInterestClient<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppInterest.
     * @param {AppInterestUpdateArgs} args - Arguments to update one AppInterest.
     * @example
     * // Update one AppInterest
     * const appInterest = await prisma.appInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppInterestUpdateArgs>(args: SelectSubset<T, AppInterestUpdateArgs<ExtArgs>>): Prisma__AppInterestClient<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppInterests.
     * @param {AppInterestDeleteManyArgs} args - Arguments to filter AppInterests to delete.
     * @example
     * // Delete a few AppInterests
     * const { count } = await prisma.appInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppInterestDeleteManyArgs>(args?: SelectSubset<T, AppInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppInterests
     * const appInterest = await prisma.appInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppInterestUpdateManyArgs>(args: SelectSubset<T, AppInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppInterests and returns the data updated in the database.
     * @param {AppInterestUpdateManyAndReturnArgs} args - Arguments to update many AppInterests.
     * @example
     * // Update many AppInterests
     * const appInterest = await prisma.appInterest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppInterests and only return the `id`
     * const appInterestWithIdOnly = await prisma.appInterest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppInterestUpdateManyAndReturnArgs>(args: SelectSubset<T, AppInterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppInterest.
     * @param {AppInterestUpsertArgs} args - Arguments to update or create a AppInterest.
     * @example
     * // Update or create a AppInterest
     * const appInterest = await prisma.appInterest.upsert({
     *   create: {
     *     // ... data to create a AppInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppInterest we want to update
     *   }
     * })
     */
    upsert<T extends AppInterestUpsertArgs>(args: SelectSubset<T, AppInterestUpsertArgs<ExtArgs>>): Prisma__AppInterestClient<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppInterestCountArgs} args - Arguments to filter AppInterests to count.
     * @example
     * // Count the number of AppInterests
     * const count = await prisma.appInterest.count({
     *   where: {
     *     // ... the filter for the AppInterests we want to count
     *   }
     * })
    **/
    count<T extends AppInterestCountArgs>(
      args?: Subset<T, AppInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppInterestAggregateArgs>(args: Subset<T, AppInterestAggregateArgs>): Prisma.PrismaPromise<GetAppInterestAggregateType<T>>

    /**
     * Group by AppInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppInterestGroupByArgs['orderBy'] }
        : { orderBy?: AppInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppInterest model
   */
  readonly fields: AppInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends AppInterest$usersArgs<ExtArgs> = {}>(args?: Subset<T, AppInterest$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppInterest model
   */
  interface AppInterestFieldRefs {
    readonly id: FieldRef<"AppInterest", 'String'>
    readonly name: FieldRef<"AppInterest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AppInterest findUnique
   */
  export type AppInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
    /**
     * Filter, which AppInterest to fetch.
     */
    where: AppInterestWhereUniqueInput
  }

  /**
   * AppInterest findUniqueOrThrow
   */
  export type AppInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
    /**
     * Filter, which AppInterest to fetch.
     */
    where: AppInterestWhereUniqueInput
  }

  /**
   * AppInterest findFirst
   */
  export type AppInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
    /**
     * Filter, which AppInterest to fetch.
     */
    where?: AppInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppInterests to fetch.
     */
    orderBy?: AppInterestOrderByWithRelationInput | AppInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppInterests.
     */
    cursor?: AppInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppInterests.
     */
    distinct?: AppInterestScalarFieldEnum | AppInterestScalarFieldEnum[]
  }

  /**
   * AppInterest findFirstOrThrow
   */
  export type AppInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
    /**
     * Filter, which AppInterest to fetch.
     */
    where?: AppInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppInterests to fetch.
     */
    orderBy?: AppInterestOrderByWithRelationInput | AppInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppInterests.
     */
    cursor?: AppInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppInterests.
     */
    distinct?: AppInterestScalarFieldEnum | AppInterestScalarFieldEnum[]
  }

  /**
   * AppInterest findMany
   */
  export type AppInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
    /**
     * Filter, which AppInterests to fetch.
     */
    where?: AppInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppInterests to fetch.
     */
    orderBy?: AppInterestOrderByWithRelationInput | AppInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppInterests.
     */
    cursor?: AppInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppInterests.
     */
    skip?: number
    distinct?: AppInterestScalarFieldEnum | AppInterestScalarFieldEnum[]
  }

  /**
   * AppInterest create
   */
  export type AppInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a AppInterest.
     */
    data: XOR<AppInterestCreateInput, AppInterestUncheckedCreateInput>
  }

  /**
   * AppInterest createMany
   */
  export type AppInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppInterests.
     */
    data: AppInterestCreateManyInput | AppInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppInterest createManyAndReturn
   */
  export type AppInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * The data used to create many AppInterests.
     */
    data: AppInterestCreateManyInput | AppInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppInterest update
   */
  export type AppInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a AppInterest.
     */
    data: XOR<AppInterestUpdateInput, AppInterestUncheckedUpdateInput>
    /**
     * Choose, which AppInterest to update.
     */
    where: AppInterestWhereUniqueInput
  }

  /**
   * AppInterest updateMany
   */
  export type AppInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppInterests.
     */
    data: XOR<AppInterestUpdateManyMutationInput, AppInterestUncheckedUpdateManyInput>
    /**
     * Filter which AppInterests to update
     */
    where?: AppInterestWhereInput
    /**
     * Limit how many AppInterests to update.
     */
    limit?: number
  }

  /**
   * AppInterest updateManyAndReturn
   */
  export type AppInterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * The data used to update AppInterests.
     */
    data: XOR<AppInterestUpdateManyMutationInput, AppInterestUncheckedUpdateManyInput>
    /**
     * Filter which AppInterests to update
     */
    where?: AppInterestWhereInput
    /**
     * Limit how many AppInterests to update.
     */
    limit?: number
  }

  /**
   * AppInterest upsert
   */
  export type AppInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the AppInterest to update in case it exists.
     */
    where: AppInterestWhereUniqueInput
    /**
     * In case the AppInterest found by the `where` argument doesn't exist, create a new AppInterest with this data.
     */
    create: XOR<AppInterestCreateInput, AppInterestUncheckedCreateInput>
    /**
     * In case the AppInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppInterestUpdateInput, AppInterestUncheckedUpdateInput>
  }

  /**
   * AppInterest delete
   */
  export type AppInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
    /**
     * Filter which AppInterest to delete.
     */
    where: AppInterestWhereUniqueInput
  }

  /**
   * AppInterest deleteMany
   */
  export type AppInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppInterests to delete
     */
    where?: AppInterestWhereInput
    /**
     * Limit how many AppInterests to delete.
     */
    limit?: number
  }

  /**
   * AppInterest.users
   */
  export type AppInterest$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    where?: ProfileAppInterestsWhereInput
    orderBy?: ProfileAppInterestsOrderByWithRelationInput | ProfileAppInterestsOrderByWithRelationInput[]
    cursor?: ProfileAppInterestsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileAppInterestsScalarFieldEnum | ProfileAppInterestsScalarFieldEnum[]
  }

  /**
   * AppInterest without action
   */
  export type AppInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppInterest
     */
    select?: AppInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppInterest
     */
    omit?: AppInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInterestInclude<ExtArgs> | null
  }


  /**
   * Model ProfileInterest
   */

  export type AggregateProfileInterest = {
    _count: ProfileInterestCountAggregateOutputType | null
    _min: ProfileInterestMinAggregateOutputType | null
    _max: ProfileInterestMaxAggregateOutputType | null
  }

  export type ProfileInterestMinAggregateOutputType = {
    userId: string | null
    interestId: string | null
    createdAt: Date | null
  }

  export type ProfileInterestMaxAggregateOutputType = {
    userId: string | null
    interestId: string | null
    createdAt: Date | null
  }

  export type ProfileInterestCountAggregateOutputType = {
    userId: number
    interestId: number
    createdAt: number
    _all: number
  }


  export type ProfileInterestMinAggregateInputType = {
    userId?: true
    interestId?: true
    createdAt?: true
  }

  export type ProfileInterestMaxAggregateInputType = {
    userId?: true
    interestId?: true
    createdAt?: true
  }

  export type ProfileInterestCountAggregateInputType = {
    userId?: true
    interestId?: true
    createdAt?: true
    _all?: true
  }

  export type ProfileInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileInterest to aggregate.
     */
    where?: ProfileInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileInterests to fetch.
     */
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileInterests
    **/
    _count?: true | ProfileInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileInterestMaxAggregateInputType
  }

  export type GetProfileInterestAggregateType<T extends ProfileInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileInterest[P]>
      : GetScalarType<T[P], AggregateProfileInterest[P]>
  }




  export type ProfileInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileInterestWhereInput
    orderBy?: ProfileInterestOrderByWithAggregationInput | ProfileInterestOrderByWithAggregationInput[]
    by: ProfileInterestScalarFieldEnum[] | ProfileInterestScalarFieldEnum
    having?: ProfileInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileInterestCountAggregateInputType | true
    _min?: ProfileInterestMinAggregateInputType
    _max?: ProfileInterestMaxAggregateInputType
  }

  export type ProfileInterestGroupByOutputType = {
    userId: string
    interestId: string
    createdAt: Date
    _count: ProfileInterestCountAggregateOutputType | null
    _min: ProfileInterestMinAggregateOutputType | null
    _max: ProfileInterestMaxAggregateOutputType | null
  }

  type GetProfileInterestGroupByPayload<T extends ProfileInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileInterestGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileInterestGroupByOutputType[P]>
        }
      >
    >


  export type ProfileInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
    interest?: boolean | InterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileInterest"]>

  export type ProfileInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
    interest?: boolean | InterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileInterest"]>

  export type ProfileInterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
    interest?: boolean | InterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileInterest"]>

  export type ProfileInterestSelectScalar = {
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
  }

  export type ProfileInterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "interestId" | "createdAt", ExtArgs["result"]["profileInterest"]>
  export type ProfileInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interest?: boolean | InterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interest?: boolean | InterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileInterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interest?: boolean | InterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfileInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileInterest"
    objects: {
      interest: Prisma.$InterestPayload<ExtArgs>
      user: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      interestId: string
      createdAt: Date
    }, ExtArgs["result"]["profileInterest"]>
    composites: {}
  }

  type ProfileInterestGetPayload<S extends boolean | null | undefined | ProfileInterestDefaultArgs> = $Result.GetResult<Prisma.$ProfileInterestPayload, S>

  type ProfileInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileInterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileInterestCountAggregateInputType | true
    }

  export interface ProfileInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileInterest'], meta: { name: 'ProfileInterest' } }
    /**
     * Find zero or one ProfileInterest that matches the filter.
     * @param {ProfileInterestFindUniqueArgs} args - Arguments to find a ProfileInterest
     * @example
     * // Get one ProfileInterest
     * const profileInterest = await prisma.profileInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileInterestFindUniqueArgs>(args: SelectSubset<T, ProfileInterestFindUniqueArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileInterest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileInterestFindUniqueOrThrowArgs} args - Arguments to find a ProfileInterest
     * @example
     * // Get one ProfileInterest
     * const profileInterest = await prisma.profileInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestFindFirstArgs} args - Arguments to find a ProfileInterest
     * @example
     * // Get one ProfileInterest
     * const profileInterest = await prisma.profileInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileInterestFindFirstArgs>(args?: SelectSubset<T, ProfileInterestFindFirstArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestFindFirstOrThrowArgs} args - Arguments to find a ProfileInterest
     * @example
     * // Get one ProfileInterest
     * const profileInterest = await prisma.profileInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileInterests
     * const profileInterests = await prisma.profileInterest.findMany()
     * 
     * // Get first 10 ProfileInterests
     * const profileInterests = await prisma.profileInterest.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const profileInterestWithUserIdOnly = await prisma.profileInterest.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ProfileInterestFindManyArgs>(args?: SelectSubset<T, ProfileInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileInterest.
     * @param {ProfileInterestCreateArgs} args - Arguments to create a ProfileInterest.
     * @example
     * // Create one ProfileInterest
     * const ProfileInterest = await prisma.profileInterest.create({
     *   data: {
     *     // ... data to create a ProfileInterest
     *   }
     * })
     * 
     */
    create<T extends ProfileInterestCreateArgs>(args: SelectSubset<T, ProfileInterestCreateArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileInterests.
     * @param {ProfileInterestCreateManyArgs} args - Arguments to create many ProfileInterests.
     * @example
     * // Create many ProfileInterests
     * const profileInterest = await prisma.profileInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileInterestCreateManyArgs>(args?: SelectSubset<T, ProfileInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileInterests and returns the data saved in the database.
     * @param {ProfileInterestCreateManyAndReturnArgs} args - Arguments to create many ProfileInterests.
     * @example
     * // Create many ProfileInterests
     * const profileInterest = await prisma.profileInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileInterests and only return the `userId`
     * const profileInterestWithUserIdOnly = await prisma.profileInterest.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfileInterest.
     * @param {ProfileInterestDeleteArgs} args - Arguments to delete one ProfileInterest.
     * @example
     * // Delete one ProfileInterest
     * const ProfileInterest = await prisma.profileInterest.delete({
     *   where: {
     *     // ... filter to delete one ProfileInterest
     *   }
     * })
     * 
     */
    delete<T extends ProfileInterestDeleteArgs>(args: SelectSubset<T, ProfileInterestDeleteArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileInterest.
     * @param {ProfileInterestUpdateArgs} args - Arguments to update one ProfileInterest.
     * @example
     * // Update one ProfileInterest
     * const profileInterest = await prisma.profileInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileInterestUpdateArgs>(args: SelectSubset<T, ProfileInterestUpdateArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileInterests.
     * @param {ProfileInterestDeleteManyArgs} args - Arguments to filter ProfileInterests to delete.
     * @example
     * // Delete a few ProfileInterests
     * const { count } = await prisma.profileInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileInterestDeleteManyArgs>(args?: SelectSubset<T, ProfileInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileInterests
     * const profileInterest = await prisma.profileInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileInterestUpdateManyArgs>(args: SelectSubset<T, ProfileInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileInterests and returns the data updated in the database.
     * @param {ProfileInterestUpdateManyAndReturnArgs} args - Arguments to update many ProfileInterests.
     * @example
     * // Update many ProfileInterests
     * const profileInterest = await prisma.profileInterest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfileInterests and only return the `userId`
     * const profileInterestWithUserIdOnly = await prisma.profileInterest.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileInterestUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileInterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfileInterest.
     * @param {ProfileInterestUpsertArgs} args - Arguments to update or create a ProfileInterest.
     * @example
     * // Update or create a ProfileInterest
     * const profileInterest = await prisma.profileInterest.upsert({
     *   create: {
     *     // ... data to create a ProfileInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileInterest we want to update
     *   }
     * })
     */
    upsert<T extends ProfileInterestUpsertArgs>(args: SelectSubset<T, ProfileInterestUpsertArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestCountArgs} args - Arguments to filter ProfileInterests to count.
     * @example
     * // Count the number of ProfileInterests
     * const count = await prisma.profileInterest.count({
     *   where: {
     *     // ... the filter for the ProfileInterests we want to count
     *   }
     * })
    **/
    count<T extends ProfileInterestCountArgs>(
      args?: Subset<T, ProfileInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileInterestAggregateArgs>(args: Subset<T, ProfileInterestAggregateArgs>): Prisma.PrismaPromise<GetProfileInterestAggregateType<T>>

    /**
     * Group by ProfileInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileInterestGroupByArgs['orderBy'] }
        : { orderBy?: ProfileInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileInterest model
   */
  readonly fields: ProfileInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interest<T extends InterestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterestDefaultArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileInterest model
   */
  interface ProfileInterestFieldRefs {
    readonly userId: FieldRef<"ProfileInterest", 'String'>
    readonly interestId: FieldRef<"ProfileInterest", 'String'>
    readonly createdAt: FieldRef<"ProfileInterest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileInterest findUnique
   */
  export type ProfileInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterest to fetch.
     */
    where: ProfileInterestWhereUniqueInput
  }

  /**
   * ProfileInterest findUniqueOrThrow
   */
  export type ProfileInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterest to fetch.
     */
    where: ProfileInterestWhereUniqueInput
  }

  /**
   * ProfileInterest findFirst
   */
  export type ProfileInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterest to fetch.
     */
    where?: ProfileInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileInterests to fetch.
     */
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileInterests.
     */
    cursor?: ProfileInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileInterests.
     */
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * ProfileInterest findFirstOrThrow
   */
  export type ProfileInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterest to fetch.
     */
    where?: ProfileInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileInterests to fetch.
     */
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileInterests.
     */
    cursor?: ProfileInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileInterests.
     */
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * ProfileInterest findMany
   */
  export type ProfileInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterests to fetch.
     */
    where?: ProfileInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileInterests to fetch.
     */
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileInterests.
     */
    cursor?: ProfileInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileInterests.
     */
    skip?: number
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * ProfileInterest create
   */
  export type ProfileInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileInterest.
     */
    data: XOR<ProfileInterestCreateInput, ProfileInterestUncheckedCreateInput>
  }

  /**
   * ProfileInterest createMany
   */
  export type ProfileInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileInterests.
     */
    data: ProfileInterestCreateManyInput | ProfileInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileInterest createManyAndReturn
   */
  export type ProfileInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * The data used to create many ProfileInterests.
     */
    data: ProfileInterestCreateManyInput | ProfileInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileInterest update
   */
  export type ProfileInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileInterest.
     */
    data: XOR<ProfileInterestUpdateInput, ProfileInterestUncheckedUpdateInput>
    /**
     * Choose, which ProfileInterest to update.
     */
    where: ProfileInterestWhereUniqueInput
  }

  /**
   * ProfileInterest updateMany
   */
  export type ProfileInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileInterests.
     */
    data: XOR<ProfileInterestUpdateManyMutationInput, ProfileInterestUncheckedUpdateManyInput>
    /**
     * Filter which ProfileInterests to update
     */
    where?: ProfileInterestWhereInput
    /**
     * Limit how many ProfileInterests to update.
     */
    limit?: number
  }

  /**
   * ProfileInterest updateManyAndReturn
   */
  export type ProfileInterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * The data used to update ProfileInterests.
     */
    data: XOR<ProfileInterestUpdateManyMutationInput, ProfileInterestUncheckedUpdateManyInput>
    /**
     * Filter which ProfileInterests to update
     */
    where?: ProfileInterestWhereInput
    /**
     * Limit how many ProfileInterests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileInterest upsert
   */
  export type ProfileInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileInterest to update in case it exists.
     */
    where: ProfileInterestWhereUniqueInput
    /**
     * In case the ProfileInterest found by the `where` argument doesn't exist, create a new ProfileInterest with this data.
     */
    create: XOR<ProfileInterestCreateInput, ProfileInterestUncheckedCreateInput>
    /**
     * In case the ProfileInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileInterestUpdateInput, ProfileInterestUncheckedUpdateInput>
  }

  /**
   * ProfileInterest delete
   */
  export type ProfileInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter which ProfileInterest to delete.
     */
    where: ProfileInterestWhereUniqueInput
  }

  /**
   * ProfileInterest deleteMany
   */
  export type ProfileInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileInterests to delete
     */
    where?: ProfileInterestWhereInput
    /**
     * Limit how many ProfileInterests to delete.
     */
    limit?: number
  }

  /**
   * ProfileInterest without action
   */
  export type ProfileInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
  }


  /**
   * Model ProfileAppInterests
   */

  export type AggregateProfileAppInterests = {
    _count: ProfileAppInterestsCountAggregateOutputType | null
    _min: ProfileAppInterestsMinAggregateOutputType | null
    _max: ProfileAppInterestsMaxAggregateOutputType | null
  }

  export type ProfileAppInterestsMinAggregateOutputType = {
    userId: string | null
    interestId: string | null
    createdAt: Date | null
  }

  export type ProfileAppInterestsMaxAggregateOutputType = {
    userId: string | null
    interestId: string | null
    createdAt: Date | null
  }

  export type ProfileAppInterestsCountAggregateOutputType = {
    userId: number
    interestId: number
    createdAt: number
    _all: number
  }


  export type ProfileAppInterestsMinAggregateInputType = {
    userId?: true
    interestId?: true
    createdAt?: true
  }

  export type ProfileAppInterestsMaxAggregateInputType = {
    userId?: true
    interestId?: true
    createdAt?: true
  }

  export type ProfileAppInterestsCountAggregateInputType = {
    userId?: true
    interestId?: true
    createdAt?: true
    _all?: true
  }

  export type ProfileAppInterestsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileAppInterests to aggregate.
     */
    where?: ProfileAppInterestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileAppInterests to fetch.
     */
    orderBy?: ProfileAppInterestsOrderByWithRelationInput | ProfileAppInterestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileAppInterestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileAppInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileAppInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileAppInterests
    **/
    _count?: true | ProfileAppInterestsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileAppInterestsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileAppInterestsMaxAggregateInputType
  }

  export type GetProfileAppInterestsAggregateType<T extends ProfileAppInterestsAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileAppInterests]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileAppInterests[P]>
      : GetScalarType<T[P], AggregateProfileAppInterests[P]>
  }




  export type ProfileAppInterestsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileAppInterestsWhereInput
    orderBy?: ProfileAppInterestsOrderByWithAggregationInput | ProfileAppInterestsOrderByWithAggregationInput[]
    by: ProfileAppInterestsScalarFieldEnum[] | ProfileAppInterestsScalarFieldEnum
    having?: ProfileAppInterestsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileAppInterestsCountAggregateInputType | true
    _min?: ProfileAppInterestsMinAggregateInputType
    _max?: ProfileAppInterestsMaxAggregateInputType
  }

  export type ProfileAppInterestsGroupByOutputType = {
    userId: string
    interestId: string
    createdAt: Date
    _count: ProfileAppInterestsCountAggregateOutputType | null
    _min: ProfileAppInterestsMinAggregateOutputType | null
    _max: ProfileAppInterestsMaxAggregateOutputType | null
  }

  type GetProfileAppInterestsGroupByPayload<T extends ProfileAppInterestsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileAppInterestsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileAppInterestsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileAppInterestsGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileAppInterestsGroupByOutputType[P]>
        }
      >
    >


  export type ProfileAppInterestsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
    interest?: boolean | AppInterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileAppInterests"]>

  export type ProfileAppInterestsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
    interest?: boolean | AppInterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileAppInterests"]>

  export type ProfileAppInterestsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
    interest?: boolean | AppInterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileAppInterests"]>

  export type ProfileAppInterestsSelectScalar = {
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
  }

  export type ProfileAppInterestsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "interestId" | "createdAt", ExtArgs["result"]["profileAppInterests"]>
  export type ProfileAppInterestsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interest?: boolean | AppInterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileAppInterestsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interest?: boolean | AppInterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileAppInterestsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interest?: boolean | AppInterestDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfileAppInterestsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileAppInterests"
    objects: {
      interest: Prisma.$AppInterestPayload<ExtArgs>
      user: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      interestId: string
      createdAt: Date
    }, ExtArgs["result"]["profileAppInterests"]>
    composites: {}
  }

  type ProfileAppInterestsGetPayload<S extends boolean | null | undefined | ProfileAppInterestsDefaultArgs> = $Result.GetResult<Prisma.$ProfileAppInterestsPayload, S>

  type ProfileAppInterestsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileAppInterestsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileAppInterestsCountAggregateInputType | true
    }

  export interface ProfileAppInterestsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileAppInterests'], meta: { name: 'ProfileAppInterests' } }
    /**
     * Find zero or one ProfileAppInterests that matches the filter.
     * @param {ProfileAppInterestsFindUniqueArgs} args - Arguments to find a ProfileAppInterests
     * @example
     * // Get one ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileAppInterestsFindUniqueArgs>(args: SelectSubset<T, ProfileAppInterestsFindUniqueArgs<ExtArgs>>): Prisma__ProfileAppInterestsClient<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileAppInterests that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileAppInterestsFindUniqueOrThrowArgs} args - Arguments to find a ProfileAppInterests
     * @example
     * // Get one ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileAppInterestsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileAppInterestsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileAppInterestsClient<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileAppInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAppInterestsFindFirstArgs} args - Arguments to find a ProfileAppInterests
     * @example
     * // Get one ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileAppInterestsFindFirstArgs>(args?: SelectSubset<T, ProfileAppInterestsFindFirstArgs<ExtArgs>>): Prisma__ProfileAppInterestsClient<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileAppInterests that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAppInterestsFindFirstOrThrowArgs} args - Arguments to find a ProfileAppInterests
     * @example
     * // Get one ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileAppInterestsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileAppInterestsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileAppInterestsClient<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileAppInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAppInterestsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.findMany()
     * 
     * // Get first 10 ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const profileAppInterestsWithUserIdOnly = await prisma.profileAppInterests.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ProfileAppInterestsFindManyArgs>(args?: SelectSubset<T, ProfileAppInterestsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileAppInterests.
     * @param {ProfileAppInterestsCreateArgs} args - Arguments to create a ProfileAppInterests.
     * @example
     * // Create one ProfileAppInterests
     * const ProfileAppInterests = await prisma.profileAppInterests.create({
     *   data: {
     *     // ... data to create a ProfileAppInterests
     *   }
     * })
     * 
     */
    create<T extends ProfileAppInterestsCreateArgs>(args: SelectSubset<T, ProfileAppInterestsCreateArgs<ExtArgs>>): Prisma__ProfileAppInterestsClient<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileAppInterests.
     * @param {ProfileAppInterestsCreateManyArgs} args - Arguments to create many ProfileAppInterests.
     * @example
     * // Create many ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileAppInterestsCreateManyArgs>(args?: SelectSubset<T, ProfileAppInterestsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileAppInterests and returns the data saved in the database.
     * @param {ProfileAppInterestsCreateManyAndReturnArgs} args - Arguments to create many ProfileAppInterests.
     * @example
     * // Create many ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileAppInterests and only return the `userId`
     * const profileAppInterestsWithUserIdOnly = await prisma.profileAppInterests.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileAppInterestsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileAppInterestsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfileAppInterests.
     * @param {ProfileAppInterestsDeleteArgs} args - Arguments to delete one ProfileAppInterests.
     * @example
     * // Delete one ProfileAppInterests
     * const ProfileAppInterests = await prisma.profileAppInterests.delete({
     *   where: {
     *     // ... filter to delete one ProfileAppInterests
     *   }
     * })
     * 
     */
    delete<T extends ProfileAppInterestsDeleteArgs>(args: SelectSubset<T, ProfileAppInterestsDeleteArgs<ExtArgs>>): Prisma__ProfileAppInterestsClient<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileAppInterests.
     * @param {ProfileAppInterestsUpdateArgs} args - Arguments to update one ProfileAppInterests.
     * @example
     * // Update one ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileAppInterestsUpdateArgs>(args: SelectSubset<T, ProfileAppInterestsUpdateArgs<ExtArgs>>): Prisma__ProfileAppInterestsClient<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileAppInterests.
     * @param {ProfileAppInterestsDeleteManyArgs} args - Arguments to filter ProfileAppInterests to delete.
     * @example
     * // Delete a few ProfileAppInterests
     * const { count } = await prisma.profileAppInterests.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileAppInterestsDeleteManyArgs>(args?: SelectSubset<T, ProfileAppInterestsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileAppInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAppInterestsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileAppInterestsUpdateManyArgs>(args: SelectSubset<T, ProfileAppInterestsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileAppInterests and returns the data updated in the database.
     * @param {ProfileAppInterestsUpdateManyAndReturnArgs} args - Arguments to update many ProfileAppInterests.
     * @example
     * // Update many ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfileAppInterests and only return the `userId`
     * const profileAppInterestsWithUserIdOnly = await prisma.profileAppInterests.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileAppInterestsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileAppInterestsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfileAppInterests.
     * @param {ProfileAppInterestsUpsertArgs} args - Arguments to update or create a ProfileAppInterests.
     * @example
     * // Update or create a ProfileAppInterests
     * const profileAppInterests = await prisma.profileAppInterests.upsert({
     *   create: {
     *     // ... data to create a ProfileAppInterests
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileAppInterests we want to update
     *   }
     * })
     */
    upsert<T extends ProfileAppInterestsUpsertArgs>(args: SelectSubset<T, ProfileAppInterestsUpsertArgs<ExtArgs>>): Prisma__ProfileAppInterestsClient<$Result.GetResult<Prisma.$ProfileAppInterestsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileAppInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAppInterestsCountArgs} args - Arguments to filter ProfileAppInterests to count.
     * @example
     * // Count the number of ProfileAppInterests
     * const count = await prisma.profileAppInterests.count({
     *   where: {
     *     // ... the filter for the ProfileAppInterests we want to count
     *   }
     * })
    **/
    count<T extends ProfileAppInterestsCountArgs>(
      args?: Subset<T, ProfileAppInterestsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileAppInterestsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileAppInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAppInterestsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAppInterestsAggregateArgs>(args: Subset<T, ProfileAppInterestsAggregateArgs>): Prisma.PrismaPromise<GetProfileAppInterestsAggregateType<T>>

    /**
     * Group by ProfileAppInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAppInterestsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileAppInterestsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileAppInterestsGroupByArgs['orderBy'] }
        : { orderBy?: ProfileAppInterestsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileAppInterestsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileAppInterestsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileAppInterests model
   */
  readonly fields: ProfileAppInterestsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileAppInterests.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileAppInterestsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interest<T extends AppInterestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppInterestDefaultArgs<ExtArgs>>): Prisma__AppInterestClient<$Result.GetResult<Prisma.$AppInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileAppInterests model
   */
  interface ProfileAppInterestsFieldRefs {
    readonly userId: FieldRef<"ProfileAppInterests", 'String'>
    readonly interestId: FieldRef<"ProfileAppInterests", 'String'>
    readonly createdAt: FieldRef<"ProfileAppInterests", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileAppInterests findUnique
   */
  export type ProfileAppInterestsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileAppInterests to fetch.
     */
    where: ProfileAppInterestsWhereUniqueInput
  }

  /**
   * ProfileAppInterests findUniqueOrThrow
   */
  export type ProfileAppInterestsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileAppInterests to fetch.
     */
    where: ProfileAppInterestsWhereUniqueInput
  }

  /**
   * ProfileAppInterests findFirst
   */
  export type ProfileAppInterestsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileAppInterests to fetch.
     */
    where?: ProfileAppInterestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileAppInterests to fetch.
     */
    orderBy?: ProfileAppInterestsOrderByWithRelationInput | ProfileAppInterestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileAppInterests.
     */
    cursor?: ProfileAppInterestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileAppInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileAppInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileAppInterests.
     */
    distinct?: ProfileAppInterestsScalarFieldEnum | ProfileAppInterestsScalarFieldEnum[]
  }

  /**
   * ProfileAppInterests findFirstOrThrow
   */
  export type ProfileAppInterestsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileAppInterests to fetch.
     */
    where?: ProfileAppInterestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileAppInterests to fetch.
     */
    orderBy?: ProfileAppInterestsOrderByWithRelationInput | ProfileAppInterestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileAppInterests.
     */
    cursor?: ProfileAppInterestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileAppInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileAppInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileAppInterests.
     */
    distinct?: ProfileAppInterestsScalarFieldEnum | ProfileAppInterestsScalarFieldEnum[]
  }

  /**
   * ProfileAppInterests findMany
   */
  export type ProfileAppInterestsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileAppInterests to fetch.
     */
    where?: ProfileAppInterestsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileAppInterests to fetch.
     */
    orderBy?: ProfileAppInterestsOrderByWithRelationInput | ProfileAppInterestsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileAppInterests.
     */
    cursor?: ProfileAppInterestsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileAppInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileAppInterests.
     */
    skip?: number
    distinct?: ProfileAppInterestsScalarFieldEnum | ProfileAppInterestsScalarFieldEnum[]
  }

  /**
   * ProfileAppInterests create
   */
  export type ProfileAppInterestsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileAppInterests.
     */
    data: XOR<ProfileAppInterestsCreateInput, ProfileAppInterestsUncheckedCreateInput>
  }

  /**
   * ProfileAppInterests createMany
   */
  export type ProfileAppInterestsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileAppInterests.
     */
    data: ProfileAppInterestsCreateManyInput | ProfileAppInterestsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileAppInterests createManyAndReturn
   */
  export type ProfileAppInterestsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * The data used to create many ProfileAppInterests.
     */
    data: ProfileAppInterestsCreateManyInput | ProfileAppInterestsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileAppInterests update
   */
  export type ProfileAppInterestsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileAppInterests.
     */
    data: XOR<ProfileAppInterestsUpdateInput, ProfileAppInterestsUncheckedUpdateInput>
    /**
     * Choose, which ProfileAppInterests to update.
     */
    where: ProfileAppInterestsWhereUniqueInput
  }

  /**
   * ProfileAppInterests updateMany
   */
  export type ProfileAppInterestsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileAppInterests.
     */
    data: XOR<ProfileAppInterestsUpdateManyMutationInput, ProfileAppInterestsUncheckedUpdateManyInput>
    /**
     * Filter which ProfileAppInterests to update
     */
    where?: ProfileAppInterestsWhereInput
    /**
     * Limit how many ProfileAppInterests to update.
     */
    limit?: number
  }

  /**
   * ProfileAppInterests updateManyAndReturn
   */
  export type ProfileAppInterestsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * The data used to update ProfileAppInterests.
     */
    data: XOR<ProfileAppInterestsUpdateManyMutationInput, ProfileAppInterestsUncheckedUpdateManyInput>
    /**
     * Filter which ProfileAppInterests to update
     */
    where?: ProfileAppInterestsWhereInput
    /**
     * Limit how many ProfileAppInterests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileAppInterests upsert
   */
  export type ProfileAppInterestsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileAppInterests to update in case it exists.
     */
    where: ProfileAppInterestsWhereUniqueInput
    /**
     * In case the ProfileAppInterests found by the `where` argument doesn't exist, create a new ProfileAppInterests with this data.
     */
    create: XOR<ProfileAppInterestsCreateInput, ProfileAppInterestsUncheckedCreateInput>
    /**
     * In case the ProfileAppInterests was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileAppInterestsUpdateInput, ProfileAppInterestsUncheckedUpdateInput>
  }

  /**
   * ProfileAppInterests delete
   */
  export type ProfileAppInterestsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
    /**
     * Filter which ProfileAppInterests to delete.
     */
    where: ProfileAppInterestsWhereUniqueInput
  }

  /**
   * ProfileAppInterests deleteMany
   */
  export type ProfileAppInterestsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileAppInterests to delete
     */
    where?: ProfileAppInterestsWhereInput
    /**
     * Limit how many ProfileAppInterests to delete.
     */
    limit?: number
  }

  /**
   * ProfileAppInterests without action
   */
  export type ProfileAppInterestsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileAppInterests
     */
    select?: ProfileAppInterestsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileAppInterests
     */
    omit?: ProfileAppInterestsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileAppInterestsInclude<ExtArgs> | null
  }


  /**
   * Model MessageRead
   */

  export type AggregateMessageRead = {
    _count: MessageReadCountAggregateOutputType | null
    _min: MessageReadMinAggregateOutputType | null
    _max: MessageReadMaxAggregateOutputType | null
  }

  export type MessageReadMinAggregateOutputType = {
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadMaxAggregateOutputType = {
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadCountAggregateOutputType = {
    messageId: number
    userId: number
    readAt: number
    _all: number
  }


  export type MessageReadMinAggregateInputType = {
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadMaxAggregateInputType = {
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadCountAggregateInputType = {
    messageId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type MessageReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRead to aggregate.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageReads
    **/
    _count?: true | MessageReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageReadMaxAggregateInputType
  }

  export type GetMessageReadAggregateType<T extends MessageReadAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageRead[P]>
      : GetScalarType<T[P], AggregateMessageRead[P]>
  }




  export type MessageReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithAggregationInput | MessageReadOrderByWithAggregationInput[]
    by: MessageReadScalarFieldEnum[] | MessageReadScalarFieldEnum
    having?: MessageReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageReadCountAggregateInputType | true
    _min?: MessageReadMinAggregateInputType
    _max?: MessageReadMaxAggregateInputType
  }

  export type MessageReadGroupByOutputType = {
    messageId: string
    userId: string
    readAt: Date
    _count: MessageReadCountAggregateOutputType | null
    _min: MessageReadMinAggregateOutputType | null
    _max: MessageReadMaxAggregateOutputType | null
  }

  type GetMessageReadGroupByPayload<T extends MessageReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageReadGroupByOutputType[P]>
            : GetScalarType<T[P], MessageReadGroupByOutputType[P]>
        }
      >
    >


  export type MessageReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectScalar = {
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type MessageReadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"messageId" | "userId" | "readAt", ExtArgs["result"]["messageRead"]>
  export type MessageReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MessageReadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MessageReadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $MessageReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageRead"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      messageId: string
      userId: string
      readAt: Date
    }, ExtArgs["result"]["messageRead"]>
    composites: {}
  }

  type MessageReadGetPayload<S extends boolean | null | undefined | MessageReadDefaultArgs> = $Result.GetResult<Prisma.$MessageReadPayload, S>

  type MessageReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageReadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageReadCountAggregateInputType | true
    }

  export interface MessageReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageRead'], meta: { name: 'MessageRead' } }
    /**
     * Find zero or one MessageRead that matches the filter.
     * @param {MessageReadFindUniqueArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageReadFindUniqueArgs>(args: SelectSubset<T, MessageReadFindUniqueArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageRead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageReadFindUniqueOrThrowArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageReadFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageReadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindFirstArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageReadFindFirstArgs>(args?: SelectSubset<T, MessageReadFindFirstArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindFirstOrThrowArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageReadFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageReadFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageReads
     * const messageReads = await prisma.messageRead.findMany()
     * 
     * // Get first 10 MessageReads
     * const messageReads = await prisma.messageRead.findMany({ take: 10 })
     * 
     * // Only select the `messageId`
     * const messageReadWithMessageIdOnly = await prisma.messageRead.findMany({ select: { messageId: true } })
     * 
     */
    findMany<T extends MessageReadFindManyArgs>(args?: SelectSubset<T, MessageReadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageRead.
     * @param {MessageReadCreateArgs} args - Arguments to create a MessageRead.
     * @example
     * // Create one MessageRead
     * const MessageRead = await prisma.messageRead.create({
     *   data: {
     *     // ... data to create a MessageRead
     *   }
     * })
     * 
     */
    create<T extends MessageReadCreateArgs>(args: SelectSubset<T, MessageReadCreateArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageReads.
     * @param {MessageReadCreateManyArgs} args - Arguments to create many MessageReads.
     * @example
     * // Create many MessageReads
     * const messageRead = await prisma.messageRead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageReadCreateManyArgs>(args?: SelectSubset<T, MessageReadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageReads and returns the data saved in the database.
     * @param {MessageReadCreateManyAndReturnArgs} args - Arguments to create many MessageReads.
     * @example
     * // Create many MessageReads
     * const messageRead = await prisma.messageRead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageReads and only return the `messageId`
     * const messageReadWithMessageIdOnly = await prisma.messageRead.createManyAndReturn({
     *   select: { messageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageReadCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageReadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageRead.
     * @param {MessageReadDeleteArgs} args - Arguments to delete one MessageRead.
     * @example
     * // Delete one MessageRead
     * const MessageRead = await prisma.messageRead.delete({
     *   where: {
     *     // ... filter to delete one MessageRead
     *   }
     * })
     * 
     */
    delete<T extends MessageReadDeleteArgs>(args: SelectSubset<T, MessageReadDeleteArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageRead.
     * @param {MessageReadUpdateArgs} args - Arguments to update one MessageRead.
     * @example
     * // Update one MessageRead
     * const messageRead = await prisma.messageRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageReadUpdateArgs>(args: SelectSubset<T, MessageReadUpdateArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageReads.
     * @param {MessageReadDeleteManyArgs} args - Arguments to filter MessageReads to delete.
     * @example
     * // Delete a few MessageReads
     * const { count } = await prisma.messageRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageReadDeleteManyArgs>(args?: SelectSubset<T, MessageReadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageReads
     * const messageRead = await prisma.messageRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageReadUpdateManyArgs>(args: SelectSubset<T, MessageReadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReads and returns the data updated in the database.
     * @param {MessageReadUpdateManyAndReturnArgs} args - Arguments to update many MessageReads.
     * @example
     * // Update many MessageReads
     * const messageRead = await prisma.messageRead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageReads and only return the `messageId`
     * const messageReadWithMessageIdOnly = await prisma.messageRead.updateManyAndReturn({
     *   select: { messageId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageReadUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageReadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageRead.
     * @param {MessageReadUpsertArgs} args - Arguments to update or create a MessageRead.
     * @example
     * // Update or create a MessageRead
     * const messageRead = await prisma.messageRead.upsert({
     *   create: {
     *     // ... data to create a MessageRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageRead we want to update
     *   }
     * })
     */
    upsert<T extends MessageReadUpsertArgs>(args: SelectSubset<T, MessageReadUpsertArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadCountArgs} args - Arguments to filter MessageReads to count.
     * @example
     * // Count the number of MessageReads
     * const count = await prisma.messageRead.count({
     *   where: {
     *     // ... the filter for the MessageReads we want to count
     *   }
     * })
    **/
    count<T extends MessageReadCountArgs>(
      args?: Subset<T, MessageReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageReadAggregateArgs>(args: Subset<T, MessageReadAggregateArgs>): Prisma.PrismaPromise<GetMessageReadAggregateType<T>>

    /**
     * Group by MessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageReadGroupByArgs['orderBy'] }
        : { orderBy?: MessageReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageRead model
   */
  readonly fields: MessageReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageRead model
   */
  interface MessageReadFieldRefs {
    readonly messageId: FieldRef<"MessageRead", 'String'>
    readonly userId: FieldRef<"MessageRead", 'String'>
    readonly readAt: FieldRef<"MessageRead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageRead findUnique
   */
  export type MessageReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead findUniqueOrThrow
   */
  export type MessageReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead findFirst
   */
  export type MessageReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReads.
     */
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead findFirstOrThrow
   */
  export type MessageReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReads.
     */
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead findMany
   */
  export type MessageReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageReads to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead create
   */
  export type MessageReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageRead.
     */
    data: XOR<MessageReadCreateInput, MessageReadUncheckedCreateInput>
  }

  /**
   * MessageRead createMany
   */
  export type MessageReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageReads.
     */
    data: MessageReadCreateManyInput | MessageReadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageRead createManyAndReturn
   */
  export type MessageReadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * The data used to create many MessageReads.
     */
    data: MessageReadCreateManyInput | MessageReadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRead update
   */
  export type MessageReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageRead.
     */
    data: XOR<MessageReadUpdateInput, MessageReadUncheckedUpdateInput>
    /**
     * Choose, which MessageRead to update.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead updateMany
   */
  export type MessageReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageReads.
     */
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyInput>
    /**
     * Filter which MessageReads to update
     */
    where?: MessageReadWhereInput
    /**
     * Limit how many MessageReads to update.
     */
    limit?: number
  }

  /**
   * MessageRead updateManyAndReturn
   */
  export type MessageReadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * The data used to update MessageReads.
     */
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyInput>
    /**
     * Filter which MessageReads to update
     */
    where?: MessageReadWhereInput
    /**
     * Limit how many MessageReads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRead upsert
   */
  export type MessageReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageRead to update in case it exists.
     */
    where: MessageReadWhereUniqueInput
    /**
     * In case the MessageRead found by the `where` argument doesn't exist, create a new MessageRead with this data.
     */
    create: XOR<MessageReadCreateInput, MessageReadUncheckedCreateInput>
    /**
     * In case the MessageRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageReadUpdateInput, MessageReadUncheckedUpdateInput>
  }

  /**
   * MessageRead delete
   */
  export type MessageReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter which MessageRead to delete.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead deleteMany
   */
  export type MessageReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReads to delete
     */
    where?: MessageReadWhereInput
    /**
     * Limit how many MessageReads to delete.
     */
    limit?: number
  }

  /**
   * MessageRead without action
   */
  export type MessageReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    lat: number | null
    lng: number | null
    viewCount: number | null
    saveCount: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    lat: number | null
    lng: number | null
    viewCount: number | null
    saveCount: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    sellerId: string | null
    visibility: $Enums.PostVisibility | null
    title: string | null
    price: number | null
    currency: string | null
    description: string | null
    category: string | null
    condition: $Enums.ProductCondition | null
    negotiable: boolean | null
    availability: $Enums.Available | null
    status: $Enums.ListingStatus | null
    publishedAt: Date | null
    expiresAt: Date | null
    deletedAt: Date | null
    country: string | null
    city: string | null
    district: string | null
    locationText: string | null
    lat: number | null
    lng: number | null
    viewCount: number | null
    saveCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    sellerId: string | null
    visibility: $Enums.PostVisibility | null
    title: string | null
    price: number | null
    currency: string | null
    description: string | null
    category: string | null
    condition: $Enums.ProductCondition | null
    negotiable: boolean | null
    availability: $Enums.Available | null
    status: $Enums.ListingStatus | null
    publishedAt: Date | null
    expiresAt: Date | null
    deletedAt: Date | null
    country: string | null
    city: string | null
    district: string | null
    locationText: string | null
    lat: number | null
    lng: number | null
    viewCount: number | null
    saveCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    sellerId: number
    visibility: number
    title: number
    price: number
    currency: number
    description: number
    category: number
    condition: number
    negotiable: number
    availability: number
    status: number
    publishedAt: number
    expiresAt: number
    deletedAt: number
    country: number
    city: number
    district: number
    locationText: number
    lat: number
    lng: number
    viewCount: number
    saveCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    lat?: true
    lng?: true
    viewCount?: true
    saveCount?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    lat?: true
    lng?: true
    viewCount?: true
    saveCount?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    sellerId?: true
    visibility?: true
    title?: true
    price?: true
    currency?: true
    description?: true
    category?: true
    condition?: true
    negotiable?: true
    availability?: true
    status?: true
    publishedAt?: true
    expiresAt?: true
    deletedAt?: true
    country?: true
    city?: true
    district?: true
    locationText?: true
    lat?: true
    lng?: true
    viewCount?: true
    saveCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    sellerId?: true
    visibility?: true
    title?: true
    price?: true
    currency?: true
    description?: true
    category?: true
    condition?: true
    negotiable?: true
    availability?: true
    status?: true
    publishedAt?: true
    expiresAt?: true
    deletedAt?: true
    country?: true
    city?: true
    district?: true
    locationText?: true
    lat?: true
    lng?: true
    viewCount?: true
    saveCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    sellerId?: true
    visibility?: true
    title?: true
    price?: true
    currency?: true
    description?: true
    category?: true
    condition?: true
    negotiable?: true
    availability?: true
    status?: true
    publishedAt?: true
    expiresAt?: true
    deletedAt?: true
    country?: true
    city?: true
    district?: true
    locationText?: true
    lat?: true
    lng?: true
    viewCount?: true
    saveCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    sellerId: string
    visibility: $Enums.PostVisibility
    title: string
    price: number
    currency: string
    description: string
    category: string
    condition: $Enums.ProductCondition
    negotiable: boolean
    availability: $Enums.Available
    status: $Enums.ListingStatus
    publishedAt: Date | null
    expiresAt: Date | null
    deletedAt: Date | null
    country: string | null
    city: string | null
    district: string | null
    locationText: string | null
    lat: number | null
    lng: number | null
    viewCount: number
    saveCount: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    visibility?: boolean
    title?: boolean
    price?: boolean
    currency?: boolean
    description?: boolean
    category?: boolean
    condition?: boolean
    negotiable?: boolean
    availability?: boolean
    status?: boolean
    publishedAt?: boolean
    expiresAt?: boolean
    deletedAt?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    locationText?: boolean
    lat?: boolean
    lng?: boolean
    viewCount?: boolean
    saveCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | ProfileDefaultArgs<ExtArgs>
    media?: boolean | Product$mediaArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    visibility?: boolean
    title?: boolean
    price?: boolean
    currency?: boolean
    description?: boolean
    category?: boolean
    condition?: boolean
    negotiable?: boolean
    availability?: boolean
    status?: boolean
    publishedAt?: boolean
    expiresAt?: boolean
    deletedAt?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    locationText?: boolean
    lat?: boolean
    lng?: boolean
    viewCount?: boolean
    saveCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sellerId?: boolean
    visibility?: boolean
    title?: boolean
    price?: boolean
    currency?: boolean
    description?: boolean
    category?: boolean
    condition?: boolean
    negotiable?: boolean
    availability?: boolean
    status?: boolean
    publishedAt?: boolean
    expiresAt?: boolean
    deletedAt?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    locationText?: boolean
    lat?: boolean
    lng?: boolean
    viewCount?: boolean
    saveCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    seller?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    sellerId?: boolean
    visibility?: boolean
    title?: boolean
    price?: boolean
    currency?: boolean
    description?: boolean
    category?: boolean
    condition?: boolean
    negotiable?: boolean
    availability?: boolean
    status?: boolean
    publishedAt?: boolean
    expiresAt?: boolean
    deletedAt?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    locationText?: boolean
    lat?: boolean
    lng?: boolean
    viewCount?: boolean
    saveCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sellerId" | "visibility" | "title" | "price" | "currency" | "description" | "category" | "condition" | "negotiable" | "availability" | "status" | "publishedAt" | "expiresAt" | "deletedAt" | "country" | "city" | "district" | "locationText" | "lat" | "lng" | "viewCount" | "saveCount" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | ProfileDefaultArgs<ExtArgs>
    media?: boolean | Product$mediaArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    seller?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      seller: Prisma.$ProfilePayload<ExtArgs>
      media: Prisma.$ProductMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sellerId: string
      visibility: $Enums.PostVisibility
      title: string
      price: number
      currency: string
      description: string
      category: string
      condition: $Enums.ProductCondition
      negotiable: boolean
      availability: $Enums.Available
      status: $Enums.ListingStatus
      publishedAt: Date | null
      expiresAt: Date | null
      deletedAt: Date | null
      country: string | null
      city: string | null
      district: string | null
      locationText: string | null
      lat: number | null
      lng: number | null
      viewCount: number
      saveCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    seller<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends Product$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Product$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly sellerId: FieldRef<"Product", 'String'>
    readonly visibility: FieldRef<"Product", 'PostVisibility'>
    readonly title: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Int'>
    readonly currency: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'String'>
    readonly condition: FieldRef<"Product", 'ProductCondition'>
    readonly negotiable: FieldRef<"Product", 'Boolean'>
    readonly availability: FieldRef<"Product", 'Available'>
    readonly status: FieldRef<"Product", 'ListingStatus'>
    readonly publishedAt: FieldRef<"Product", 'DateTime'>
    readonly expiresAt: FieldRef<"Product", 'DateTime'>
    readonly deletedAt: FieldRef<"Product", 'DateTime'>
    readonly country: FieldRef<"Product", 'String'>
    readonly city: FieldRef<"Product", 'String'>
    readonly district: FieldRef<"Product", 'String'>
    readonly locationText: FieldRef<"Product", 'String'>
    readonly lat: FieldRef<"Product", 'Float'>
    readonly lng: FieldRef<"Product", 'Float'>
    readonly viewCount: FieldRef<"Product", 'Int'>
    readonly saveCount: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.media
   */
  export type Product$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    where?: ProductMediaWhereInput
    orderBy?: ProductMediaOrderByWithRelationInput | ProductMediaOrderByWithRelationInput[]
    cursor?: ProductMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductMediaScalarFieldEnum | ProductMediaScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductMedia
   */

  export type AggregateProductMedia = {
    _count: ProductMediaCountAggregateOutputType | null
    _avg: ProductMediaAvgAggregateOutputType | null
    _sum: ProductMediaSumAggregateOutputType | null
    _min: ProductMediaMinAggregateOutputType | null
    _max: ProductMediaMaxAggregateOutputType | null
  }

  export type ProductMediaAvgAggregateOutputType = {
    width: number | null
    height: number | null
    sizeBytes: number | null
    orderIndex: number | null
  }

  export type ProductMediaSumAggregateOutputType = {
    width: number | null
    height: number | null
    sizeBytes: number | null
    orderIndex: number | null
  }

  export type ProductMediaMinAggregateOutputType = {
    id: string | null
    productId: string | null
    url: string | null
    mimeType: string | null
    width: number | null
    height: number | null
    sizeBytes: number | null
    orderIndex: number | null
    isCover: boolean | null
    createdAt: Date | null
  }

  export type ProductMediaMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    url: string | null
    mimeType: string | null
    width: number | null
    height: number | null
    sizeBytes: number | null
    orderIndex: number | null
    isCover: boolean | null
    createdAt: Date | null
  }

  export type ProductMediaCountAggregateOutputType = {
    id: number
    productId: number
    url: number
    mimeType: number
    width: number
    height: number
    sizeBytes: number
    orderIndex: number
    isCover: number
    createdAt: number
    _all: number
  }


  export type ProductMediaAvgAggregateInputType = {
    width?: true
    height?: true
    sizeBytes?: true
    orderIndex?: true
  }

  export type ProductMediaSumAggregateInputType = {
    width?: true
    height?: true
    sizeBytes?: true
    orderIndex?: true
  }

  export type ProductMediaMinAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    mimeType?: true
    width?: true
    height?: true
    sizeBytes?: true
    orderIndex?: true
    isCover?: true
    createdAt?: true
  }

  export type ProductMediaMaxAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    mimeType?: true
    width?: true
    height?: true
    sizeBytes?: true
    orderIndex?: true
    isCover?: true
    createdAt?: true
  }

  export type ProductMediaCountAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    mimeType?: true
    width?: true
    height?: true
    sizeBytes?: true
    orderIndex?: true
    isCover?: true
    createdAt?: true
    _all?: true
  }

  export type ProductMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductMedia to aggregate.
     */
    where?: ProductMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMedias to fetch.
     */
    orderBy?: ProductMediaOrderByWithRelationInput | ProductMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductMedias
    **/
    _count?: true | ProductMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMediaMaxAggregateInputType
  }

  export type GetProductMediaAggregateType<T extends ProductMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateProductMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductMedia[P]>
      : GetScalarType<T[P], AggregateProductMedia[P]>
  }




  export type ProductMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductMediaWhereInput
    orderBy?: ProductMediaOrderByWithAggregationInput | ProductMediaOrderByWithAggregationInput[]
    by: ProductMediaScalarFieldEnum[] | ProductMediaScalarFieldEnum
    having?: ProductMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductMediaCountAggregateInputType | true
    _avg?: ProductMediaAvgAggregateInputType
    _sum?: ProductMediaSumAggregateInputType
    _min?: ProductMediaMinAggregateInputType
    _max?: ProductMediaMaxAggregateInputType
  }

  export type ProductMediaGroupByOutputType = {
    id: string
    productId: string
    url: string
    mimeType: string
    width: number | null
    height: number | null
    sizeBytes: number
    orderIndex: number
    isCover: boolean
    createdAt: Date
    _count: ProductMediaCountAggregateOutputType | null
    _avg: ProductMediaAvgAggregateOutputType | null
    _sum: ProductMediaSumAggregateOutputType | null
    _min: ProductMediaMinAggregateOutputType | null
    _max: ProductMediaMaxAggregateOutputType | null
  }

  type GetProductMediaGroupByPayload<T extends ProductMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductMediaGroupByOutputType[P]>
            : GetScalarType<T[P], ProductMediaGroupByOutputType[P]>
        }
      >
    >


  export type ProductMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    orderIndex?: boolean
    isCover?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productMedia"]>

  export type ProductMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    orderIndex?: boolean
    isCover?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productMedia"]>

  export type ProductMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    orderIndex?: boolean
    isCover?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productMedia"]>

  export type ProductMediaSelectScalar = {
    id?: boolean
    productId?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    orderIndex?: boolean
    isCover?: boolean
    createdAt?: boolean
  }

  export type ProductMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "url" | "mimeType" | "width" | "height" | "sizeBytes" | "orderIndex" | "isCover" | "createdAt", ExtArgs["result"]["productMedia"]>
  export type ProductMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductMedia"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      url: string
      mimeType: string
      width: number | null
      height: number | null
      sizeBytes: number
      orderIndex: number
      isCover: boolean
      createdAt: Date
    }, ExtArgs["result"]["productMedia"]>
    composites: {}
  }

  type ProductMediaGetPayload<S extends boolean | null | undefined | ProductMediaDefaultArgs> = $Result.GetResult<Prisma.$ProductMediaPayload, S>

  type ProductMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductMediaCountAggregateInputType | true
    }

  export interface ProductMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductMedia'], meta: { name: 'ProductMedia' } }
    /**
     * Find zero or one ProductMedia that matches the filter.
     * @param {ProductMediaFindUniqueArgs} args - Arguments to find a ProductMedia
     * @example
     * // Get one ProductMedia
     * const productMedia = await prisma.productMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductMediaFindUniqueArgs>(args: SelectSubset<T, ProductMediaFindUniqueArgs<ExtArgs>>): Prisma__ProductMediaClient<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductMediaFindUniqueOrThrowArgs} args - Arguments to find a ProductMedia
     * @example
     * // Get one ProductMedia
     * const productMedia = await prisma.productMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductMediaClient<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMediaFindFirstArgs} args - Arguments to find a ProductMedia
     * @example
     * // Get one ProductMedia
     * const productMedia = await prisma.productMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductMediaFindFirstArgs>(args?: SelectSubset<T, ProductMediaFindFirstArgs<ExtArgs>>): Prisma__ProductMediaClient<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMediaFindFirstOrThrowArgs} args - Arguments to find a ProductMedia
     * @example
     * // Get one ProductMedia
     * const productMedia = await prisma.productMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductMediaClient<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductMedias
     * const productMedias = await prisma.productMedia.findMany()
     * 
     * // Get first 10 ProductMedias
     * const productMedias = await prisma.productMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productMediaWithIdOnly = await prisma.productMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductMediaFindManyArgs>(args?: SelectSubset<T, ProductMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductMedia.
     * @param {ProductMediaCreateArgs} args - Arguments to create a ProductMedia.
     * @example
     * // Create one ProductMedia
     * const ProductMedia = await prisma.productMedia.create({
     *   data: {
     *     // ... data to create a ProductMedia
     *   }
     * })
     * 
     */
    create<T extends ProductMediaCreateArgs>(args: SelectSubset<T, ProductMediaCreateArgs<ExtArgs>>): Prisma__ProductMediaClient<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductMedias.
     * @param {ProductMediaCreateManyArgs} args - Arguments to create many ProductMedias.
     * @example
     * // Create many ProductMedias
     * const productMedia = await prisma.productMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductMediaCreateManyArgs>(args?: SelectSubset<T, ProductMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductMedias and returns the data saved in the database.
     * @param {ProductMediaCreateManyAndReturnArgs} args - Arguments to create many ProductMedias.
     * @example
     * // Create many ProductMedias
     * const productMedia = await prisma.productMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductMedias and only return the `id`
     * const productMediaWithIdOnly = await prisma.productMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductMedia.
     * @param {ProductMediaDeleteArgs} args - Arguments to delete one ProductMedia.
     * @example
     * // Delete one ProductMedia
     * const ProductMedia = await prisma.productMedia.delete({
     *   where: {
     *     // ... filter to delete one ProductMedia
     *   }
     * })
     * 
     */
    delete<T extends ProductMediaDeleteArgs>(args: SelectSubset<T, ProductMediaDeleteArgs<ExtArgs>>): Prisma__ProductMediaClient<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductMedia.
     * @param {ProductMediaUpdateArgs} args - Arguments to update one ProductMedia.
     * @example
     * // Update one ProductMedia
     * const productMedia = await prisma.productMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductMediaUpdateArgs>(args: SelectSubset<T, ProductMediaUpdateArgs<ExtArgs>>): Prisma__ProductMediaClient<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductMedias.
     * @param {ProductMediaDeleteManyArgs} args - Arguments to filter ProductMedias to delete.
     * @example
     * // Delete a few ProductMedias
     * const { count } = await prisma.productMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductMediaDeleteManyArgs>(args?: SelectSubset<T, ProductMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductMedias
     * const productMedia = await prisma.productMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductMediaUpdateManyArgs>(args: SelectSubset<T, ProductMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductMedias and returns the data updated in the database.
     * @param {ProductMediaUpdateManyAndReturnArgs} args - Arguments to update many ProductMedias.
     * @example
     * // Update many ProductMedias
     * const productMedia = await prisma.productMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductMedias and only return the `id`
     * const productMediaWithIdOnly = await prisma.productMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductMedia.
     * @param {ProductMediaUpsertArgs} args - Arguments to update or create a ProductMedia.
     * @example
     * // Update or create a ProductMedia
     * const productMedia = await prisma.productMedia.upsert({
     *   create: {
     *     // ... data to create a ProductMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductMedia we want to update
     *   }
     * })
     */
    upsert<T extends ProductMediaUpsertArgs>(args: SelectSubset<T, ProductMediaUpsertArgs<ExtArgs>>): Prisma__ProductMediaClient<$Result.GetResult<Prisma.$ProductMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMediaCountArgs} args - Arguments to filter ProductMedias to count.
     * @example
     * // Count the number of ProductMedias
     * const count = await prisma.productMedia.count({
     *   where: {
     *     // ... the filter for the ProductMedias we want to count
     *   }
     * })
    **/
    count<T extends ProductMediaCountArgs>(
      args?: Subset<T, ProductMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductMediaAggregateArgs>(args: Subset<T, ProductMediaAggregateArgs>): Prisma.PrismaPromise<GetProductMediaAggregateType<T>>

    /**
     * Group by ProductMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductMediaGroupByArgs['orderBy'] }
        : { orderBy?: ProductMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductMedia model
   */
  readonly fields: ProductMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductMedia model
   */
  interface ProductMediaFieldRefs {
    readonly id: FieldRef<"ProductMedia", 'String'>
    readonly productId: FieldRef<"ProductMedia", 'String'>
    readonly url: FieldRef<"ProductMedia", 'String'>
    readonly mimeType: FieldRef<"ProductMedia", 'String'>
    readonly width: FieldRef<"ProductMedia", 'Int'>
    readonly height: FieldRef<"ProductMedia", 'Int'>
    readonly sizeBytes: FieldRef<"ProductMedia", 'Int'>
    readonly orderIndex: FieldRef<"ProductMedia", 'Int'>
    readonly isCover: FieldRef<"ProductMedia", 'Boolean'>
    readonly createdAt: FieldRef<"ProductMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductMedia findUnique
   */
  export type ProductMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMedia to fetch.
     */
    where: ProductMediaWhereUniqueInput
  }

  /**
   * ProductMedia findUniqueOrThrow
   */
  export type ProductMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMedia to fetch.
     */
    where: ProductMediaWhereUniqueInput
  }

  /**
   * ProductMedia findFirst
   */
  export type ProductMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMedia to fetch.
     */
    where?: ProductMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMedias to fetch.
     */
    orderBy?: ProductMediaOrderByWithRelationInput | ProductMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductMedias.
     */
    cursor?: ProductMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductMedias.
     */
    distinct?: ProductMediaScalarFieldEnum | ProductMediaScalarFieldEnum[]
  }

  /**
   * ProductMedia findFirstOrThrow
   */
  export type ProductMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMedia to fetch.
     */
    where?: ProductMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMedias to fetch.
     */
    orderBy?: ProductMediaOrderByWithRelationInput | ProductMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductMedias.
     */
    cursor?: ProductMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductMedias.
     */
    distinct?: ProductMediaScalarFieldEnum | ProductMediaScalarFieldEnum[]
  }

  /**
   * ProductMedia findMany
   */
  export type ProductMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    /**
     * Filter, which ProductMedias to fetch.
     */
    where?: ProductMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductMedias to fetch.
     */
    orderBy?: ProductMediaOrderByWithRelationInput | ProductMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductMedias.
     */
    cursor?: ProductMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductMedias.
     */
    skip?: number
    distinct?: ProductMediaScalarFieldEnum | ProductMediaScalarFieldEnum[]
  }

  /**
   * ProductMedia create
   */
  export type ProductMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductMedia.
     */
    data: XOR<ProductMediaCreateInput, ProductMediaUncheckedCreateInput>
  }

  /**
   * ProductMedia createMany
   */
  export type ProductMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductMedias.
     */
    data: ProductMediaCreateManyInput | ProductMediaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductMedia createManyAndReturn
   */
  export type ProductMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * The data used to create many ProductMedias.
     */
    data: ProductMediaCreateManyInput | ProductMediaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductMedia update
   */
  export type ProductMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductMedia.
     */
    data: XOR<ProductMediaUpdateInput, ProductMediaUncheckedUpdateInput>
    /**
     * Choose, which ProductMedia to update.
     */
    where: ProductMediaWhereUniqueInput
  }

  /**
   * ProductMedia updateMany
   */
  export type ProductMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductMedias.
     */
    data: XOR<ProductMediaUpdateManyMutationInput, ProductMediaUncheckedUpdateManyInput>
    /**
     * Filter which ProductMedias to update
     */
    where?: ProductMediaWhereInput
    /**
     * Limit how many ProductMedias to update.
     */
    limit?: number
  }

  /**
   * ProductMedia updateManyAndReturn
   */
  export type ProductMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * The data used to update ProductMedias.
     */
    data: XOR<ProductMediaUpdateManyMutationInput, ProductMediaUncheckedUpdateManyInput>
    /**
     * Filter which ProductMedias to update
     */
    where?: ProductMediaWhereInput
    /**
     * Limit how many ProductMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductMedia upsert
   */
  export type ProductMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductMedia to update in case it exists.
     */
    where: ProductMediaWhereUniqueInput
    /**
     * In case the ProductMedia found by the `where` argument doesn't exist, create a new ProductMedia with this data.
     */
    create: XOR<ProductMediaCreateInput, ProductMediaUncheckedCreateInput>
    /**
     * In case the ProductMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductMediaUpdateInput, ProductMediaUncheckedUpdateInput>
  }

  /**
   * ProductMedia delete
   */
  export type ProductMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
    /**
     * Filter which ProductMedia to delete.
     */
    where: ProductMediaWhereUniqueInput
  }

  /**
   * ProductMedia deleteMany
   */
  export type ProductMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductMedias to delete
     */
    where?: ProductMediaWhereInput
    /**
     * Limit how many ProductMedias to delete.
     */
    limit?: number
  }

  /**
   * ProductMedia without action
   */
  export type ProductMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductMedia
     */
    select?: ProductMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductMedia
     */
    omit?: ProductMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductMediaInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    fullName: 'fullName',
    username: 'username',
    gender: 'gender',
    dateOfBirth: 'dateOfBirth',
    email: 'email',
    country: 'country',
    city: 'city',
    district: 'district',
    location: 'location',
    bio: 'bio',
    profession: 'profession',
    countryCode: 'countryCode',
    avatarUrl: 'avatarUrl',
    coverUrl: 'coverUrl',
    lineageMainSurname: 'lineageMainSurname',
    lineageRootVillage: 'lineageRootVillage',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    ethnicity: 'ethnicity',
    occupation: 'occupation',
    isProfileComplete: 'isProfileComplete'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const ProfileSettingsScalarFieldEnum: {
    profileId: 'profileId',
    isPrivate: 'isPrivate',
    showLastSeen: 'showLastSeen',
    allowTagging: 'allowTagging',
    allowMessagesFrom: 'allowMessagesFrom',
    discoveryAllowLineage: 'discoveryAllowLineage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileSettingsScalarFieldEnum = (typeof ProfileSettingsScalarFieldEnum)[keyof typeof ProfileSettingsScalarFieldEnum]


  export const FriendRequestScalarFieldEnum: {
    id: 'id',
    requesterId: 'requesterId',
    addresseeId: 'addresseeId',
    status: 'status',
    createdAt: 'createdAt',
    respondedAt: 'respondedAt'
  };

  export type FriendRequestScalarFieldEnum = (typeof FriendRequestScalarFieldEnum)[keyof typeof FriendRequestScalarFieldEnum]


  export const FriendshipScalarFieldEnum: {
    id: 'id',
    userAId: 'userAId',
    userBId: 'userBId',
    createdAt: 'createdAt'
  };

  export type FriendshipScalarFieldEnum = (typeof FriendshipScalarFieldEnum)[keyof typeof FriendshipScalarFieldEnum]


  export const ClanScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type ClanScalarFieldEnum = (typeof ClanScalarFieldEnum)[keyof typeof ClanScalarFieldEnum]


  export const ProfileClanScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    clanId: 'clanId',
    order: 'order'
  };

  export type ProfileClanScalarFieldEnum = (typeof ProfileClanScalarFieldEnum)[keyof typeof ProfileClanScalarFieldEnum]


  export const LineageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    primarySurname: 'primarySurname',
    rootVillage: 'rootVillage',
    rootRegion: 'rootRegion',
    description: 'description',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LineageScalarFieldEnum = (typeof LineageScalarFieldEnum)[keyof typeof LineageScalarFieldEnum]


  export const LineageMembershipScalarFieldEnum: {
    id: 'id',
    lineageId: 'lineageId',
    profileId: 'profileId',
    role: 'role',
    generation: 'generation',
    isPrimaryLineage: 'isPrimaryLineage',
    addedById: 'addedById',
    createdAt: 'createdAt'
  };

  export type LineageMembershipScalarFieldEnum = (typeof LineageMembershipScalarFieldEnum)[keyof typeof LineageMembershipScalarFieldEnum]


  export const KinshipScalarFieldEnum: {
    id: 'id',
    profileIdA: 'profileIdA',
    profileIdB: 'profileIdB',
    relationAtoB: 'relationAtoB',
    verified: 'verified',
    verifiedById: 'verifiedById',
    createdAt: 'createdAt'
  };

  export type KinshipScalarFieldEnum = (typeof KinshipScalarFieldEnum)[keyof typeof KinshipScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    blockerId: 'blockerId',
    blockedId: 'blockedId',
    createdAt: 'createdAt'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const MuteScalarFieldEnum: {
    id: 'id',
    muterId: 'muterId',
    mutedId: 'mutedId',
    createdAt: 'createdAt'
  };

  export type MuteScalarFieldEnum = (typeof MuteScalarFieldEnum)[keyof typeof MuteScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    content: 'content',
    visibility: 'visibility',
    locationText: 'locationText',
    lineageId: 'lineageId',
    commentCount: 'commentCount',
    likeCount: 'likeCount',
    shareCount: 'shareCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const MediaFileScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    type: 'type',
    url: 'url',
    mimeType: 'mimeType',
    width: 'width',
    height: 'height',
    sizeBytes: 'sizeBytes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaFileScalarFieldEnum = (typeof MediaFileScalarFieldEnum)[keyof typeof MediaFileScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    profileId: 'profileId',
    parentCommentId: 'parentCommentId',
    content: 'content',
    likeCount: 'likeCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const PostReactionScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    profileId: 'profileId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type PostReactionScalarFieldEnum = (typeof PostReactionScalarFieldEnum)[keyof typeof PostReactionScalarFieldEnum]


  export const CommentReactionScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    profileId: 'profileId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type CommentReactionScalarFieldEnum = (typeof CommentReactionScalarFieldEnum)[keyof typeof CommentReactionScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    isGroup: 'isGroup',
    title: 'title',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    profileId: 'profileId',
    role: 'role',
    lastReadAt: 'lastReadAt',
    joinedAt: 'joinedAt'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    mediaUrl: 'mediaUrl',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    timestamp: 'timestamp'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    recipientId: 'recipientId',
    senderId: 'senderId',
    type: 'type',
    postId: 'postId',
    commentId: 'commentId',
    requestId: 'requestId',
    lineageId: 'lineageId',
    messageId: 'messageId',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const InterestScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type InterestScalarFieldEnum = (typeof InterestScalarFieldEnum)[keyof typeof InterestScalarFieldEnum]


  export const AppInterestScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type AppInterestScalarFieldEnum = (typeof AppInterestScalarFieldEnum)[keyof typeof AppInterestScalarFieldEnum]


  export const ProfileInterestScalarFieldEnum: {
    userId: 'userId',
    interestId: 'interestId',
    createdAt: 'createdAt'
  };

  export type ProfileInterestScalarFieldEnum = (typeof ProfileInterestScalarFieldEnum)[keyof typeof ProfileInterestScalarFieldEnum]


  export const ProfileAppInterestsScalarFieldEnum: {
    userId: 'userId',
    interestId: 'interestId',
    createdAt: 'createdAt'
  };

  export type ProfileAppInterestsScalarFieldEnum = (typeof ProfileAppInterestsScalarFieldEnum)[keyof typeof ProfileAppInterestsScalarFieldEnum]


  export const MessageReadScalarFieldEnum: {
    messageId: 'messageId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type MessageReadScalarFieldEnum = (typeof MessageReadScalarFieldEnum)[keyof typeof MessageReadScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    sellerId: 'sellerId',
    visibility: 'visibility',
    title: 'title',
    price: 'price',
    currency: 'currency',
    description: 'description',
    category: 'category',
    condition: 'condition',
    negotiable: 'negotiable',
    availability: 'availability',
    status: 'status',
    publishedAt: 'publishedAt',
    expiresAt: 'expiresAt',
    deletedAt: 'deletedAt',
    country: 'country',
    city: 'city',
    district: 'district',
    locationText: 'locationText',
    lat: 'lat',
    lng: 'lng',
    viewCount: 'viewCount',
    saveCount: 'saveCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductMediaScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    url: 'url',
    mimeType: 'mimeType',
    width: 'width',
    height: 'height',
    sizeBytes: 'sizeBytes',
    orderIndex: 'orderIndex',
    isCover: 'isCover',
    createdAt: 'createdAt'
  };

  export type ProductMediaScalarFieldEnum = (typeof ProductMediaScalarFieldEnum)[keyof typeof ProductMediaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'FriendRequestStatus'
   */
  export type EnumFriendRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendRequestStatus'>
    


  /**
   * Reference to a field of type 'FriendRequestStatus[]'
   */
  export type ListEnumFriendRequestStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FriendRequestStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'LineageType'
   */
  export type EnumLineageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LineageType'>
    


  /**
   * Reference to a field of type 'LineageType[]'
   */
  export type ListEnumLineageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LineageType[]'>
    


  /**
   * Reference to a field of type 'LineageRole'
   */
  export type EnumLineageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LineageRole'>
    


  /**
   * Reference to a field of type 'LineageRole[]'
   */
  export type ListEnumLineageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LineageRole[]'>
    


  /**
   * Reference to a field of type 'KinshipType'
   */
  export type EnumKinshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KinshipType'>
    


  /**
   * Reference to a field of type 'KinshipType[]'
   */
  export type ListEnumKinshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KinshipType[]'>
    


  /**
   * Reference to a field of type 'PostVisibility'
   */
  export type EnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility'>
    


  /**
   * Reference to a field of type 'PostVisibility[]'
   */
  export type ListEnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'ReactionType'
   */
  export type EnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType'>
    


  /**
   * Reference to a field of type 'ReactionType[]'
   */
  export type ListEnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'ProductCondition'
   */
  export type EnumProductConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductCondition'>
    


  /**
   * Reference to a field of type 'ProductCondition[]'
   */
  export type ListEnumProductConditionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductCondition[]'>
    


  /**
   * Reference to a field of type 'Available'
   */
  export type EnumAvailableFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Available'>
    


  /**
   * Reference to a field of type 'Available[]'
   */
  export type ListEnumAvailableFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Available[]'>
    


  /**
   * Reference to a field of type 'ListingStatus'
   */
  export type EnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus'>
    


  /**
   * Reference to a field of type 'ListingStatus[]'
   */
  export type ListEnumListingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListingStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: UuidFilter<"Profile"> | string
    userId?: UuidFilter<"Profile"> | string
    firstName?: StringFilter<"Profile"> | string
    lastName?: StringFilter<"Profile"> | string
    fullName?: StringNullableFilter<"Profile"> | string | null
    username?: StringFilter<"Profile"> | string
    gender?: StringNullableFilter<"Profile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Profile"> | Date | string | null
    email?: StringFilter<"Profile"> | string
    country?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    district?: StringNullableFilter<"Profile"> | string | null
    location?: StringFilter<"Profile"> | string
    bio?: StringFilter<"Profile"> | string
    profession?: StringNullableFilter<"Profile"> | string | null
    countryCode?: StringNullableFilter<"Profile"> | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    coverUrl?: StringNullableFilter<"Profile"> | string | null
    lineageMainSurname?: StringNullableFilter<"Profile"> | string | null
    lineageRootVillage?: StringNullableFilter<"Profile"> | string | null
    isVerified?: BoolFilter<"Profile"> | boolean
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    ethnicity?: StringNullableFilter<"Profile"> | string | null
    occupation?: StringNullableFilter<"Profile"> | string | null
    isProfileComplete?: BoolFilter<"Profile"> | boolean
    blocksAsBlocked?: BlockListRelationFilter
    blocksAsBlocker?: BlockListRelationFilter
    comments?: CommentListRelationFilter
    commentReactions?: CommentReactionListRelationFilter
    conversationsOwned?: ConversationListRelationFilter
    conversationMembers?: ConversationParticipantListRelationFilter
    clanTree?: ProfileClanListRelationFilter
    kinshipsA?: KinshipListRelationFilter
    kinshipsB?: KinshipListRelationFilter
    lineagesCreated?: LineageListRelationFilter
    lineageMembershipsAdded?: LineageMembershipListRelationFilter
    lineageMemberships?: LineageMembershipListRelationFilter
    messages?: MessageListRelationFilter
    messageReads?: MessageReadListRelationFilter
    mutesAsMuted?: MuteListRelationFilter
    mutesAsMuter?: MuteListRelationFilter
    notificationsAsActor?: NotificationListRelationFilter
    notifications?: NotificationListRelationFilter
    posts?: PostListRelationFilter
    postReactions?: PostReactionListRelationFilter
    product?: ProductListRelationFilter
    interests?: ProfileInterestListRelationFilter
    appInterests?: ProfileAppInterestsListRelationFilter
    settings?: XOR<ProfileSettingsNullableScalarRelationFilter, ProfileSettingsWhereInput> | null
    sentFriendRequests?: FriendRequestListRelationFilter
    receivedFriendRequests?: FriendRequestListRelationFilter
    friendshipsA?: FriendshipListRelationFilter
    friendshipsB?: FriendshipListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrderInput | SortOrder
    username?: SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    email?: SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    location?: SortOrder
    bio?: SortOrder
    profession?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    lineageMainSurname?: SortOrderInput | SortOrder
    lineageRootVillage?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ethnicity?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    isProfileComplete?: SortOrder
    blocksAsBlocked?: BlockOrderByRelationAggregateInput
    blocksAsBlocker?: BlockOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    commentReactions?: CommentReactionOrderByRelationAggregateInput
    conversationsOwned?: ConversationOrderByRelationAggregateInput
    conversationMembers?: ConversationParticipantOrderByRelationAggregateInput
    clanTree?: ProfileClanOrderByRelationAggregateInput
    kinshipsA?: KinshipOrderByRelationAggregateInput
    kinshipsB?: KinshipOrderByRelationAggregateInput
    lineagesCreated?: LineageOrderByRelationAggregateInput
    lineageMembershipsAdded?: LineageMembershipOrderByRelationAggregateInput
    lineageMemberships?: LineageMembershipOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    messageReads?: MessageReadOrderByRelationAggregateInput
    mutesAsMuted?: MuteOrderByRelationAggregateInput
    mutesAsMuter?: MuteOrderByRelationAggregateInput
    notificationsAsActor?: NotificationOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    postReactions?: PostReactionOrderByRelationAggregateInput
    product?: ProductOrderByRelationAggregateInput
    interests?: ProfileInterestOrderByRelationAggregateInput
    appInterests?: ProfileAppInterestsOrderByRelationAggregateInput
    settings?: ProfileSettingsOrderByWithRelationInput
    sentFriendRequests?: FriendRequestOrderByRelationAggregateInput
    receivedFriendRequests?: FriendRequestOrderByRelationAggregateInput
    friendshipsA?: FriendshipOrderByRelationAggregateInput
    friendshipsB?: FriendshipOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    username?: string
    email?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    firstName?: StringFilter<"Profile"> | string
    lastName?: StringFilter<"Profile"> | string
    fullName?: StringNullableFilter<"Profile"> | string | null
    gender?: StringNullableFilter<"Profile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Profile"> | Date | string | null
    country?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    district?: StringNullableFilter<"Profile"> | string | null
    location?: StringFilter<"Profile"> | string
    bio?: StringFilter<"Profile"> | string
    profession?: StringNullableFilter<"Profile"> | string | null
    countryCode?: StringNullableFilter<"Profile"> | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    coverUrl?: StringNullableFilter<"Profile"> | string | null
    lineageMainSurname?: StringNullableFilter<"Profile"> | string | null
    lineageRootVillage?: StringNullableFilter<"Profile"> | string | null
    isVerified?: BoolFilter<"Profile"> | boolean
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    ethnicity?: StringNullableFilter<"Profile"> | string | null
    occupation?: StringNullableFilter<"Profile"> | string | null
    isProfileComplete?: BoolFilter<"Profile"> | boolean
    blocksAsBlocked?: BlockListRelationFilter
    blocksAsBlocker?: BlockListRelationFilter
    comments?: CommentListRelationFilter
    commentReactions?: CommentReactionListRelationFilter
    conversationsOwned?: ConversationListRelationFilter
    conversationMembers?: ConversationParticipantListRelationFilter
    clanTree?: ProfileClanListRelationFilter
    kinshipsA?: KinshipListRelationFilter
    kinshipsB?: KinshipListRelationFilter
    lineagesCreated?: LineageListRelationFilter
    lineageMembershipsAdded?: LineageMembershipListRelationFilter
    lineageMemberships?: LineageMembershipListRelationFilter
    messages?: MessageListRelationFilter
    messageReads?: MessageReadListRelationFilter
    mutesAsMuted?: MuteListRelationFilter
    mutesAsMuter?: MuteListRelationFilter
    notificationsAsActor?: NotificationListRelationFilter
    notifications?: NotificationListRelationFilter
    posts?: PostListRelationFilter
    postReactions?: PostReactionListRelationFilter
    product?: ProductListRelationFilter
    interests?: ProfileInterestListRelationFilter
    appInterests?: ProfileAppInterestsListRelationFilter
    settings?: XOR<ProfileSettingsNullableScalarRelationFilter, ProfileSettingsWhereInput> | null
    sentFriendRequests?: FriendRequestListRelationFilter
    receivedFriendRequests?: FriendRequestListRelationFilter
    friendshipsA?: FriendshipListRelationFilter
    friendshipsB?: FriendshipListRelationFilter
  }, "id" | "userId" | "username" | "email">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrderInput | SortOrder
    username?: SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    email?: SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    location?: SortOrder
    bio?: SortOrder
    profession?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    lineageMainSurname?: SortOrderInput | SortOrder
    lineageRootVillage?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ethnicity?: SortOrderInput | SortOrder
    occupation?: SortOrderInput | SortOrder
    isProfileComplete?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Profile"> | string
    userId?: UuidWithAggregatesFilter<"Profile"> | string
    firstName?: StringWithAggregatesFilter<"Profile"> | string
    lastName?: StringWithAggregatesFilter<"Profile"> | string
    fullName?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    username?: StringWithAggregatesFilter<"Profile"> | string
    gender?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    email?: StringWithAggregatesFilter<"Profile"> | string
    country?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    city?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    district?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    location?: StringWithAggregatesFilter<"Profile"> | string
    bio?: StringWithAggregatesFilter<"Profile"> | string
    profession?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    coverUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lineageMainSurname?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lineageRootVillage?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Profile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    ethnicity?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    occupation?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    isProfileComplete?: BoolWithAggregatesFilter<"Profile"> | boolean
  }

  export type ProfileSettingsWhereInput = {
    AND?: ProfileSettingsWhereInput | ProfileSettingsWhereInput[]
    OR?: ProfileSettingsWhereInput[]
    NOT?: ProfileSettingsWhereInput | ProfileSettingsWhereInput[]
    profileId?: UuidFilter<"ProfileSettings"> | string
    isPrivate?: BoolFilter<"ProfileSettings"> | boolean
    showLastSeen?: BoolFilter<"ProfileSettings"> | boolean
    allowTagging?: BoolFilter<"ProfileSettings"> | boolean
    allowMessagesFrom?: StringFilter<"ProfileSettings"> | string
    discoveryAllowLineage?: BoolFilter<"ProfileSettings"> | boolean
    createdAt?: DateTimeFilter<"ProfileSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileSettings"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ProfileSettingsOrderByWithRelationInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type ProfileSettingsWhereUniqueInput = Prisma.AtLeast<{
    profileId?: string
    AND?: ProfileSettingsWhereInput | ProfileSettingsWhereInput[]
    OR?: ProfileSettingsWhereInput[]
    NOT?: ProfileSettingsWhereInput | ProfileSettingsWhereInput[]
    isPrivate?: BoolFilter<"ProfileSettings"> | boolean
    showLastSeen?: BoolFilter<"ProfileSettings"> | boolean
    allowTagging?: BoolFilter<"ProfileSettings"> | boolean
    allowMessagesFrom?: StringFilter<"ProfileSettings"> | string
    discoveryAllowLineage?: BoolFilter<"ProfileSettings"> | boolean
    createdAt?: DateTimeFilter<"ProfileSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileSettings"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "profileId">

  export type ProfileSettingsOrderByWithAggregationInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileSettingsCountOrderByAggregateInput
    _max?: ProfileSettingsMaxOrderByAggregateInput
    _min?: ProfileSettingsMinOrderByAggregateInput
  }

  export type ProfileSettingsScalarWhereWithAggregatesInput = {
    AND?: ProfileSettingsScalarWhereWithAggregatesInput | ProfileSettingsScalarWhereWithAggregatesInput[]
    OR?: ProfileSettingsScalarWhereWithAggregatesInput[]
    NOT?: ProfileSettingsScalarWhereWithAggregatesInput | ProfileSettingsScalarWhereWithAggregatesInput[]
    profileId?: UuidWithAggregatesFilter<"ProfileSettings"> | string
    isPrivate?: BoolWithAggregatesFilter<"ProfileSettings"> | boolean
    showLastSeen?: BoolWithAggregatesFilter<"ProfileSettings"> | boolean
    allowTagging?: BoolWithAggregatesFilter<"ProfileSettings"> | boolean
    allowMessagesFrom?: StringWithAggregatesFilter<"ProfileSettings"> | string
    discoveryAllowLineage?: BoolWithAggregatesFilter<"ProfileSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProfileSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfileSettings"> | Date | string
  }

  export type FriendRequestWhereInput = {
    AND?: FriendRequestWhereInput | FriendRequestWhereInput[]
    OR?: FriendRequestWhereInput[]
    NOT?: FriendRequestWhereInput | FriendRequestWhereInput[]
    id?: UuidFilter<"FriendRequest"> | string
    requesterId?: UuidFilter<"FriendRequest"> | string
    addresseeId?: UuidFilter<"FriendRequest"> | string
    status?: EnumFriendRequestStatusFilter<"FriendRequest"> | $Enums.FriendRequestStatus
    createdAt?: DateTimeFilter<"FriendRequest"> | Date | string
    respondedAt?: DateTimeNullableFilter<"FriendRequest"> | Date | string | null
    notifications?: NotificationListRelationFilter
    requester?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    addressee?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type FriendRequestOrderByWithRelationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    notifications?: NotificationOrderByRelationAggregateInput
    requester?: ProfileOrderByWithRelationInput
    addressee?: ProfileOrderByWithRelationInput
  }

  export type FriendRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    requesterId_addresseeId?: FriendRequestRequesterIdAddresseeIdCompoundUniqueInput
    AND?: FriendRequestWhereInput | FriendRequestWhereInput[]
    OR?: FriendRequestWhereInput[]
    NOT?: FriendRequestWhereInput | FriendRequestWhereInput[]
    requesterId?: UuidFilter<"FriendRequest"> | string
    addresseeId?: UuidFilter<"FriendRequest"> | string
    status?: EnumFriendRequestStatusFilter<"FriendRequest"> | $Enums.FriendRequestStatus
    createdAt?: DateTimeFilter<"FriendRequest"> | Date | string
    respondedAt?: DateTimeNullableFilter<"FriendRequest"> | Date | string | null
    notifications?: NotificationListRelationFilter
    requester?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    addressee?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "requesterId_addresseeId">

  export type FriendRequestOrderByWithAggregationInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    _count?: FriendRequestCountOrderByAggregateInput
    _max?: FriendRequestMaxOrderByAggregateInput
    _min?: FriendRequestMinOrderByAggregateInput
  }

  export type FriendRequestScalarWhereWithAggregatesInput = {
    AND?: FriendRequestScalarWhereWithAggregatesInput | FriendRequestScalarWhereWithAggregatesInput[]
    OR?: FriendRequestScalarWhereWithAggregatesInput[]
    NOT?: FriendRequestScalarWhereWithAggregatesInput | FriendRequestScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FriendRequest"> | string
    requesterId?: UuidWithAggregatesFilter<"FriendRequest"> | string
    addresseeId?: UuidWithAggregatesFilter<"FriendRequest"> | string
    status?: EnumFriendRequestStatusWithAggregatesFilter<"FriendRequest"> | $Enums.FriendRequestStatus
    createdAt?: DateTimeWithAggregatesFilter<"FriendRequest"> | Date | string
    respondedAt?: DateTimeNullableWithAggregatesFilter<"FriendRequest"> | Date | string | null
  }

  export type FriendshipWhereInput = {
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    id?: UuidFilter<"Friendship"> | string
    userAId?: UuidFilter<"Friendship"> | string
    userBId?: UuidFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    userA?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    userB?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type FriendshipOrderByWithRelationInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    createdAt?: SortOrder
    userA?: ProfileOrderByWithRelationInput
    userB?: ProfileOrderByWithRelationInput
  }

  export type FriendshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userAId_userBId?: FriendshipUserAIdUserBIdCompoundUniqueInput
    AND?: FriendshipWhereInput | FriendshipWhereInput[]
    OR?: FriendshipWhereInput[]
    NOT?: FriendshipWhereInput | FriendshipWhereInput[]
    userAId?: UuidFilter<"Friendship"> | string
    userBId?: UuidFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
    userA?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    userB?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "userAId_userBId">

  export type FriendshipOrderByWithAggregationInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    createdAt?: SortOrder
    _count?: FriendshipCountOrderByAggregateInput
    _max?: FriendshipMaxOrderByAggregateInput
    _min?: FriendshipMinOrderByAggregateInput
  }

  export type FriendshipScalarWhereWithAggregatesInput = {
    AND?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    OR?: FriendshipScalarWhereWithAggregatesInput[]
    NOT?: FriendshipScalarWhereWithAggregatesInput | FriendshipScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Friendship"> | string
    userAId?: UuidWithAggregatesFilter<"Friendship"> | string
    userBId?: UuidWithAggregatesFilter<"Friendship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Friendship"> | Date | string
  }

  export type ClanWhereInput = {
    AND?: ClanWhereInput | ClanWhereInput[]
    OR?: ClanWhereInput[]
    NOT?: ClanWhereInput | ClanWhereInput[]
    id?: UuidFilter<"Clan"> | string
    name?: StringFilter<"Clan"> | string
    members?: ProfileClanListRelationFilter
  }

  export type ClanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    members?: ProfileClanOrderByRelationAggregateInput
  }

  export type ClanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: ClanWhereInput | ClanWhereInput[]
    OR?: ClanWhereInput[]
    NOT?: ClanWhereInput | ClanWhereInput[]
    members?: ProfileClanListRelationFilter
  }, "id" | "name">

  export type ClanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: ClanCountOrderByAggregateInput
    _max?: ClanMaxOrderByAggregateInput
    _min?: ClanMinOrderByAggregateInput
  }

  export type ClanScalarWhereWithAggregatesInput = {
    AND?: ClanScalarWhereWithAggregatesInput | ClanScalarWhereWithAggregatesInput[]
    OR?: ClanScalarWhereWithAggregatesInput[]
    NOT?: ClanScalarWhereWithAggregatesInput | ClanScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Clan"> | string
    name?: StringWithAggregatesFilter<"Clan"> | string
  }

  export type ProfileClanWhereInput = {
    AND?: ProfileClanWhereInput | ProfileClanWhereInput[]
    OR?: ProfileClanWhereInput[]
    NOT?: ProfileClanWhereInput | ProfileClanWhereInput[]
    id?: UuidFilter<"ProfileClan"> | string
    profileId?: UuidFilter<"ProfileClan"> | string
    clanId?: UuidFilter<"ProfileClan"> | string
    order?: IntFilter<"ProfileClan"> | number
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    clan?: XOR<ClanScalarRelationFilter, ClanWhereInput>
  }

  export type ProfileClanOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    clanId?: SortOrder
    order?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    clan?: ClanOrderByWithRelationInput
  }

  export type ProfileClanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileId_order?: ProfileClanProfileIdOrderCompoundUniqueInput
    AND?: ProfileClanWhereInput | ProfileClanWhereInput[]
    OR?: ProfileClanWhereInput[]
    NOT?: ProfileClanWhereInput | ProfileClanWhereInput[]
    profileId?: UuidFilter<"ProfileClan"> | string
    clanId?: UuidFilter<"ProfileClan"> | string
    order?: IntFilter<"ProfileClan"> | number
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    clan?: XOR<ClanScalarRelationFilter, ClanWhereInput>
  }, "id" | "profileId_order">

  export type ProfileClanOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    clanId?: SortOrder
    order?: SortOrder
    _count?: ProfileClanCountOrderByAggregateInput
    _avg?: ProfileClanAvgOrderByAggregateInput
    _max?: ProfileClanMaxOrderByAggregateInput
    _min?: ProfileClanMinOrderByAggregateInput
    _sum?: ProfileClanSumOrderByAggregateInput
  }

  export type ProfileClanScalarWhereWithAggregatesInput = {
    AND?: ProfileClanScalarWhereWithAggregatesInput | ProfileClanScalarWhereWithAggregatesInput[]
    OR?: ProfileClanScalarWhereWithAggregatesInput[]
    NOT?: ProfileClanScalarWhereWithAggregatesInput | ProfileClanScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProfileClan"> | string
    profileId?: UuidWithAggregatesFilter<"ProfileClan"> | string
    clanId?: UuidWithAggregatesFilter<"ProfileClan"> | string
    order?: IntWithAggregatesFilter<"ProfileClan"> | number
  }

  export type LineageWhereInput = {
    AND?: LineageWhereInput | LineageWhereInput[]
    OR?: LineageWhereInput[]
    NOT?: LineageWhereInput | LineageWhereInput[]
    id?: UuidFilter<"Lineage"> | string
    name?: StringFilter<"Lineage"> | string
    type?: EnumLineageTypeFilter<"Lineage"> | $Enums.LineageType
    primarySurname?: StringNullableFilter<"Lineage"> | string | null
    rootVillage?: StringNullableFilter<"Lineage"> | string | null
    rootRegion?: StringNullableFilter<"Lineage"> | string | null
    description?: StringNullableFilter<"Lineage"> | string | null
    createdById?: UuidNullableFilter<"Lineage"> | string | null
    createdAt?: DateTimeFilter<"Lineage"> | Date | string
    updatedAt?: DateTimeFilter<"Lineage"> | Date | string
    createdBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    memberships?: LineageMembershipListRelationFilter
    notifications?: NotificationListRelationFilter
    posts?: PostListRelationFilter
  }

  export type LineageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrderInput | SortOrder
    rootVillage?: SortOrderInput | SortOrder
    rootRegion?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: ProfileOrderByWithRelationInput
    memberships?: LineageMembershipOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
  }

  export type LineageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LineageWhereInput | LineageWhereInput[]
    OR?: LineageWhereInput[]
    NOT?: LineageWhereInput | LineageWhereInput[]
    name?: StringFilter<"Lineage"> | string
    type?: EnumLineageTypeFilter<"Lineage"> | $Enums.LineageType
    primarySurname?: StringNullableFilter<"Lineage"> | string | null
    rootVillage?: StringNullableFilter<"Lineage"> | string | null
    rootRegion?: StringNullableFilter<"Lineage"> | string | null
    description?: StringNullableFilter<"Lineage"> | string | null
    createdById?: UuidNullableFilter<"Lineage"> | string | null
    createdAt?: DateTimeFilter<"Lineage"> | Date | string
    updatedAt?: DateTimeFilter<"Lineage"> | Date | string
    createdBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    memberships?: LineageMembershipListRelationFilter
    notifications?: NotificationListRelationFilter
    posts?: PostListRelationFilter
  }, "id">

  export type LineageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrderInput | SortOrder
    rootVillage?: SortOrderInput | SortOrder
    rootRegion?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LineageCountOrderByAggregateInput
    _max?: LineageMaxOrderByAggregateInput
    _min?: LineageMinOrderByAggregateInput
  }

  export type LineageScalarWhereWithAggregatesInput = {
    AND?: LineageScalarWhereWithAggregatesInput | LineageScalarWhereWithAggregatesInput[]
    OR?: LineageScalarWhereWithAggregatesInput[]
    NOT?: LineageScalarWhereWithAggregatesInput | LineageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Lineage"> | string
    name?: StringWithAggregatesFilter<"Lineage"> | string
    type?: EnumLineageTypeWithAggregatesFilter<"Lineage"> | $Enums.LineageType
    primarySurname?: StringNullableWithAggregatesFilter<"Lineage"> | string | null
    rootVillage?: StringNullableWithAggregatesFilter<"Lineage"> | string | null
    rootRegion?: StringNullableWithAggregatesFilter<"Lineage"> | string | null
    description?: StringNullableWithAggregatesFilter<"Lineage"> | string | null
    createdById?: UuidNullableWithAggregatesFilter<"Lineage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lineage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lineage"> | Date | string
  }

  export type LineageMembershipWhereInput = {
    AND?: LineageMembershipWhereInput | LineageMembershipWhereInput[]
    OR?: LineageMembershipWhereInput[]
    NOT?: LineageMembershipWhereInput | LineageMembershipWhereInput[]
    id?: UuidFilter<"LineageMembership"> | string
    lineageId?: UuidFilter<"LineageMembership"> | string
    profileId?: UuidFilter<"LineageMembership"> | string
    role?: EnumLineageRoleFilter<"LineageMembership"> | $Enums.LineageRole
    generation?: IntNullableFilter<"LineageMembership"> | number | null
    isPrimaryLineage?: BoolFilter<"LineageMembership"> | boolean
    addedById?: UuidNullableFilter<"LineageMembership"> | string | null
    createdAt?: DateTimeFilter<"LineageMembership"> | Date | string
    addedBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    lineage?: XOR<LineageScalarRelationFilter, LineageWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type LineageMembershipOrderByWithRelationInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrderInput | SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    addedBy?: ProfileOrderByWithRelationInput
    lineage?: LineageOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type LineageMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lineageId_profileId?: LineageMembershipLineageIdProfileIdCompoundUniqueInput
    AND?: LineageMembershipWhereInput | LineageMembershipWhereInput[]
    OR?: LineageMembershipWhereInput[]
    NOT?: LineageMembershipWhereInput | LineageMembershipWhereInput[]
    lineageId?: UuidFilter<"LineageMembership"> | string
    profileId?: UuidFilter<"LineageMembership"> | string
    role?: EnumLineageRoleFilter<"LineageMembership"> | $Enums.LineageRole
    generation?: IntNullableFilter<"LineageMembership"> | number | null
    isPrimaryLineage?: BoolFilter<"LineageMembership"> | boolean
    addedById?: UuidNullableFilter<"LineageMembership"> | string | null
    createdAt?: DateTimeFilter<"LineageMembership"> | Date | string
    addedBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    lineage?: XOR<LineageScalarRelationFilter, LineageWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "lineageId_profileId">

  export type LineageMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrderInput | SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LineageMembershipCountOrderByAggregateInput
    _avg?: LineageMembershipAvgOrderByAggregateInput
    _max?: LineageMembershipMaxOrderByAggregateInput
    _min?: LineageMembershipMinOrderByAggregateInput
    _sum?: LineageMembershipSumOrderByAggregateInput
  }

  export type LineageMembershipScalarWhereWithAggregatesInput = {
    AND?: LineageMembershipScalarWhereWithAggregatesInput | LineageMembershipScalarWhereWithAggregatesInput[]
    OR?: LineageMembershipScalarWhereWithAggregatesInput[]
    NOT?: LineageMembershipScalarWhereWithAggregatesInput | LineageMembershipScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LineageMembership"> | string
    lineageId?: UuidWithAggregatesFilter<"LineageMembership"> | string
    profileId?: UuidWithAggregatesFilter<"LineageMembership"> | string
    role?: EnumLineageRoleWithAggregatesFilter<"LineageMembership"> | $Enums.LineageRole
    generation?: IntNullableWithAggregatesFilter<"LineageMembership"> | number | null
    isPrimaryLineage?: BoolWithAggregatesFilter<"LineageMembership"> | boolean
    addedById?: UuidNullableWithAggregatesFilter<"LineageMembership"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LineageMembership"> | Date | string
  }

  export type KinshipWhereInput = {
    AND?: KinshipWhereInput | KinshipWhereInput[]
    OR?: KinshipWhereInput[]
    NOT?: KinshipWhereInput | KinshipWhereInput[]
    id?: UuidFilter<"Kinship"> | string
    profileIdA?: UuidFilter<"Kinship"> | string
    profileIdB?: UuidFilter<"Kinship"> | string
    relationAtoB?: EnumKinshipTypeFilter<"Kinship"> | $Enums.KinshipType
    verified?: BoolFilter<"Kinship"> | boolean
    verifiedById?: UuidNullableFilter<"Kinship"> | string | null
    createdAt?: DateTimeFilter<"Kinship"> | Date | string
    profileA?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    profileB?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type KinshipOrderByWithRelationInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    profileA?: ProfileOrderByWithRelationInput
    profileB?: ProfileOrderByWithRelationInput
  }

  export type KinshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileIdA_profileIdB_relationAtoB?: KinshipProfileIdAProfileIdBRelationAtoBCompoundUniqueInput
    AND?: KinshipWhereInput | KinshipWhereInput[]
    OR?: KinshipWhereInput[]
    NOT?: KinshipWhereInput | KinshipWhereInput[]
    profileIdA?: UuidFilter<"Kinship"> | string
    profileIdB?: UuidFilter<"Kinship"> | string
    relationAtoB?: EnumKinshipTypeFilter<"Kinship"> | $Enums.KinshipType
    verified?: BoolFilter<"Kinship"> | boolean
    verifiedById?: UuidNullableFilter<"Kinship"> | string | null
    createdAt?: DateTimeFilter<"Kinship"> | Date | string
    profileA?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    profileB?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "profileIdA_profileIdB_relationAtoB">

  export type KinshipOrderByWithAggregationInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: KinshipCountOrderByAggregateInput
    _max?: KinshipMaxOrderByAggregateInput
    _min?: KinshipMinOrderByAggregateInput
  }

  export type KinshipScalarWhereWithAggregatesInput = {
    AND?: KinshipScalarWhereWithAggregatesInput | KinshipScalarWhereWithAggregatesInput[]
    OR?: KinshipScalarWhereWithAggregatesInput[]
    NOT?: KinshipScalarWhereWithAggregatesInput | KinshipScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Kinship"> | string
    profileIdA?: UuidWithAggregatesFilter<"Kinship"> | string
    profileIdB?: UuidWithAggregatesFilter<"Kinship"> | string
    relationAtoB?: EnumKinshipTypeWithAggregatesFilter<"Kinship"> | $Enums.KinshipType
    verified?: BoolWithAggregatesFilter<"Kinship"> | boolean
    verifiedById?: UuidNullableWithAggregatesFilter<"Kinship"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Kinship"> | Date | string
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: UuidFilter<"Block"> | string
    blockerId?: UuidFilter<"Block"> | string
    blockedId?: UuidFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blocked?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    blocker?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
    blocked?: ProfileOrderByWithRelationInput
    blocker?: ProfileOrderByWithRelationInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockerId_blockedId?: BlockBlockerIdBlockedIdCompoundUniqueInput
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    blockerId?: UuidFilter<"Block"> | string
    blockedId?: UuidFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blocked?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    blocker?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "blockerId_blockedId">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Block"> | string
    blockerId?: UuidWithAggregatesFilter<"Block"> | string
    blockedId?: UuidWithAggregatesFilter<"Block"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
  }

  export type MuteWhereInput = {
    AND?: MuteWhereInput | MuteWhereInput[]
    OR?: MuteWhereInput[]
    NOT?: MuteWhereInput | MuteWhereInput[]
    id?: UuidFilter<"Mute"> | string
    muterId?: UuidFilter<"Mute"> | string
    mutedId?: UuidFilter<"Mute"> | string
    createdAt?: DateTimeFilter<"Mute"> | Date | string
    muted?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    muter?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type MuteOrderByWithRelationInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
    muted?: ProfileOrderByWithRelationInput
    muter?: ProfileOrderByWithRelationInput
  }

  export type MuteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    muterId_mutedId?: MuteMuterIdMutedIdCompoundUniqueInput
    AND?: MuteWhereInput | MuteWhereInput[]
    OR?: MuteWhereInput[]
    NOT?: MuteWhereInput | MuteWhereInput[]
    muterId?: UuidFilter<"Mute"> | string
    mutedId?: UuidFilter<"Mute"> | string
    createdAt?: DateTimeFilter<"Mute"> | Date | string
    muted?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    muter?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "muterId_mutedId">

  export type MuteOrderByWithAggregationInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
    _count?: MuteCountOrderByAggregateInput
    _max?: MuteMaxOrderByAggregateInput
    _min?: MuteMinOrderByAggregateInput
  }

  export type MuteScalarWhereWithAggregatesInput = {
    AND?: MuteScalarWhereWithAggregatesInput | MuteScalarWhereWithAggregatesInput[]
    OR?: MuteScalarWhereWithAggregatesInput[]
    NOT?: MuteScalarWhereWithAggregatesInput | MuteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Mute"> | string
    muterId?: UuidWithAggregatesFilter<"Mute"> | string
    mutedId?: UuidWithAggregatesFilter<"Mute"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Mute"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: UuidFilter<"Post"> | string
    profileId?: UuidFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    locationText?: StringNullableFilter<"Post"> | string | null
    lineageId?: UuidNullableFilter<"Post"> | string | null
    commentCount?: IntFilter<"Post"> | number
    likeCount?: IntFilter<"Post"> | number
    shareCount?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    comments?: CommentListRelationFilter
    mediaFiles?: MediaFileListRelationFilter
    notifications?: NotificationListRelationFilter
    lineage?: XOR<LineageNullableScalarRelationFilter, LineageWhereInput> | null
    author?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    reactions?: PostReactionListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrderInput | SortOrder
    visibility?: SortOrder
    locationText?: SortOrderInput | SortOrder
    lineageId?: SortOrderInput | SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    comments?: CommentOrderByRelationAggregateInput
    mediaFiles?: MediaFileOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    lineage?: LineageOrderByWithRelationInput
    author?: ProfileOrderByWithRelationInput
    reactions?: PostReactionOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    profileId?: UuidFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    locationText?: StringNullableFilter<"Post"> | string | null
    lineageId?: UuidNullableFilter<"Post"> | string | null
    commentCount?: IntFilter<"Post"> | number
    likeCount?: IntFilter<"Post"> | number
    shareCount?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    comments?: CommentListRelationFilter
    mediaFiles?: MediaFileListRelationFilter
    notifications?: NotificationListRelationFilter
    lineage?: XOR<LineageNullableScalarRelationFilter, LineageWhereInput> | null
    author?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    reactions?: PostReactionListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrderInput | SortOrder
    visibility?: SortOrder
    locationText?: SortOrderInput | SortOrder
    lineageId?: SortOrderInput | SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Post"> | string
    profileId?: UuidWithAggregatesFilter<"Post"> | string
    content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    visibility?: EnumPostVisibilityWithAggregatesFilter<"Post"> | $Enums.PostVisibility
    locationText?: StringNullableWithAggregatesFilter<"Post"> | string | null
    lineageId?: UuidNullableWithAggregatesFilter<"Post"> | string | null
    commentCount?: IntWithAggregatesFilter<"Post"> | number
    likeCount?: IntWithAggregatesFilter<"Post"> | number
    shareCount?: IntWithAggregatesFilter<"Post"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type MediaFileWhereInput = {
    AND?: MediaFileWhereInput | MediaFileWhereInput[]
    OR?: MediaFileWhereInput[]
    NOT?: MediaFileWhereInput | MediaFileWhereInput[]
    id?: UuidFilter<"MediaFile"> | string
    postId?: UuidFilter<"MediaFile"> | string
    type?: EnumMediaTypeFilter<"MediaFile"> | $Enums.MediaType
    url?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    width?: IntNullableFilter<"MediaFile"> | number | null
    height?: IntNullableFilter<"MediaFile"> | number | null
    sizeBytes?: IntFilter<"MediaFile"> | number
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    updatedAt?: DateTimeFilter<"MediaFile"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type MediaFileOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type MediaFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaFileWhereInput | MediaFileWhereInput[]
    OR?: MediaFileWhereInput[]
    NOT?: MediaFileWhereInput | MediaFileWhereInput[]
    postId?: UuidFilter<"MediaFile"> | string
    type?: EnumMediaTypeFilter<"MediaFile"> | $Enums.MediaType
    url?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    width?: IntNullableFilter<"MediaFile"> | number | null
    height?: IntNullableFilter<"MediaFile"> | number | null
    sizeBytes?: IntFilter<"MediaFile"> | number
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    updatedAt?: DateTimeFilter<"MediaFile"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type MediaFileOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaFileCountOrderByAggregateInput
    _avg?: MediaFileAvgOrderByAggregateInput
    _max?: MediaFileMaxOrderByAggregateInput
    _min?: MediaFileMinOrderByAggregateInput
    _sum?: MediaFileSumOrderByAggregateInput
  }

  export type MediaFileScalarWhereWithAggregatesInput = {
    AND?: MediaFileScalarWhereWithAggregatesInput | MediaFileScalarWhereWithAggregatesInput[]
    OR?: MediaFileScalarWhereWithAggregatesInput[]
    NOT?: MediaFileScalarWhereWithAggregatesInput | MediaFileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MediaFile"> | string
    postId?: UuidWithAggregatesFilter<"MediaFile"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"MediaFile"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"MediaFile"> | string
    mimeType?: StringWithAggregatesFilter<"MediaFile"> | string
    width?: IntNullableWithAggregatesFilter<"MediaFile"> | number | null
    height?: IntNullableWithAggregatesFilter<"MediaFile"> | number | null
    sizeBytes?: IntWithAggregatesFilter<"MediaFile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MediaFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaFile"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: UuidFilter<"Comment"> | string
    postId?: UuidFilter<"Comment"> | string
    profileId?: UuidFilter<"Comment"> | string
    parentCommentId?: UuidNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    likeCount?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    parentComment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    reactions?: CommentReactionListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    parentComment?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
    post?: PostOrderByWithRelationInput
    author?: ProfileOrderByWithRelationInput
    reactions?: CommentReactionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: UuidFilter<"Comment"> | string
    profileId?: UuidFilter<"Comment"> | string
    parentCommentId?: UuidNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    likeCount?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    parentComment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    reactions?: CommentReactionListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Comment"> | string
    postId?: UuidWithAggregatesFilter<"Comment"> | string
    profileId?: UuidWithAggregatesFilter<"Comment"> | string
    parentCommentId?: UuidNullableWithAggregatesFilter<"Comment"> | string | null
    content?: StringWithAggregatesFilter<"Comment"> | string
    likeCount?: IntWithAggregatesFilter<"Comment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type PostReactionWhereInput = {
    AND?: PostReactionWhereInput | PostReactionWhereInput[]
    OR?: PostReactionWhereInput[]
    NOT?: PostReactionWhereInput | PostReactionWhereInput[]
    id?: UuidFilter<"PostReaction"> | string
    postId?: UuidFilter<"PostReaction"> | string
    profileId?: UuidFilter<"PostReaction"> | string
    type?: EnumReactionTypeFilter<"PostReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"PostReaction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type PostReactionOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type PostReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_profileId?: PostReactionPostIdProfileIdCompoundUniqueInput
    AND?: PostReactionWhereInput | PostReactionWhereInput[]
    OR?: PostReactionWhereInput[]
    NOT?: PostReactionWhereInput | PostReactionWhereInput[]
    postId?: UuidFilter<"PostReaction"> | string
    profileId?: UuidFilter<"PostReaction"> | string
    type?: EnumReactionTypeFilter<"PostReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"PostReaction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "postId_profileId">

  export type PostReactionOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: PostReactionCountOrderByAggregateInput
    _max?: PostReactionMaxOrderByAggregateInput
    _min?: PostReactionMinOrderByAggregateInput
  }

  export type PostReactionScalarWhereWithAggregatesInput = {
    AND?: PostReactionScalarWhereWithAggregatesInput | PostReactionScalarWhereWithAggregatesInput[]
    OR?: PostReactionScalarWhereWithAggregatesInput[]
    NOT?: PostReactionScalarWhereWithAggregatesInput | PostReactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PostReaction"> | string
    postId?: UuidWithAggregatesFilter<"PostReaction"> | string
    profileId?: UuidWithAggregatesFilter<"PostReaction"> | string
    type?: EnumReactionTypeWithAggregatesFilter<"PostReaction"> | $Enums.ReactionType
    createdAt?: DateTimeWithAggregatesFilter<"PostReaction"> | Date | string
  }

  export type CommentReactionWhereInput = {
    AND?: CommentReactionWhereInput | CommentReactionWhereInput[]
    OR?: CommentReactionWhereInput[]
    NOT?: CommentReactionWhereInput | CommentReactionWhereInput[]
    id?: UuidFilter<"CommentReaction"> | string
    commentId?: UuidFilter<"CommentReaction"> | string
    profileId?: UuidFilter<"CommentReaction"> | string
    type?: EnumReactionTypeFilter<"CommentReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"CommentReaction"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type CommentReactionOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type CommentReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    commentId_profileId?: CommentReactionCommentIdProfileIdCompoundUniqueInput
    AND?: CommentReactionWhereInput | CommentReactionWhereInput[]
    OR?: CommentReactionWhereInput[]
    NOT?: CommentReactionWhereInput | CommentReactionWhereInput[]
    commentId?: UuidFilter<"CommentReaction"> | string
    profileId?: UuidFilter<"CommentReaction"> | string
    type?: EnumReactionTypeFilter<"CommentReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"CommentReaction"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "commentId_profileId">

  export type CommentReactionOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: CommentReactionCountOrderByAggregateInput
    _max?: CommentReactionMaxOrderByAggregateInput
    _min?: CommentReactionMinOrderByAggregateInput
  }

  export type CommentReactionScalarWhereWithAggregatesInput = {
    AND?: CommentReactionScalarWhereWithAggregatesInput | CommentReactionScalarWhereWithAggregatesInput[]
    OR?: CommentReactionScalarWhereWithAggregatesInput[]
    NOT?: CommentReactionScalarWhereWithAggregatesInput | CommentReactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CommentReaction"> | string
    commentId?: UuidWithAggregatesFilter<"CommentReaction"> | string
    profileId?: UuidWithAggregatesFilter<"CommentReaction"> | string
    type?: EnumReactionTypeWithAggregatesFilter<"CommentReaction"> | $Enums.ReactionType
    createdAt?: DateTimeWithAggregatesFilter<"CommentReaction"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: UuidFilter<"Conversation"> | string
    isGroup?: BoolFilter<"Conversation"> | boolean
    title?: StringNullableFilter<"Conversation"> | string | null
    createdById?: UuidNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    createdBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: ProfileOrderByWithRelationInput
    participants?: ConversationParticipantOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    isGroup?: BoolFilter<"Conversation"> | boolean
    title?: StringNullableFilter<"Conversation"> | string | null
    createdById?: UuidNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    createdBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Conversation"> | string
    isGroup?: BoolWithAggregatesFilter<"Conversation"> | boolean
    title?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdById?: UuidNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantWhereInput = {
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    id?: UuidFilter<"ConversationParticipant"> | string
    conversationId?: UuidFilter<"ConversationParticipant"> | string
    profileId?: UuidFilter<"ConversationParticipant"> | string
    role?: StringFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ConversationParticipantOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type ConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_profileId?: ConversationParticipantConversationIdProfileIdCompoundUniqueInput
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: UuidFilter<"ConversationParticipant"> | string
    profileId?: UuidFilter<"ConversationParticipant"> | string
    role?: StringFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "conversationId_profileId">

  export type ConversationParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: ConversationParticipantCountOrderByAggregateInput
    _max?: ConversationParticipantMaxOrderByAggregateInput
    _min?: ConversationParticipantMinOrderByAggregateInput
  }

  export type ConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: ConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ConversationParticipant"> | string
    conversationId?: UuidWithAggregatesFilter<"ConversationParticipant"> | string
    profileId?: UuidWithAggregatesFilter<"ConversationParticipant"> | string
    role?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeNullableWithAggregatesFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"ConversationParticipant"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: UuidFilter<"Message"> | string
    conversationId?: UuidFilter<"Message"> | string
    senderId?: UuidFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    timestamp?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    reads?: MessageReadListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: ProfileOrderByWithRelationInput
    reads?: MessageReadOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: UuidFilter<"Message"> | string
    senderId?: UuidFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    timestamp?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    reads?: MessageReadListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Message"> | string
    conversationId?: UuidWithAggregatesFilter<"Message"> | string
    senderId?: UuidWithAggregatesFilter<"Message"> | string
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    recipientId?: UuidFilter<"Notification"> | string
    senderId?: UuidNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    postId?: UuidNullableFilter<"Notification"> | string | null
    commentId?: UuidNullableFilter<"Notification"> | string | null
    requestId?: UuidNullableFilter<"Notification"> | string | null
    lineageId?: UuidNullableFilter<"Notification"> | string | null
    messageId?: UuidNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    sender?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    lineage?: XOR<LineageNullableScalarRelationFilter, LineageWhereInput> | null
    request?: XOR<FriendRequestNullableScalarRelationFilter, FriendRequestWhereInput> | null
    message?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    recipient?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    type?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    lineageId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    sender?: ProfileOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
    lineage?: LineageOrderByWithRelationInput
    request?: FriendRequestOrderByWithRelationInput
    message?: MessageOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    recipient?: ProfileOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    recipientId?: UuidFilter<"Notification"> | string
    senderId?: UuidNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    postId?: UuidNullableFilter<"Notification"> | string | null
    commentId?: UuidNullableFilter<"Notification"> | string | null
    requestId?: UuidNullableFilter<"Notification"> | string | null
    lineageId?: UuidNullableFilter<"Notification"> | string | null
    messageId?: UuidNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    sender?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    lineage?: XOR<LineageNullableScalarRelationFilter, LineageWhereInput> | null
    request?: XOR<FriendRequestNullableScalarRelationFilter, FriendRequestWhereInput> | null
    message?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    recipient?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrderInput | SortOrder
    type?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    requestId?: SortOrderInput | SortOrder
    lineageId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    recipientId?: UuidWithAggregatesFilter<"Notification"> | string
    senderId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    postId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    commentId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    requestId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    lineageId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    messageId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type InterestWhereInput = {
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    id?: UuidFilter<"Interest"> | string
    name?: StringFilter<"Interest"> | string
    users?: ProfileInterestListRelationFilter
  }

  export type InterestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: ProfileInterestOrderByRelationAggregateInput
  }

  export type InterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    users?: ProfileInterestListRelationFilter
  }, "id" | "name">

  export type InterestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: InterestCountOrderByAggregateInput
    _max?: InterestMaxOrderByAggregateInput
    _min?: InterestMinOrderByAggregateInput
  }

  export type InterestScalarWhereWithAggregatesInput = {
    AND?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    OR?: InterestScalarWhereWithAggregatesInput[]
    NOT?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Interest"> | string
    name?: StringWithAggregatesFilter<"Interest"> | string
  }

  export type AppInterestWhereInput = {
    AND?: AppInterestWhereInput | AppInterestWhereInput[]
    OR?: AppInterestWhereInput[]
    NOT?: AppInterestWhereInput | AppInterestWhereInput[]
    id?: UuidFilter<"AppInterest"> | string
    name?: StringFilter<"AppInterest"> | string
    users?: ProfileAppInterestsListRelationFilter
  }

  export type AppInterestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: ProfileAppInterestsOrderByRelationAggregateInput
  }

  export type AppInterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AppInterestWhereInput | AppInterestWhereInput[]
    OR?: AppInterestWhereInput[]
    NOT?: AppInterestWhereInput | AppInterestWhereInput[]
    users?: ProfileAppInterestsListRelationFilter
  }, "id" | "name">

  export type AppInterestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: AppInterestCountOrderByAggregateInput
    _max?: AppInterestMaxOrderByAggregateInput
    _min?: AppInterestMinOrderByAggregateInput
  }

  export type AppInterestScalarWhereWithAggregatesInput = {
    AND?: AppInterestScalarWhereWithAggregatesInput | AppInterestScalarWhereWithAggregatesInput[]
    OR?: AppInterestScalarWhereWithAggregatesInput[]
    NOT?: AppInterestScalarWhereWithAggregatesInput | AppInterestScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"AppInterest"> | string
    name?: StringWithAggregatesFilter<"AppInterest"> | string
  }

  export type ProfileInterestWhereInput = {
    AND?: ProfileInterestWhereInput | ProfileInterestWhereInput[]
    OR?: ProfileInterestWhereInput[]
    NOT?: ProfileInterestWhereInput | ProfileInterestWhereInput[]
    userId?: UuidFilter<"ProfileInterest"> | string
    interestId?: UuidFilter<"ProfileInterest"> | string
    createdAt?: DateTimeFilter<"ProfileInterest"> | Date | string
    interest?: XOR<InterestScalarRelationFilter, InterestWhereInput>
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ProfileInterestOrderByWithRelationInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
    interest?: InterestOrderByWithRelationInput
    user?: ProfileOrderByWithRelationInput
  }

  export type ProfileInterestWhereUniqueInput = Prisma.AtLeast<{
    userId_interestId?: ProfileInterestUserIdInterestIdCompoundUniqueInput
    AND?: ProfileInterestWhereInput | ProfileInterestWhereInput[]
    OR?: ProfileInterestWhereInput[]
    NOT?: ProfileInterestWhereInput | ProfileInterestWhereInput[]
    userId?: UuidFilter<"ProfileInterest"> | string
    interestId?: UuidFilter<"ProfileInterest"> | string
    createdAt?: DateTimeFilter<"ProfileInterest"> | Date | string
    interest?: XOR<InterestScalarRelationFilter, InterestWhereInput>
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "userId_interestId">

  export type ProfileInterestOrderByWithAggregationInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
    _count?: ProfileInterestCountOrderByAggregateInput
    _max?: ProfileInterestMaxOrderByAggregateInput
    _min?: ProfileInterestMinOrderByAggregateInput
  }

  export type ProfileInterestScalarWhereWithAggregatesInput = {
    AND?: ProfileInterestScalarWhereWithAggregatesInput | ProfileInterestScalarWhereWithAggregatesInput[]
    OR?: ProfileInterestScalarWhereWithAggregatesInput[]
    NOT?: ProfileInterestScalarWhereWithAggregatesInput | ProfileInterestScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"ProfileInterest"> | string
    interestId?: UuidWithAggregatesFilter<"ProfileInterest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileInterest"> | Date | string
  }

  export type ProfileAppInterestsWhereInput = {
    AND?: ProfileAppInterestsWhereInput | ProfileAppInterestsWhereInput[]
    OR?: ProfileAppInterestsWhereInput[]
    NOT?: ProfileAppInterestsWhereInput | ProfileAppInterestsWhereInput[]
    userId?: UuidFilter<"ProfileAppInterests"> | string
    interestId?: UuidFilter<"ProfileAppInterests"> | string
    createdAt?: DateTimeFilter<"ProfileAppInterests"> | Date | string
    interest?: XOR<AppInterestScalarRelationFilter, AppInterestWhereInput>
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ProfileAppInterestsOrderByWithRelationInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
    interest?: AppInterestOrderByWithRelationInput
    user?: ProfileOrderByWithRelationInput
  }

  export type ProfileAppInterestsWhereUniqueInput = Prisma.AtLeast<{
    userId_interestId?: ProfileAppInterestsUserIdInterestIdCompoundUniqueInput
    AND?: ProfileAppInterestsWhereInput | ProfileAppInterestsWhereInput[]
    OR?: ProfileAppInterestsWhereInput[]
    NOT?: ProfileAppInterestsWhereInput | ProfileAppInterestsWhereInput[]
    userId?: UuidFilter<"ProfileAppInterests"> | string
    interestId?: UuidFilter<"ProfileAppInterests"> | string
    createdAt?: DateTimeFilter<"ProfileAppInterests"> | Date | string
    interest?: XOR<AppInterestScalarRelationFilter, AppInterestWhereInput>
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "userId_interestId">

  export type ProfileAppInterestsOrderByWithAggregationInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
    _count?: ProfileAppInterestsCountOrderByAggregateInput
    _max?: ProfileAppInterestsMaxOrderByAggregateInput
    _min?: ProfileAppInterestsMinOrderByAggregateInput
  }

  export type ProfileAppInterestsScalarWhereWithAggregatesInput = {
    AND?: ProfileAppInterestsScalarWhereWithAggregatesInput | ProfileAppInterestsScalarWhereWithAggregatesInput[]
    OR?: ProfileAppInterestsScalarWhereWithAggregatesInput[]
    NOT?: ProfileAppInterestsScalarWhereWithAggregatesInput | ProfileAppInterestsScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"ProfileAppInterests"> | string
    interestId?: UuidWithAggregatesFilter<"ProfileAppInterests"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileAppInterests"> | Date | string
  }

  export type MessageReadWhereInput = {
    AND?: MessageReadWhereInput | MessageReadWhereInput[]
    OR?: MessageReadWhereInput[]
    NOT?: MessageReadWhereInput | MessageReadWhereInput[]
    messageId?: UuidFilter<"MessageRead"> | string
    userId?: UuidFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type MessageReadOrderByWithRelationInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: ProfileOrderByWithRelationInput
  }

  export type MessageReadWhereUniqueInput = Prisma.AtLeast<{
    messageId_userId?: MessageReadMessageIdUserIdCompoundUniqueInput
    AND?: MessageReadWhereInput | MessageReadWhereInput[]
    OR?: MessageReadWhereInput[]
    NOT?: MessageReadWhereInput | MessageReadWhereInput[]
    messageId?: UuidFilter<"MessageRead"> | string
    userId?: UuidFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "messageId_userId">

  export type MessageReadOrderByWithAggregationInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: MessageReadCountOrderByAggregateInput
    _max?: MessageReadMaxOrderByAggregateInput
    _min?: MessageReadMinOrderByAggregateInput
  }

  export type MessageReadScalarWhereWithAggregatesInput = {
    AND?: MessageReadScalarWhereWithAggregatesInput | MessageReadScalarWhereWithAggregatesInput[]
    OR?: MessageReadScalarWhereWithAggregatesInput[]
    NOT?: MessageReadScalarWhereWithAggregatesInput | MessageReadScalarWhereWithAggregatesInput[]
    messageId?: UuidWithAggregatesFilter<"MessageRead"> | string
    userId?: UuidWithAggregatesFilter<"MessageRead"> | string
    readAt?: DateTimeWithAggregatesFilter<"MessageRead"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: UuidFilter<"Product"> | string
    sellerId?: UuidFilter<"Product"> | string
    visibility?: EnumPostVisibilityFilter<"Product"> | $Enums.PostVisibility
    title?: StringFilter<"Product"> | string
    price?: IntFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    condition?: EnumProductConditionFilter<"Product"> | $Enums.ProductCondition
    negotiable?: BoolFilter<"Product"> | boolean
    availability?: EnumAvailableFilter<"Product"> | $Enums.Available
    status?: EnumListingStatusFilter<"Product"> | $Enums.ListingStatus
    publishedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    country?: StringNullableFilter<"Product"> | string | null
    city?: StringNullableFilter<"Product"> | string | null
    district?: StringNullableFilter<"Product"> | string | null
    locationText?: StringNullableFilter<"Product"> | string | null
    lat?: FloatNullableFilter<"Product"> | number | null
    lng?: FloatNullableFilter<"Product"> | number | null
    viewCount?: IntFilter<"Product"> | number
    saveCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    seller?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    media?: ProductMediaListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    visibility?: SortOrder
    title?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    negotiable?: SortOrder
    availability?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    locationText?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    saveCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    seller?: ProfileOrderByWithRelationInput
    media?: ProductMediaOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    sellerId?: UuidFilter<"Product"> | string
    visibility?: EnumPostVisibilityFilter<"Product"> | $Enums.PostVisibility
    title?: StringFilter<"Product"> | string
    price?: IntFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    condition?: EnumProductConditionFilter<"Product"> | $Enums.ProductCondition
    negotiable?: BoolFilter<"Product"> | boolean
    availability?: EnumAvailableFilter<"Product"> | $Enums.Available
    status?: EnumListingStatusFilter<"Product"> | $Enums.ListingStatus
    publishedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    country?: StringNullableFilter<"Product"> | string | null
    city?: StringNullableFilter<"Product"> | string | null
    district?: StringNullableFilter<"Product"> | string | null
    locationText?: StringNullableFilter<"Product"> | string | null
    lat?: FloatNullableFilter<"Product"> | number | null
    lng?: FloatNullableFilter<"Product"> | number | null
    viewCount?: IntFilter<"Product"> | number
    saveCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    seller?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    media?: ProductMediaListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    sellerId?: SortOrder
    visibility?: SortOrder
    title?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    negotiable?: SortOrder
    availability?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    locationText?: SortOrderInput | SortOrder
    lat?: SortOrderInput | SortOrder
    lng?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    saveCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Product"> | string
    sellerId?: UuidWithAggregatesFilter<"Product"> | string
    visibility?: EnumPostVisibilityWithAggregatesFilter<"Product"> | $Enums.PostVisibility
    title?: StringWithAggregatesFilter<"Product"> | string
    price?: IntWithAggregatesFilter<"Product"> | number
    currency?: StringWithAggregatesFilter<"Product"> | string
    description?: StringWithAggregatesFilter<"Product"> | string
    category?: StringWithAggregatesFilter<"Product"> | string
    condition?: EnumProductConditionWithAggregatesFilter<"Product"> | $Enums.ProductCondition
    negotiable?: BoolWithAggregatesFilter<"Product"> | boolean
    availability?: EnumAvailableWithAggregatesFilter<"Product"> | $Enums.Available
    status?: EnumListingStatusWithAggregatesFilter<"Product"> | $Enums.ListingStatus
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    country?: StringNullableWithAggregatesFilter<"Product"> | string | null
    city?: StringNullableWithAggregatesFilter<"Product"> | string | null
    district?: StringNullableWithAggregatesFilter<"Product"> | string | null
    locationText?: StringNullableWithAggregatesFilter<"Product"> | string | null
    lat?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    lng?: FloatNullableWithAggregatesFilter<"Product"> | number | null
    viewCount?: IntWithAggregatesFilter<"Product"> | number
    saveCount?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductMediaWhereInput = {
    AND?: ProductMediaWhereInput | ProductMediaWhereInput[]
    OR?: ProductMediaWhereInput[]
    NOT?: ProductMediaWhereInput | ProductMediaWhereInput[]
    id?: UuidFilter<"ProductMedia"> | string
    productId?: UuidFilter<"ProductMedia"> | string
    url?: StringFilter<"ProductMedia"> | string
    mimeType?: StringFilter<"ProductMedia"> | string
    width?: IntNullableFilter<"ProductMedia"> | number | null
    height?: IntNullableFilter<"ProductMedia"> | number | null
    sizeBytes?: IntFilter<"ProductMedia"> | number
    orderIndex?: IntFilter<"ProductMedia"> | number
    isCover?: BoolFilter<"ProductMedia"> | boolean
    createdAt?: DateTimeFilter<"ProductMedia"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductMediaOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    sizeBytes?: SortOrder
    orderIndex?: SortOrder
    isCover?: SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
  }

  export type ProductMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductMediaWhereInput | ProductMediaWhereInput[]
    OR?: ProductMediaWhereInput[]
    NOT?: ProductMediaWhereInput | ProductMediaWhereInput[]
    productId?: UuidFilter<"ProductMedia"> | string
    url?: StringFilter<"ProductMedia"> | string
    mimeType?: StringFilter<"ProductMedia"> | string
    width?: IntNullableFilter<"ProductMedia"> | number | null
    height?: IntNullableFilter<"ProductMedia"> | number | null
    sizeBytes?: IntFilter<"ProductMedia"> | number
    orderIndex?: IntFilter<"ProductMedia"> | number
    isCover?: BoolFilter<"ProductMedia"> | boolean
    createdAt?: DateTimeFilter<"ProductMedia"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id">

  export type ProductMediaOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    sizeBytes?: SortOrder
    orderIndex?: SortOrder
    isCover?: SortOrder
    createdAt?: SortOrder
    _count?: ProductMediaCountOrderByAggregateInput
    _avg?: ProductMediaAvgOrderByAggregateInput
    _max?: ProductMediaMaxOrderByAggregateInput
    _min?: ProductMediaMinOrderByAggregateInput
    _sum?: ProductMediaSumOrderByAggregateInput
  }

  export type ProductMediaScalarWhereWithAggregatesInput = {
    AND?: ProductMediaScalarWhereWithAggregatesInput | ProductMediaScalarWhereWithAggregatesInput[]
    OR?: ProductMediaScalarWhereWithAggregatesInput[]
    NOT?: ProductMediaScalarWhereWithAggregatesInput | ProductMediaScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProductMedia"> | string
    productId?: UuidWithAggregatesFilter<"ProductMedia"> | string
    url?: StringWithAggregatesFilter<"ProductMedia"> | string
    mimeType?: StringWithAggregatesFilter<"ProductMedia"> | string
    width?: IntNullableWithAggregatesFilter<"ProductMedia"> | number | null
    height?: IntNullableWithAggregatesFilter<"ProductMedia"> | number | null
    sizeBytes?: IntWithAggregatesFilter<"ProductMedia"> | number
    orderIndex?: IntWithAggregatesFilter<"ProductMedia"> | number
    isCover?: BoolWithAggregatesFilter<"ProductMedia"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProductMedia"> | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProfileSettingsCreateInput = {
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutSettingsInput
  }

  export type ProfileSettingsUncheckedCreateInput = {
    profileId: string
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileSettingsUpdateInput = {
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type ProfileSettingsUncheckedUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileSettingsCreateManyInput = {
    profileId: string
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileSettingsUpdateManyMutationInput = {
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileSettingsUncheckedUpdateManyInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendRequestCreateInput = {
    id?: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    requester: ProfileCreateNestedOneWithoutSentFriendRequestsInput
    addressee: ProfileCreateNestedOneWithoutReceivedFriendRequestsInput
  }

  export type FriendRequestUncheckedCreateInput = {
    id?: string
    requesterId: string
    addresseeId: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
  }

  export type FriendRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    requester?: ProfileUpdateOneRequiredWithoutSentFriendRequestsNestedInput
    addressee?: ProfileUpdateOneRequiredWithoutReceivedFriendRequestsNestedInput
  }

  export type FriendRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type FriendRequestCreateManyInput = {
    id?: string
    requesterId: string
    addresseeId: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type FriendRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FriendRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FriendshipCreateInput = {
    id?: string
    createdAt?: Date | string
    userA: ProfileCreateNestedOneWithoutFriendshipsAInput
    userB: ProfileCreateNestedOneWithoutFriendshipsBInput
  }

  export type FriendshipUncheckedCreateInput = {
    id?: string
    userAId: string
    userBId: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: ProfileUpdateOneRequiredWithoutFriendshipsANestedInput
    userB?: ProfileUpdateOneRequiredWithoutFriendshipsBNestedInput
  }

  export type FriendshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipCreateManyInput = {
    id?: string
    userAId: string
    userBId: string
    createdAt?: Date | string
  }

  export type FriendshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClanCreateInput = {
    id?: string
    name: string
    members?: ProfileClanCreateNestedManyWithoutClanInput
  }

  export type ClanUncheckedCreateInput = {
    id?: string
    name: string
    members?: ProfileClanUncheckedCreateNestedManyWithoutClanInput
  }

  export type ClanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    members?: ProfileClanUpdateManyWithoutClanNestedInput
  }

  export type ClanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    members?: ProfileClanUncheckedUpdateManyWithoutClanNestedInput
  }

  export type ClanCreateManyInput = {
    id?: string
    name: string
  }

  export type ClanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ClanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileClanCreateInput = {
    id?: string
    order: number
    profile: ProfileCreateNestedOneWithoutClanTreeInput
    clan: ClanCreateNestedOneWithoutMembersInput
  }

  export type ProfileClanUncheckedCreateInput = {
    id?: string
    profileId: string
    clanId: string
    order: number
  }

  export type ProfileClanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    profile?: ProfileUpdateOneRequiredWithoutClanTreeNestedInput
    clan?: ClanUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProfileClanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    clanId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProfileClanCreateManyInput = {
    id?: string
    profileId: string
    clanId: string
    order: number
  }

  export type ProfileClanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProfileClanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    clanId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type LineageCreateInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutLineagesCreatedInput
    memberships?: LineageMembershipCreateNestedManyWithoutLineageInput
    notifications?: NotificationCreateNestedManyWithoutLineageInput
    posts?: PostCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipUncheckedCreateNestedManyWithoutLineageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutLineageInput
    posts?: PostUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutLineagesCreatedNestedInput
    memberships?: LineageMembershipUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUpdateManyWithoutLineageNestedInput
    posts?: PostUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutLineageNestedInput
    posts?: PostUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type LineageCreateManyInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LineageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipCreateInput = {
    id?: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
    addedBy?: ProfileCreateNestedOneWithoutLineageMembershipsAddedInput
    lineage: LineageCreateNestedOneWithoutMembershipsInput
    profile: ProfileCreateNestedOneWithoutLineageMembershipsInput
  }

  export type LineageMembershipUncheckedCreateInput = {
    id?: string
    lineageId: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type LineageMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: ProfileUpdateOneWithoutLineageMembershipsAddedNestedInput
    lineage?: LineageUpdateOneRequiredWithoutMembershipsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutLineageMembershipsNestedInput
  }

  export type LineageMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipCreateManyInput = {
    id?: string
    lineageId: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type LineageMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipCreateInput = {
    id?: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
    profileA: ProfileCreateNestedOneWithoutKinshipsAInput
    profileB: ProfileCreateNestedOneWithoutKinshipsBInput
  }

  export type KinshipUncheckedCreateInput = {
    id?: string
    profileIdA: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileA?: ProfileUpdateOneRequiredWithoutKinshipsANestedInput
    profileB?: ProfileUpdateOneRequiredWithoutKinshipsBNestedInput
  }

  export type KinshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdA?: StringFieldUpdateOperationsInput | string
    profileIdB?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipCreateManyInput = {
    id?: string
    profileIdA: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdA?: StringFieldUpdateOperationsInput | string
    profileIdB?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateInput = {
    id?: string
    createdAt?: Date | string
    blocked: ProfileCreateNestedOneWithoutBlocksAsBlockedInput
    blocker: ProfileCreateNestedOneWithoutBlocksAsBlockerInput
  }

  export type BlockUncheckedCreateInput = {
    id?: string
    blockerId: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocked?: ProfileUpdateOneRequiredWithoutBlocksAsBlockedNestedInput
    blocker?: ProfileUpdateOneRequiredWithoutBlocksAsBlockerNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyInput = {
    id?: string
    blockerId: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteCreateInput = {
    id?: string
    createdAt?: Date | string
    muted: ProfileCreateNestedOneWithoutMutesAsMutedInput
    muter: ProfileCreateNestedOneWithoutMutesAsMuterInput
  }

  export type MuteUncheckedCreateInput = {
    id?: string
    muterId: string
    mutedId: string
    createdAt?: Date | string
  }

  export type MuteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    muted?: ProfileUpdateOneRequiredWithoutMutesAsMutedNestedInput
    muter?: ProfileUpdateOneRequiredWithoutMutesAsMuterNestedInput
  }

  export type MuteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
    mutedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteCreateManyInput = {
    id?: string
    muterId: string
    mutedId: string
    createdAt?: Date | string
  }

  export type MuteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
    mutedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    author: ProfileCreateNestedOneWithoutPostsInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileCreateInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutMediaFilesInput
  }

  export type MediaFileUncheckedCreateInput = {
    id?: string
    postId: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutMediaFilesNestedInput
  }

  export type MediaFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileCreateManyInput = {
    id?: string
    postId: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionCreateInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutReactionsInput
    profile: ProfileCreateNestedOneWithoutPostReactionsInput
  }

  export type PostReactionUncheckedCreateInput = {
    id?: string
    postId: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type PostReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutReactionsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutPostReactionsNestedInput
  }

  export type PostReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionCreateManyInput = {
    id?: string
    postId: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type PostReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionCreateInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutReactionsInput
    profile: ProfileCreateNestedOneWithoutCommentReactionsInput
  }

  export type CommentReactionUncheckedCreateInput = {
    id?: string
    commentId: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutReactionsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutCommentReactionsNestedInput
  }

  export type CommentReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionCreateManyInput = {
    id?: string
    commentId: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutConversationsOwnedInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById?: string | null
    createdAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutConversationsOwnedNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateInput = {
    id?: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    profile: ProfileCreateNestedOneWithoutConversationMembersInput
  }

  export type ConversationParticipantUncheckedCreateInput = {
    id?: string
    conversationId: string
    profileId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutConversationMembersNestedInput
  }

  export type ConversationParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyInput = {
    id?: string
    conversationId: string
    profileId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: ProfileCreateNestedOneWithoutMessagesInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
    notifications?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: ProfileUpdateOneRequiredWithoutMessagesNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    sender?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    request?: FriendRequestCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    request?: FriendRequestUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestCreateInput = {
    id?: string
    name: string
    users?: ProfileInterestCreateNestedManyWithoutInterestInput
  }

  export type InterestUncheckedCreateInput = {
    id?: string
    name: string
    users?: ProfileInterestUncheckedCreateNestedManyWithoutInterestInput
  }

  export type InterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: ProfileInterestUpdateManyWithoutInterestNestedInput
  }

  export type InterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: ProfileInterestUncheckedUpdateManyWithoutInterestNestedInput
  }

  export type InterestCreateManyInput = {
    id?: string
    name: string
  }

  export type InterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AppInterestCreateInput = {
    id?: string
    name: string
    users?: ProfileAppInterestsCreateNestedManyWithoutInterestInput
  }

  export type AppInterestUncheckedCreateInput = {
    id?: string
    name: string
    users?: ProfileAppInterestsUncheckedCreateNestedManyWithoutInterestInput
  }

  export type AppInterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: ProfileAppInterestsUpdateManyWithoutInterestNestedInput
  }

  export type AppInterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: ProfileAppInterestsUncheckedUpdateManyWithoutInterestNestedInput
  }

  export type AppInterestCreateManyInput = {
    id?: string
    name: string
  }

  export type AppInterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AppInterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileInterestCreateInput = {
    createdAt?: Date | string
    interest: InterestCreateNestedOneWithoutUsersInput
    user: ProfileCreateNestedOneWithoutInterestsInput
  }

  export type ProfileInterestUncheckedCreateInput = {
    userId: string
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileInterestUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interest?: InterestUpdateOneRequiredWithoutUsersNestedInput
    user?: ProfileUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type ProfileInterestUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestCreateManyInput = {
    userId: string
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileInterestUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileAppInterestsCreateInput = {
    createdAt?: Date | string
    interest: AppInterestCreateNestedOneWithoutUsersInput
    user: ProfileCreateNestedOneWithoutAppInterestsInput
  }

  export type ProfileAppInterestsUncheckedCreateInput = {
    userId: string
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileAppInterestsUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interest?: AppInterestUpdateOneRequiredWithoutUsersNestedInput
    user?: ProfileUpdateOneRequiredWithoutAppInterestsNestedInput
  }

  export type ProfileAppInterestsUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileAppInterestsCreateManyInput = {
    userId: string
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileAppInterestsUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileAppInterestsUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateInput = {
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadsInput
    user: ProfileCreateNestedOneWithoutMessageReadsInput
  }

  export type MessageReadUncheckedCreateInput = {
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUpdateInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadsNestedInput
    user?: ProfileUpdateOneRequiredWithoutMessageReadsNestedInput
  }

  export type MessageReadUncheckedUpdateInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateManyInput = {
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUpdateManyMutationInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    visibility?: $Enums.PostVisibility
    title: string
    price: number
    currency?: string
    description: string
    category: string
    condition?: $Enums.ProductCondition
    negotiable?: boolean
    availability: $Enums.Available
    status?: $Enums.ListingStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    deletedAt?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    locationText?: string | null
    lat?: number | null
    lng?: number | null
    viewCount?: number
    saveCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: ProfileCreateNestedOneWithoutProductInput
    media?: ProductMediaCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    sellerId: string
    visibility?: $Enums.PostVisibility
    title: string
    price: number
    currency?: string
    description: string
    category: string
    condition?: $Enums.ProductCondition
    negotiable?: boolean
    availability: $Enums.Available
    status?: $Enums.ListingStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    deletedAt?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    locationText?: string | null
    lat?: number | null
    lng?: number | null
    viewCount?: number
    saveCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ProductMediaUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    negotiable?: BoolFieldUpdateOperationsInput | boolean
    availability?: EnumAvailableFieldUpdateOperationsInput | $Enums.Available
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    saveCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: ProfileUpdateOneRequiredWithoutProductNestedInput
    media?: ProductMediaUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    negotiable?: BoolFieldUpdateOperationsInput | boolean
    availability?: EnumAvailableFieldUpdateOperationsInput | $Enums.Available
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    saveCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ProductMediaUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    sellerId: string
    visibility?: $Enums.PostVisibility
    title: string
    price: number
    currency?: string
    description: string
    category: string
    condition?: $Enums.ProductCondition
    negotiable?: boolean
    availability: $Enums.Available
    status?: $Enums.ListingStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    deletedAt?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    locationText?: string | null
    lat?: number | null
    lng?: number | null
    viewCount?: number
    saveCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    negotiable?: BoolFieldUpdateOperationsInput | boolean
    availability?: EnumAvailableFieldUpdateOperationsInput | $Enums.Available
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    saveCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    negotiable?: BoolFieldUpdateOperationsInput | boolean
    availability?: EnumAvailableFieldUpdateOperationsInput | $Enums.Available
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    saveCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMediaCreateInput = {
    id?: string
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    orderIndex?: number
    isCover?: boolean
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutMediaInput
  }

  export type ProductMediaUncheckedCreateInput = {
    id?: string
    productId: string
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    orderIndex?: number
    isCover?: boolean
    createdAt?: Date | string
  }

  export type ProductMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    isCover?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutMediaNestedInput
  }

  export type ProductMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    isCover?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMediaCreateManyInput = {
    id?: string
    productId: string
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    orderIndex?: number
    isCover?: boolean
    createdAt?: Date | string
  }

  export type ProductMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    isCover?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    isCover?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BlockListRelationFilter = {
    every?: BlockWhereInput
    some?: BlockWhereInput
    none?: BlockWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type CommentReactionListRelationFilter = {
    every?: CommentReactionWhereInput
    some?: CommentReactionWhereInput
    none?: CommentReactionWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type ConversationParticipantListRelationFilter = {
    every?: ConversationParticipantWhereInput
    some?: ConversationParticipantWhereInput
    none?: ConversationParticipantWhereInput
  }

  export type ProfileClanListRelationFilter = {
    every?: ProfileClanWhereInput
    some?: ProfileClanWhereInput
    none?: ProfileClanWhereInput
  }

  export type KinshipListRelationFilter = {
    every?: KinshipWhereInput
    some?: KinshipWhereInput
    none?: KinshipWhereInput
  }

  export type LineageListRelationFilter = {
    every?: LineageWhereInput
    some?: LineageWhereInput
    none?: LineageWhereInput
  }

  export type LineageMembershipListRelationFilter = {
    every?: LineageMembershipWhereInput
    some?: LineageMembershipWhereInput
    none?: LineageMembershipWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageReadListRelationFilter = {
    every?: MessageReadWhereInput
    some?: MessageReadWhereInput
    none?: MessageReadWhereInput
  }

  export type MuteListRelationFilter = {
    every?: MuteWhereInput
    some?: MuteWhereInput
    none?: MuteWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type PostReactionListRelationFilter = {
    every?: PostReactionWhereInput
    some?: PostReactionWhereInput
    none?: PostReactionWhereInput
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProfileInterestListRelationFilter = {
    every?: ProfileInterestWhereInput
    some?: ProfileInterestWhereInput
    none?: ProfileInterestWhereInput
  }

  export type ProfileAppInterestsListRelationFilter = {
    every?: ProfileAppInterestsWhereInput
    some?: ProfileAppInterestsWhereInput
    none?: ProfileAppInterestsWhereInput
  }

  export type ProfileSettingsNullableScalarRelationFilter = {
    is?: ProfileSettingsWhereInput | null
    isNot?: ProfileSettingsWhereInput | null
  }

  export type FriendRequestListRelationFilter = {
    every?: FriendRequestWhereInput
    some?: FriendRequestWhereInput
    none?: FriendRequestWhereInput
  }

  export type FriendshipListRelationFilter = {
    every?: FriendshipWhereInput
    some?: FriendshipWhereInput
    none?: FriendshipWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileClanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KinshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LineageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LineageMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MuteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileAppInterestsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    email?: SortOrder
    country?: SortOrder
    city?: SortOrder
    district?: SortOrder
    location?: SortOrder
    bio?: SortOrder
    profession?: SortOrder
    countryCode?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    lineageMainSurname?: SortOrder
    lineageRootVillage?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ethnicity?: SortOrder
    occupation?: SortOrder
    isProfileComplete?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    email?: SortOrder
    country?: SortOrder
    city?: SortOrder
    district?: SortOrder
    location?: SortOrder
    bio?: SortOrder
    profession?: SortOrder
    countryCode?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    lineageMainSurname?: SortOrder
    lineageRootVillage?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ethnicity?: SortOrder
    occupation?: SortOrder
    isProfileComplete?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    fullName?: SortOrder
    username?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    email?: SortOrder
    country?: SortOrder
    city?: SortOrder
    district?: SortOrder
    location?: SortOrder
    bio?: SortOrder
    profession?: SortOrder
    countryCode?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    lineageMainSurname?: SortOrder
    lineageRootVillage?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ethnicity?: SortOrder
    occupation?: SortOrder
    isProfileComplete?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type ProfileSettingsCountOrderByAggregateInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSettingsMaxOrderByAggregateInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSettingsMinOrderByAggregateInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFriendRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendRequestStatus | EnumFriendRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendRequestStatusFilter<$PrismaModel> | $Enums.FriendRequestStatus
  }

  export type FriendRequestRequesterIdAddresseeIdCompoundUniqueInput = {
    requesterId: string
    addresseeId: string
  }

  export type FriendRequestCountOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type FriendRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type FriendRequestMinOrderByAggregateInput = {
    id?: SortOrder
    requesterId?: SortOrder
    addresseeId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type EnumFriendRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendRequestStatus | EnumFriendRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendRequestStatusFilter<$PrismaModel>
  }

  export type FriendshipUserAIdUserBIdCompoundUniqueInput = {
    userAId: string
    userBId: string
  }

  export type FriendshipCountOrderByAggregateInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMaxOrderByAggregateInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    createdAt?: SortOrder
  }

  export type FriendshipMinOrderByAggregateInput = {
    id?: SortOrder
    userAId?: SortOrder
    userBId?: SortOrder
    createdAt?: SortOrder
  }

  export type ClanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ClanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type ClanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ClanScalarRelationFilter = {
    is?: ClanWhereInput
    isNot?: ClanWhereInput
  }

  export type ProfileClanProfileIdOrderCompoundUniqueInput = {
    profileId: string
    order: number
  }

  export type ProfileClanCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    clanId?: SortOrder
    order?: SortOrder
  }

  export type ProfileClanAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ProfileClanMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    clanId?: SortOrder
    order?: SortOrder
  }

  export type ProfileClanMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    clanId?: SortOrder
    order?: SortOrder
  }

  export type ProfileClanSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumLineageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageType | EnumLineageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageTypeFilter<$PrismaModel> | $Enums.LineageType
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type LineageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrder
    rootVillage?: SortOrder
    rootRegion?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LineageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrder
    rootVillage?: SortOrder
    rootRegion?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LineageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrder
    rootVillage?: SortOrder
    rootRegion?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLineageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageType | EnumLineageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageTypeWithAggregatesFilter<$PrismaModel> | $Enums.LineageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLineageTypeFilter<$PrismaModel>
    _max?: NestedEnumLineageTypeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumLineageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageRole | EnumLineageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageRoleFilter<$PrismaModel> | $Enums.LineageRole
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LineageScalarRelationFilter = {
    is?: LineageWhereInput
    isNot?: LineageWhereInput
  }

  export type LineageMembershipLineageIdProfileIdCompoundUniqueInput = {
    lineageId: string
    profileId: string
  }

  export type LineageMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LineageMembershipAvgOrderByAggregateInput = {
    generation?: SortOrder
  }

  export type LineageMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LineageMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LineageMembershipSumOrderByAggregateInput = {
    generation?: SortOrder
  }

  export type EnumLineageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageRole | EnumLineageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageRoleWithAggregatesFilter<$PrismaModel> | $Enums.LineageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLineageRoleFilter<$PrismaModel>
    _max?: NestedEnumLineageRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumKinshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KinshipType | EnumKinshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKinshipTypeFilter<$PrismaModel> | $Enums.KinshipType
  }

  export type KinshipProfileIdAProfileIdBRelationAtoBCompoundUniqueInput = {
    profileIdA: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
  }

  export type KinshipCountOrderByAggregateInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
  }

  export type KinshipMaxOrderByAggregateInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
  }

  export type KinshipMinOrderByAggregateInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumKinshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KinshipType | EnumKinshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKinshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.KinshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKinshipTypeFilter<$PrismaModel>
    _max?: NestedEnumKinshipTypeFilter<$PrismaModel>
  }

  export type BlockBlockerIdBlockedIdCompoundUniqueInput = {
    blockerId: string
    blockedId: string
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type MuteMuterIdMutedIdCompoundUniqueInput = {
    muterId: string
    mutedId: string
  }

  export type MuteCountOrderByAggregateInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
  }

  export type MuteMaxOrderByAggregateInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
  }

  export type MuteMinOrderByAggregateInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type MediaFileListRelationFilter = {
    every?: MediaFileWhereInput
    some?: MediaFileWhereInput
    none?: MediaFileWhereInput
  }

  export type LineageNullableScalarRelationFilter = {
    is?: LineageWhereInput | null
    isNot?: LineageWhereInput | null
  }

  export type MediaFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrder
    visibility?: SortOrder
    locationText?: SortOrder
    lineageId?: SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrder
    visibility?: SortOrder
    locationText?: SortOrder
    lineageId?: SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrder
    visibility?: SortOrder
    locationText?: SortOrder
    lineageId?: SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
  }

  export type EnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type MediaFileCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaFileAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
  }

  export type MediaFileMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaFileMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaFileSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    likeCount?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    likeCount?: SortOrder
  }

  export type EnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type PostReactionPostIdProfileIdCompoundUniqueInput = {
    postId: string
    profileId: string
  }

  export type PostReactionCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PostReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PostReactionMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentReactionCommentIdProfileIdCompoundUniqueInput = {
    commentId: string
    profileId: string
  }

  export type CommentReactionCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentReactionMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ConversationParticipantConversationIdProfileIdCompoundUniqueInput = {
    conversationId: string
    profileId: string
  }

  export type ConversationParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type FriendRequestNullableScalarRelationFilter = {
    is?: FriendRequestWhereInput | null
    isNot?: FriendRequestWhereInput | null
  }

  export type MessageNullableScalarRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type PostNullableScalarRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    requestId?: SortOrder
    lineageId?: SortOrder
    messageId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    requestId?: SortOrder
    lineageId?: SortOrder
    messageId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    senderId?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    requestId?: SortOrder
    lineageId?: SortOrder
    messageId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type InterestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type InterestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type InterestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AppInterestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AppInterestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type AppInterestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type InterestScalarRelationFilter = {
    is?: InterestWhereInput
    isNot?: InterestWhereInput
  }

  export type ProfileInterestUserIdInterestIdCompoundUniqueInput = {
    userId: string
    interestId: string
  }

  export type ProfileInterestCountOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileInterestMaxOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileInterestMinOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
  }

  export type AppInterestScalarRelationFilter = {
    is?: AppInterestWhereInput
    isNot?: AppInterestWhereInput
  }

  export type ProfileAppInterestsUserIdInterestIdCompoundUniqueInput = {
    userId: string
    interestId: string
  }

  export type ProfileAppInterestsCountOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileAppInterestsMaxOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileAppInterestsMinOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageReadMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageReadCountOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadMaxOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadMinOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type EnumProductConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCondition | EnumProductConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumProductConditionFilter<$PrismaModel> | $Enums.ProductCondition
  }

  export type EnumAvailableFilter<$PrismaModel = never> = {
    equals?: $Enums.Available | EnumAvailableFieldRefInput<$PrismaModel>
    in?: $Enums.Available[] | ListEnumAvailableFieldRefInput<$PrismaModel>
    notIn?: $Enums.Available[] | ListEnumAvailableFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailableFilter<$PrismaModel> | $Enums.Available
  }

  export type EnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductMediaListRelationFilter = {
    every?: ProductMediaWhereInput
    some?: ProductMediaWhereInput
    none?: ProductMediaWhereInput
  }

  export type ProductMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    visibility?: SortOrder
    title?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    negotiable?: SortOrder
    availability?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    expiresAt?: SortOrder
    deletedAt?: SortOrder
    country?: SortOrder
    city?: SortOrder
    district?: SortOrder
    locationText?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    viewCount?: SortOrder
    saveCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    viewCount?: SortOrder
    saveCount?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    visibility?: SortOrder
    title?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    negotiable?: SortOrder
    availability?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    expiresAt?: SortOrder
    deletedAt?: SortOrder
    country?: SortOrder
    city?: SortOrder
    district?: SortOrder
    locationText?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    viewCount?: SortOrder
    saveCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    sellerId?: SortOrder
    visibility?: SortOrder
    title?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    category?: SortOrder
    condition?: SortOrder
    negotiable?: SortOrder
    availability?: SortOrder
    status?: SortOrder
    publishedAt?: SortOrder
    expiresAt?: SortOrder
    deletedAt?: SortOrder
    country?: SortOrder
    city?: SortOrder
    district?: SortOrder
    locationText?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    viewCount?: SortOrder
    saveCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    lat?: SortOrder
    lng?: SortOrder
    viewCount?: SortOrder
    saveCount?: SortOrder
  }

  export type EnumProductConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCondition | EnumProductConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumProductConditionWithAggregatesFilter<$PrismaModel> | $Enums.ProductCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductConditionFilter<$PrismaModel>
    _max?: NestedEnumProductConditionFilter<$PrismaModel>
  }

  export type EnumAvailableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Available | EnumAvailableFieldRefInput<$PrismaModel>
    in?: $Enums.Available[] | ListEnumAvailableFieldRefInput<$PrismaModel>
    notIn?: $Enums.Available[] | ListEnumAvailableFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailableWithAggregatesFilter<$PrismaModel> | $Enums.Available
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailableFilter<$PrismaModel>
    _max?: NestedEnumAvailableFilter<$PrismaModel>
  }

  export type EnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductMediaCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    orderIndex?: SortOrder
    isCover?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMediaAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    orderIndex?: SortOrder
  }

  export type ProductMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    orderIndex?: SortOrder
    isCover?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMediaMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    orderIndex?: SortOrder
    isCover?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMediaSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    orderIndex?: SortOrder
  }

  export type BlockCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentReactionCreateNestedManyWithoutProfileInput = {
    create?: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput> | CommentReactionCreateWithoutProfileInput[] | CommentReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutProfileInput | CommentReactionCreateOrConnectWithoutProfileInput[]
    createMany?: CommentReactionCreateManyProfileInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutProfileInput = {
    create?: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput> | ConversationParticipantCreateWithoutProfileInput[] | ConversationParticipantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutProfileInput | ConversationParticipantCreateOrConnectWithoutProfileInput[]
    createMany?: ConversationParticipantCreateManyProfileInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type ProfileClanCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileClanCreateWithoutProfileInput, ProfileClanUncheckedCreateWithoutProfileInput> | ProfileClanCreateWithoutProfileInput[] | ProfileClanUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileClanCreateOrConnectWithoutProfileInput | ProfileClanCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileClanCreateManyProfileInputEnvelope
    connect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
  }

  export type KinshipCreateNestedManyWithoutProfileAInput = {
    create?: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput> | KinshipCreateWithoutProfileAInput[] | KinshipUncheckedCreateWithoutProfileAInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileAInput | KinshipCreateOrConnectWithoutProfileAInput[]
    createMany?: KinshipCreateManyProfileAInputEnvelope
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
  }

  export type KinshipCreateNestedManyWithoutProfileBInput = {
    create?: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput> | KinshipCreateWithoutProfileBInput[] | KinshipUncheckedCreateWithoutProfileBInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileBInput | KinshipCreateOrConnectWithoutProfileBInput[]
    createMany?: KinshipCreateManyProfileBInputEnvelope
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
  }

  export type LineageCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput> | LineageCreateWithoutCreatedByInput[] | LineageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LineageCreateOrConnectWithoutCreatedByInput | LineageCreateOrConnectWithoutCreatedByInput[]
    createMany?: LineageCreateManyCreatedByInputEnvelope
    connect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
  }

  export type LineageMembershipCreateNestedManyWithoutAddedByInput = {
    create?: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput> | LineageMembershipCreateWithoutAddedByInput[] | LineageMembershipUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutAddedByInput | LineageMembershipCreateOrConnectWithoutAddedByInput[]
    createMany?: LineageMembershipCreateManyAddedByInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type LineageMembershipCreateNestedManyWithoutProfileInput = {
    create?: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput> | LineageMembershipCreateWithoutProfileInput[] | LineageMembershipUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutProfileInput | LineageMembershipCreateOrConnectWithoutProfileInput[]
    createMany?: LineageMembershipCreateManyProfileInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageReadCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type MuteCreateNestedManyWithoutMutedInput = {
    create?: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput> | MuteCreateWithoutMutedInput[] | MuteUncheckedCreateWithoutMutedInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMutedInput | MuteCreateOrConnectWithoutMutedInput[]
    createMany?: MuteCreateManyMutedInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type MuteCreateNestedManyWithoutMuterInput = {
    create?: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput> | MuteCreateWithoutMuterInput[] | MuteUncheckedCreateWithoutMuterInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMuterInput | MuteCreateOrConnectWithoutMuterInput[]
    createMany?: MuteCreateManyMuterInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostReactionCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput> | PostReactionCreateWithoutProfileInput[] | PostReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutProfileInput | PostReactionCreateOrConnectWithoutProfileInput[]
    createMany?: PostReactionCreateManyProfileInputEnvelope
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutSellerInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProfileInterestCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput> | ProfileInterestCreateWithoutUserInput[] | ProfileInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutUserInput | ProfileInterestCreateOrConnectWithoutUserInput[]
    createMany?: ProfileInterestCreateManyUserInputEnvelope
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
  }

  export type ProfileAppInterestsCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileAppInterestsCreateWithoutUserInput, ProfileAppInterestsUncheckedCreateWithoutUserInput> | ProfileAppInterestsCreateWithoutUserInput[] | ProfileAppInterestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileAppInterestsCreateOrConnectWithoutUserInput | ProfileAppInterestsCreateOrConnectWithoutUserInput[]
    createMany?: ProfileAppInterestsCreateManyUserInputEnvelope
    connect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
  }

  export type ProfileSettingsCreateNestedOneWithoutProfileInput = {
    create?: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileSettingsCreateOrConnectWithoutProfileInput
    connect?: ProfileSettingsWhereUniqueInput
  }

  export type FriendRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<FriendRequestCreateWithoutRequesterInput, FriendRequestUncheckedCreateWithoutRequesterInput> | FriendRequestCreateWithoutRequesterInput[] | FriendRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FriendRequestCreateOrConnectWithoutRequesterInput | FriendRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: FriendRequestCreateManyRequesterInputEnvelope
    connect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
  }

  export type FriendRequestCreateNestedManyWithoutAddresseeInput = {
    create?: XOR<FriendRequestCreateWithoutAddresseeInput, FriendRequestUncheckedCreateWithoutAddresseeInput> | FriendRequestCreateWithoutAddresseeInput[] | FriendRequestUncheckedCreateWithoutAddresseeInput[]
    connectOrCreate?: FriendRequestCreateOrConnectWithoutAddresseeInput | FriendRequestCreateOrConnectWithoutAddresseeInput[]
    createMany?: FriendRequestCreateManyAddresseeInputEnvelope
    connect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutUserAInput = {
    create?: XOR<FriendshipCreateWithoutUserAInput, FriendshipUncheckedCreateWithoutUserAInput> | FriendshipCreateWithoutUserAInput[] | FriendshipUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserAInput | FriendshipCreateOrConnectWithoutUserAInput[]
    createMany?: FriendshipCreateManyUserAInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipCreateNestedManyWithoutUserBInput = {
    create?: XOR<FriendshipCreateWithoutUserBInput, FriendshipUncheckedCreateWithoutUserBInput> | FriendshipCreateWithoutUserBInput[] | FriendshipUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserBInput | FriendshipCreateOrConnectWithoutUserBInput[]
    createMany?: FriendshipCreateManyUserBInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentReactionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput> | CommentReactionCreateWithoutProfileInput[] | CommentReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutProfileInput | CommentReactionCreateOrConnectWithoutProfileInput[]
    createMany?: CommentReactionCreateManyProfileInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput> | ConversationParticipantCreateWithoutProfileInput[] | ConversationParticipantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutProfileInput | ConversationParticipantCreateOrConnectWithoutProfileInput[]
    createMany?: ConversationParticipantCreateManyProfileInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type ProfileClanUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ProfileClanCreateWithoutProfileInput, ProfileClanUncheckedCreateWithoutProfileInput> | ProfileClanCreateWithoutProfileInput[] | ProfileClanUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileClanCreateOrConnectWithoutProfileInput | ProfileClanCreateOrConnectWithoutProfileInput[]
    createMany?: ProfileClanCreateManyProfileInputEnvelope
    connect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
  }

  export type KinshipUncheckedCreateNestedManyWithoutProfileAInput = {
    create?: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput> | KinshipCreateWithoutProfileAInput[] | KinshipUncheckedCreateWithoutProfileAInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileAInput | KinshipCreateOrConnectWithoutProfileAInput[]
    createMany?: KinshipCreateManyProfileAInputEnvelope
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
  }

  export type KinshipUncheckedCreateNestedManyWithoutProfileBInput = {
    create?: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput> | KinshipCreateWithoutProfileBInput[] | KinshipUncheckedCreateWithoutProfileBInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileBInput | KinshipCreateOrConnectWithoutProfileBInput[]
    createMany?: KinshipCreateManyProfileBInputEnvelope
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
  }

  export type LineageUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput> | LineageCreateWithoutCreatedByInput[] | LineageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LineageCreateOrConnectWithoutCreatedByInput | LineageCreateOrConnectWithoutCreatedByInput[]
    createMany?: LineageCreateManyCreatedByInputEnvelope
    connect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
  }

  export type LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput> | LineageMembershipCreateWithoutAddedByInput[] | LineageMembershipUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutAddedByInput | LineageMembershipCreateOrConnectWithoutAddedByInput[]
    createMany?: LineageMembershipCreateManyAddedByInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type LineageMembershipUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput> | LineageMembershipCreateWithoutProfileInput[] | LineageMembershipUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutProfileInput | LineageMembershipCreateOrConnectWithoutProfileInput[]
    createMany?: LineageMembershipCreateManyProfileInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageReadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type MuteUncheckedCreateNestedManyWithoutMutedInput = {
    create?: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput> | MuteCreateWithoutMutedInput[] | MuteUncheckedCreateWithoutMutedInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMutedInput | MuteCreateOrConnectWithoutMutedInput[]
    createMany?: MuteCreateManyMutedInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type MuteUncheckedCreateNestedManyWithoutMuterInput = {
    create?: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput> | MuteCreateWithoutMuterInput[] | MuteUncheckedCreateWithoutMuterInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMuterInput | MuteCreateOrConnectWithoutMuterInput[]
    createMany?: MuteCreateManyMuterInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type PostReactionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput> | PostReactionCreateWithoutProfileInput[] | PostReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutProfileInput | PostReactionCreateOrConnectWithoutProfileInput[]
    createMany?: PostReactionCreateManyProfileInputEnvelope
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProfileInterestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput> | ProfileInterestCreateWithoutUserInput[] | ProfileInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutUserInput | ProfileInterestCreateOrConnectWithoutUserInput[]
    createMany?: ProfileInterestCreateManyUserInputEnvelope
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
  }

  export type ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileAppInterestsCreateWithoutUserInput, ProfileAppInterestsUncheckedCreateWithoutUserInput> | ProfileAppInterestsCreateWithoutUserInput[] | ProfileAppInterestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileAppInterestsCreateOrConnectWithoutUserInput | ProfileAppInterestsCreateOrConnectWithoutUserInput[]
    createMany?: ProfileAppInterestsCreateManyUserInputEnvelope
    connect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
  }

  export type ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileSettingsCreateOrConnectWithoutProfileInput
    connect?: ProfileSettingsWhereUniqueInput
  }

  export type FriendRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<FriendRequestCreateWithoutRequesterInput, FriendRequestUncheckedCreateWithoutRequesterInput> | FriendRequestCreateWithoutRequesterInput[] | FriendRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FriendRequestCreateOrConnectWithoutRequesterInput | FriendRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: FriendRequestCreateManyRequesterInputEnvelope
    connect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
  }

  export type FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput = {
    create?: XOR<FriendRequestCreateWithoutAddresseeInput, FriendRequestUncheckedCreateWithoutAddresseeInput> | FriendRequestCreateWithoutAddresseeInput[] | FriendRequestUncheckedCreateWithoutAddresseeInput[]
    connectOrCreate?: FriendRequestCreateOrConnectWithoutAddresseeInput | FriendRequestCreateOrConnectWithoutAddresseeInput[]
    createMany?: FriendRequestCreateManyAddresseeInputEnvelope
    connect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutUserAInput = {
    create?: XOR<FriendshipCreateWithoutUserAInput, FriendshipUncheckedCreateWithoutUserAInput> | FriendshipCreateWithoutUserAInput[] | FriendshipUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserAInput | FriendshipCreateOrConnectWithoutUserAInput[]
    createMany?: FriendshipCreateManyUserAInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type FriendshipUncheckedCreateNestedManyWithoutUserBInput = {
    create?: XOR<FriendshipCreateWithoutUserBInput, FriendshipUncheckedCreateWithoutUserBInput> | FriendshipCreateWithoutUserBInput[] | FriendshipUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserBInput | FriendshipCreateOrConnectWithoutUserBInput[]
    createMany?: FriendshipCreateManyUserBInputEnvelope
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BlockUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedInput | BlockUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedInput | BlockUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedInput | BlockUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentReactionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput> | CommentReactionCreateWithoutProfileInput[] | CommentReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutProfileInput | CommentReactionCreateOrConnectWithoutProfileInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutProfileInput | CommentReactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CommentReactionCreateManyProfileInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutProfileInput | CommentReactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutProfileInput | CommentReactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutCreatedByInput | ConversationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutCreatedByInput | ConversationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutCreatedByInput | ConversationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput> | ConversationParticipantCreateWithoutProfileInput[] | ConversationParticipantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutProfileInput | ConversationParticipantCreateOrConnectWithoutProfileInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput | ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ConversationParticipantCreateManyProfileInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput | ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutProfileInput | ConversationParticipantUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type ProfileClanUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileClanCreateWithoutProfileInput, ProfileClanUncheckedCreateWithoutProfileInput> | ProfileClanCreateWithoutProfileInput[] | ProfileClanUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileClanCreateOrConnectWithoutProfileInput | ProfileClanCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileClanUpsertWithWhereUniqueWithoutProfileInput | ProfileClanUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileClanCreateManyProfileInputEnvelope
    set?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    disconnect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    delete?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    connect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    update?: ProfileClanUpdateWithWhereUniqueWithoutProfileInput | ProfileClanUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileClanUpdateManyWithWhereWithoutProfileInput | ProfileClanUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileClanScalarWhereInput | ProfileClanScalarWhereInput[]
  }

  export type KinshipUpdateManyWithoutProfileANestedInput = {
    create?: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput> | KinshipCreateWithoutProfileAInput[] | KinshipUncheckedCreateWithoutProfileAInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileAInput | KinshipCreateOrConnectWithoutProfileAInput[]
    upsert?: KinshipUpsertWithWhereUniqueWithoutProfileAInput | KinshipUpsertWithWhereUniqueWithoutProfileAInput[]
    createMany?: KinshipCreateManyProfileAInputEnvelope
    set?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    disconnect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    delete?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    update?: KinshipUpdateWithWhereUniqueWithoutProfileAInput | KinshipUpdateWithWhereUniqueWithoutProfileAInput[]
    updateMany?: KinshipUpdateManyWithWhereWithoutProfileAInput | KinshipUpdateManyWithWhereWithoutProfileAInput[]
    deleteMany?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
  }

  export type KinshipUpdateManyWithoutProfileBNestedInput = {
    create?: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput> | KinshipCreateWithoutProfileBInput[] | KinshipUncheckedCreateWithoutProfileBInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileBInput | KinshipCreateOrConnectWithoutProfileBInput[]
    upsert?: KinshipUpsertWithWhereUniqueWithoutProfileBInput | KinshipUpsertWithWhereUniqueWithoutProfileBInput[]
    createMany?: KinshipCreateManyProfileBInputEnvelope
    set?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    disconnect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    delete?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    update?: KinshipUpdateWithWhereUniqueWithoutProfileBInput | KinshipUpdateWithWhereUniqueWithoutProfileBInput[]
    updateMany?: KinshipUpdateManyWithWhereWithoutProfileBInput | KinshipUpdateManyWithWhereWithoutProfileBInput[]
    deleteMany?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
  }

  export type LineageUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput> | LineageCreateWithoutCreatedByInput[] | LineageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LineageCreateOrConnectWithoutCreatedByInput | LineageCreateOrConnectWithoutCreatedByInput[]
    upsert?: LineageUpsertWithWhereUniqueWithoutCreatedByInput | LineageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LineageCreateManyCreatedByInputEnvelope
    set?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    disconnect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    delete?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    connect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    update?: LineageUpdateWithWhereUniqueWithoutCreatedByInput | LineageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LineageUpdateManyWithWhereWithoutCreatedByInput | LineageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LineageScalarWhereInput | LineageScalarWhereInput[]
  }

  export type LineageMembershipUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput> | LineageMembershipCreateWithoutAddedByInput[] | LineageMembershipUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutAddedByInput | LineageMembershipCreateOrConnectWithoutAddedByInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput | LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: LineageMembershipCreateManyAddedByInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput | LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutAddedByInput | LineageMembershipUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type LineageMembershipUpdateManyWithoutProfileNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput> | LineageMembershipCreateWithoutProfileInput[] | LineageMembershipUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutProfileInput | LineageMembershipCreateOrConnectWithoutProfileInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutProfileInput | LineageMembershipUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: LineageMembershipCreateManyProfileInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutProfileInput | LineageMembershipUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutProfileInput | LineageMembershipUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageReadUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutUserInput | MessageReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutUserInput | MessageReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutUserInput | MessageReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type MuteUpdateManyWithoutMutedNestedInput = {
    create?: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput> | MuteCreateWithoutMutedInput[] | MuteUncheckedCreateWithoutMutedInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMutedInput | MuteCreateOrConnectWithoutMutedInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutMutedInput | MuteUpsertWithWhereUniqueWithoutMutedInput[]
    createMany?: MuteCreateManyMutedInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutMutedInput | MuteUpdateWithWhereUniqueWithoutMutedInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutMutedInput | MuteUpdateManyWithWhereWithoutMutedInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type MuteUpdateManyWithoutMuterNestedInput = {
    create?: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput> | MuteCreateWithoutMuterInput[] | MuteUncheckedCreateWithoutMuterInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMuterInput | MuteCreateOrConnectWithoutMuterInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutMuterInput | MuteUpsertWithWhereUniqueWithoutMuterInput[]
    createMany?: MuteCreateManyMuterInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutMuterInput | MuteUpdateWithWhereUniqueWithoutMuterInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutMuterInput | MuteUpdateManyWithWhereWithoutMuterInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostReactionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput> | PostReactionCreateWithoutProfileInput[] | PostReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutProfileInput | PostReactionCreateOrConnectWithoutProfileInput[]
    upsert?: PostReactionUpsertWithWhereUniqueWithoutProfileInput | PostReactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostReactionCreateManyProfileInputEnvelope
    set?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    disconnect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    delete?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    update?: PostReactionUpdateWithWhereUniqueWithoutProfileInput | PostReactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostReactionUpdateManyWithWhereWithoutProfileInput | PostReactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSellerInput | ProductUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSellerInput | ProductUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSellerInput | ProductUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProfileInterestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput> | ProfileInterestCreateWithoutUserInput[] | ProfileInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutUserInput | ProfileInterestCreateOrConnectWithoutUserInput[]
    upsert?: ProfileInterestUpsertWithWhereUniqueWithoutUserInput | ProfileInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileInterestCreateManyUserInputEnvelope
    set?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    disconnect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    delete?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    update?: ProfileInterestUpdateWithWhereUniqueWithoutUserInput | ProfileInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileInterestUpdateManyWithWhereWithoutUserInput | ProfileInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
  }

  export type ProfileAppInterestsUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileAppInterestsCreateWithoutUserInput, ProfileAppInterestsUncheckedCreateWithoutUserInput> | ProfileAppInterestsCreateWithoutUserInput[] | ProfileAppInterestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileAppInterestsCreateOrConnectWithoutUserInput | ProfileAppInterestsCreateOrConnectWithoutUserInput[]
    upsert?: ProfileAppInterestsUpsertWithWhereUniqueWithoutUserInput | ProfileAppInterestsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileAppInterestsCreateManyUserInputEnvelope
    set?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    disconnect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    delete?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    connect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    update?: ProfileAppInterestsUpdateWithWhereUniqueWithoutUserInput | ProfileAppInterestsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileAppInterestsUpdateManyWithWhereWithoutUserInput | ProfileAppInterestsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileAppInterestsScalarWhereInput | ProfileAppInterestsScalarWhereInput[]
  }

  export type ProfileSettingsUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileSettingsCreateOrConnectWithoutProfileInput
    upsert?: ProfileSettingsUpsertWithoutProfileInput
    disconnect?: ProfileSettingsWhereInput | boolean
    delete?: ProfileSettingsWhereInput | boolean
    connect?: ProfileSettingsWhereUniqueInput
    update?: XOR<XOR<ProfileSettingsUpdateToOneWithWhereWithoutProfileInput, ProfileSettingsUpdateWithoutProfileInput>, ProfileSettingsUncheckedUpdateWithoutProfileInput>
  }

  export type FriendRequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<FriendRequestCreateWithoutRequesterInput, FriendRequestUncheckedCreateWithoutRequesterInput> | FriendRequestCreateWithoutRequesterInput[] | FriendRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FriendRequestCreateOrConnectWithoutRequesterInput | FriendRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: FriendRequestUpsertWithWhereUniqueWithoutRequesterInput | FriendRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: FriendRequestCreateManyRequesterInputEnvelope
    set?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    disconnect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    delete?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    connect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    update?: FriendRequestUpdateWithWhereUniqueWithoutRequesterInput | FriendRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: FriendRequestUpdateManyWithWhereWithoutRequesterInput | FriendRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: FriendRequestScalarWhereInput | FriendRequestScalarWhereInput[]
  }

  export type FriendRequestUpdateManyWithoutAddresseeNestedInput = {
    create?: XOR<FriendRequestCreateWithoutAddresseeInput, FriendRequestUncheckedCreateWithoutAddresseeInput> | FriendRequestCreateWithoutAddresseeInput[] | FriendRequestUncheckedCreateWithoutAddresseeInput[]
    connectOrCreate?: FriendRequestCreateOrConnectWithoutAddresseeInput | FriendRequestCreateOrConnectWithoutAddresseeInput[]
    upsert?: FriendRequestUpsertWithWhereUniqueWithoutAddresseeInput | FriendRequestUpsertWithWhereUniqueWithoutAddresseeInput[]
    createMany?: FriendRequestCreateManyAddresseeInputEnvelope
    set?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    disconnect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    delete?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    connect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    update?: FriendRequestUpdateWithWhereUniqueWithoutAddresseeInput | FriendRequestUpdateWithWhereUniqueWithoutAddresseeInput[]
    updateMany?: FriendRequestUpdateManyWithWhereWithoutAddresseeInput | FriendRequestUpdateManyWithWhereWithoutAddresseeInput[]
    deleteMany?: FriendRequestScalarWhereInput | FriendRequestScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutUserANestedInput = {
    create?: XOR<FriendshipCreateWithoutUserAInput, FriendshipUncheckedCreateWithoutUserAInput> | FriendshipCreateWithoutUserAInput[] | FriendshipUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserAInput | FriendshipCreateOrConnectWithoutUserAInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserAInput | FriendshipUpsertWithWhereUniqueWithoutUserAInput[]
    createMany?: FriendshipCreateManyUserAInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserAInput | FriendshipUpdateWithWhereUniqueWithoutUserAInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserAInput | FriendshipUpdateManyWithWhereWithoutUserAInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUpdateManyWithoutUserBNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserBInput, FriendshipUncheckedCreateWithoutUserBInput> | FriendshipCreateWithoutUserBInput[] | FriendshipUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserBInput | FriendshipCreateOrConnectWithoutUserBInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserBInput | FriendshipUpsertWithWhereUniqueWithoutUserBInput[]
    createMany?: FriendshipCreateManyUserBInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserBInput | FriendshipUpdateWithWhereUniqueWithoutUserBInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserBInput | FriendshipUpdateManyWithWhereWithoutUserBInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedInput | BlockUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedInput | BlockUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedInput | BlockUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentReactionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput> | CommentReactionCreateWithoutProfileInput[] | CommentReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutProfileInput | CommentReactionCreateOrConnectWithoutProfileInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutProfileInput | CommentReactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CommentReactionCreateManyProfileInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutProfileInput | CommentReactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutProfileInput | CommentReactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutCreatedByInput | ConversationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutCreatedByInput | ConversationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutCreatedByInput | ConversationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput> | ConversationParticipantCreateWithoutProfileInput[] | ConversationParticipantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutProfileInput | ConversationParticipantCreateOrConnectWithoutProfileInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput | ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ConversationParticipantCreateManyProfileInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput | ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutProfileInput | ConversationParticipantUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type ProfileClanUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ProfileClanCreateWithoutProfileInput, ProfileClanUncheckedCreateWithoutProfileInput> | ProfileClanCreateWithoutProfileInput[] | ProfileClanUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ProfileClanCreateOrConnectWithoutProfileInput | ProfileClanCreateOrConnectWithoutProfileInput[]
    upsert?: ProfileClanUpsertWithWhereUniqueWithoutProfileInput | ProfileClanUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ProfileClanCreateManyProfileInputEnvelope
    set?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    disconnect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    delete?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    connect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    update?: ProfileClanUpdateWithWhereUniqueWithoutProfileInput | ProfileClanUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ProfileClanUpdateManyWithWhereWithoutProfileInput | ProfileClanUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ProfileClanScalarWhereInput | ProfileClanScalarWhereInput[]
  }

  export type KinshipUncheckedUpdateManyWithoutProfileANestedInput = {
    create?: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput> | KinshipCreateWithoutProfileAInput[] | KinshipUncheckedCreateWithoutProfileAInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileAInput | KinshipCreateOrConnectWithoutProfileAInput[]
    upsert?: KinshipUpsertWithWhereUniqueWithoutProfileAInput | KinshipUpsertWithWhereUniqueWithoutProfileAInput[]
    createMany?: KinshipCreateManyProfileAInputEnvelope
    set?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    disconnect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    delete?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    update?: KinshipUpdateWithWhereUniqueWithoutProfileAInput | KinshipUpdateWithWhereUniqueWithoutProfileAInput[]
    updateMany?: KinshipUpdateManyWithWhereWithoutProfileAInput | KinshipUpdateManyWithWhereWithoutProfileAInput[]
    deleteMany?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
  }

  export type KinshipUncheckedUpdateManyWithoutProfileBNestedInput = {
    create?: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput> | KinshipCreateWithoutProfileBInput[] | KinshipUncheckedCreateWithoutProfileBInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileBInput | KinshipCreateOrConnectWithoutProfileBInput[]
    upsert?: KinshipUpsertWithWhereUniqueWithoutProfileBInput | KinshipUpsertWithWhereUniqueWithoutProfileBInput[]
    createMany?: KinshipCreateManyProfileBInputEnvelope
    set?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    disconnect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    delete?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    update?: KinshipUpdateWithWhereUniqueWithoutProfileBInput | KinshipUpdateWithWhereUniqueWithoutProfileBInput[]
    updateMany?: KinshipUpdateManyWithWhereWithoutProfileBInput | KinshipUpdateManyWithWhereWithoutProfileBInput[]
    deleteMany?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
  }

  export type LineageUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput> | LineageCreateWithoutCreatedByInput[] | LineageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LineageCreateOrConnectWithoutCreatedByInput | LineageCreateOrConnectWithoutCreatedByInput[]
    upsert?: LineageUpsertWithWhereUniqueWithoutCreatedByInput | LineageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LineageCreateManyCreatedByInputEnvelope
    set?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    disconnect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    delete?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    connect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    update?: LineageUpdateWithWhereUniqueWithoutCreatedByInput | LineageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LineageUpdateManyWithWhereWithoutCreatedByInput | LineageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LineageScalarWhereInput | LineageScalarWhereInput[]
  }

  export type LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput> | LineageMembershipCreateWithoutAddedByInput[] | LineageMembershipUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutAddedByInput | LineageMembershipCreateOrConnectWithoutAddedByInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput | LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: LineageMembershipCreateManyAddedByInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput | LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutAddedByInput | LineageMembershipUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput> | LineageMembershipCreateWithoutProfileInput[] | LineageMembershipUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutProfileInput | LineageMembershipCreateOrConnectWithoutProfileInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutProfileInput | LineageMembershipUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: LineageMembershipCreateManyProfileInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutProfileInput | LineageMembershipUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutProfileInput | LineageMembershipUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageReadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutUserInput | MessageReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutUserInput | MessageReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutUserInput | MessageReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type MuteUncheckedUpdateManyWithoutMutedNestedInput = {
    create?: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput> | MuteCreateWithoutMutedInput[] | MuteUncheckedCreateWithoutMutedInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMutedInput | MuteCreateOrConnectWithoutMutedInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutMutedInput | MuteUpsertWithWhereUniqueWithoutMutedInput[]
    createMany?: MuteCreateManyMutedInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutMutedInput | MuteUpdateWithWhereUniqueWithoutMutedInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutMutedInput | MuteUpdateManyWithWhereWithoutMutedInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type MuteUncheckedUpdateManyWithoutMuterNestedInput = {
    create?: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput> | MuteCreateWithoutMuterInput[] | MuteUncheckedCreateWithoutMuterInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMuterInput | MuteCreateOrConnectWithoutMuterInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutMuterInput | MuteUpsertWithWhereUniqueWithoutMuterInput[]
    createMany?: MuteCreateManyMuterInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutMuterInput | MuteUpdateWithWhereUniqueWithoutMuterInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutMuterInput | MuteUpdateManyWithWhereWithoutMuterInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput> | NotificationCreateWithoutSenderInput[] | NotificationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutSenderInput | NotificationCreateOrConnectWithoutSenderInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutSenderInput | NotificationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: NotificationCreateManySenderInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutSenderInput | NotificationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutSenderInput | NotificationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type PostReactionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput> | PostReactionCreateWithoutProfileInput[] | PostReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutProfileInput | PostReactionCreateOrConnectWithoutProfileInput[]
    upsert?: PostReactionUpsertWithWhereUniqueWithoutProfileInput | PostReactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostReactionCreateManyProfileInputEnvelope
    set?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    disconnect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    delete?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    update?: PostReactionUpdateWithWhereUniqueWithoutProfileInput | PostReactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostReactionUpdateManyWithWhereWithoutProfileInput | PostReactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput> | ProductCreateWithoutSellerInput[] | ProductUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutSellerInput | ProductCreateOrConnectWithoutSellerInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutSellerInput | ProductUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ProductCreateManySellerInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutSellerInput | ProductUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutSellerInput | ProductUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProfileInterestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput> | ProfileInterestCreateWithoutUserInput[] | ProfileInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutUserInput | ProfileInterestCreateOrConnectWithoutUserInput[]
    upsert?: ProfileInterestUpsertWithWhereUniqueWithoutUserInput | ProfileInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileInterestCreateManyUserInputEnvelope
    set?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    disconnect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    delete?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    update?: ProfileInterestUpdateWithWhereUniqueWithoutUserInput | ProfileInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileInterestUpdateManyWithWhereWithoutUserInput | ProfileInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
  }

  export type ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileAppInterestsCreateWithoutUserInput, ProfileAppInterestsUncheckedCreateWithoutUserInput> | ProfileAppInterestsCreateWithoutUserInput[] | ProfileAppInterestsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileAppInterestsCreateOrConnectWithoutUserInput | ProfileAppInterestsCreateOrConnectWithoutUserInput[]
    upsert?: ProfileAppInterestsUpsertWithWhereUniqueWithoutUserInput | ProfileAppInterestsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileAppInterestsCreateManyUserInputEnvelope
    set?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    disconnect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    delete?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    connect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    update?: ProfileAppInterestsUpdateWithWhereUniqueWithoutUserInput | ProfileAppInterestsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileAppInterestsUpdateManyWithWhereWithoutUserInput | ProfileAppInterestsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileAppInterestsScalarWhereInput | ProfileAppInterestsScalarWhereInput[]
  }

  export type ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileSettingsCreateOrConnectWithoutProfileInput
    upsert?: ProfileSettingsUpsertWithoutProfileInput
    disconnect?: ProfileSettingsWhereInput | boolean
    delete?: ProfileSettingsWhereInput | boolean
    connect?: ProfileSettingsWhereUniqueInput
    update?: XOR<XOR<ProfileSettingsUpdateToOneWithWhereWithoutProfileInput, ProfileSettingsUpdateWithoutProfileInput>, ProfileSettingsUncheckedUpdateWithoutProfileInput>
  }

  export type FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<FriendRequestCreateWithoutRequesterInput, FriendRequestUncheckedCreateWithoutRequesterInput> | FriendRequestCreateWithoutRequesterInput[] | FriendRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: FriendRequestCreateOrConnectWithoutRequesterInput | FriendRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: FriendRequestUpsertWithWhereUniqueWithoutRequesterInput | FriendRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: FriendRequestCreateManyRequesterInputEnvelope
    set?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    disconnect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    delete?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    connect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    update?: FriendRequestUpdateWithWhereUniqueWithoutRequesterInput | FriendRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: FriendRequestUpdateManyWithWhereWithoutRequesterInput | FriendRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: FriendRequestScalarWhereInput | FriendRequestScalarWhereInput[]
  }

  export type FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput = {
    create?: XOR<FriendRequestCreateWithoutAddresseeInput, FriendRequestUncheckedCreateWithoutAddresseeInput> | FriendRequestCreateWithoutAddresseeInput[] | FriendRequestUncheckedCreateWithoutAddresseeInput[]
    connectOrCreate?: FriendRequestCreateOrConnectWithoutAddresseeInput | FriendRequestCreateOrConnectWithoutAddresseeInput[]
    upsert?: FriendRequestUpsertWithWhereUniqueWithoutAddresseeInput | FriendRequestUpsertWithWhereUniqueWithoutAddresseeInput[]
    createMany?: FriendRequestCreateManyAddresseeInputEnvelope
    set?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    disconnect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    delete?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    connect?: FriendRequestWhereUniqueInput | FriendRequestWhereUniqueInput[]
    update?: FriendRequestUpdateWithWhereUniqueWithoutAddresseeInput | FriendRequestUpdateWithWhereUniqueWithoutAddresseeInput[]
    updateMany?: FriendRequestUpdateManyWithWhereWithoutAddresseeInput | FriendRequestUpdateManyWithWhereWithoutAddresseeInput[]
    deleteMany?: FriendRequestScalarWhereInput | FriendRequestScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutUserANestedInput = {
    create?: XOR<FriendshipCreateWithoutUserAInput, FriendshipUncheckedCreateWithoutUserAInput> | FriendshipCreateWithoutUserAInput[] | FriendshipUncheckedCreateWithoutUserAInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserAInput | FriendshipCreateOrConnectWithoutUserAInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserAInput | FriendshipUpsertWithWhereUniqueWithoutUserAInput[]
    createMany?: FriendshipCreateManyUserAInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserAInput | FriendshipUpdateWithWhereUniqueWithoutUserAInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserAInput | FriendshipUpdateManyWithWhereWithoutUserAInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type FriendshipUncheckedUpdateManyWithoutUserBNestedInput = {
    create?: XOR<FriendshipCreateWithoutUserBInput, FriendshipUncheckedCreateWithoutUserBInput> | FriendshipCreateWithoutUserBInput[] | FriendshipUncheckedCreateWithoutUserBInput[]
    connectOrCreate?: FriendshipCreateOrConnectWithoutUserBInput | FriendshipCreateOrConnectWithoutUserBInput[]
    upsert?: FriendshipUpsertWithWhereUniqueWithoutUserBInput | FriendshipUpsertWithWhereUniqueWithoutUserBInput[]
    createMany?: FriendshipCreateManyUserBInputEnvelope
    set?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    disconnect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    delete?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    connect?: FriendshipWhereUniqueInput | FriendshipWhereUniqueInput[]
    update?: FriendshipUpdateWithWhereUniqueWithoutUserBInput | FriendshipUpdateWithWhereUniqueWithoutUserBInput[]
    updateMany?: FriendshipUpdateManyWithWhereWithoutUserBInput | FriendshipUpdateManyWithWhereWithoutUserBInput[]
    deleteMany?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutSettingsInput = {
    create?: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSettingsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSettingsInput
    upsert?: ProfileUpsertWithoutSettingsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutSettingsInput, ProfileUpdateWithoutSettingsInput>, ProfileUncheckedUpdateWithoutSettingsInput>
  }

  export type NotificationCreateNestedManyWithoutRequestInput = {
    create?: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput> | NotificationCreateWithoutRequestInput[] | NotificationUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRequestInput | NotificationCreateOrConnectWithoutRequestInput[]
    createMany?: NotificationCreateManyRequestInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ProfileCreateNestedOneWithoutSentFriendRequestsInput = {
    create?: XOR<ProfileCreateWithoutSentFriendRequestsInput, ProfileUncheckedCreateWithoutSentFriendRequestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSentFriendRequestsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutReceivedFriendRequestsInput = {
    create?: XOR<ProfileCreateWithoutReceivedFriendRequestsInput, ProfileUncheckedCreateWithoutReceivedFriendRequestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutReceivedFriendRequestsInput
    connect?: ProfileWhereUniqueInput
  }

  export type NotificationUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput> | NotificationCreateWithoutRequestInput[] | NotificationUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRequestInput | NotificationCreateOrConnectWithoutRequestInput[]
    createMany?: NotificationCreateManyRequestInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumFriendRequestStatusFieldUpdateOperationsInput = {
    set?: $Enums.FriendRequestStatus
  }

  export type NotificationUpdateManyWithoutRequestNestedInput = {
    create?: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput> | NotificationCreateWithoutRequestInput[] | NotificationUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRequestInput | NotificationCreateOrConnectWithoutRequestInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRequestInput | NotificationUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: NotificationCreateManyRequestInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRequestInput | NotificationUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRequestInput | NotificationUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProfileUpdateOneRequiredWithoutSentFriendRequestsNestedInput = {
    create?: XOR<ProfileCreateWithoutSentFriendRequestsInput, ProfileUncheckedCreateWithoutSentFriendRequestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSentFriendRequestsInput
    upsert?: ProfileUpsertWithoutSentFriendRequestsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutSentFriendRequestsInput, ProfileUpdateWithoutSentFriendRequestsInput>, ProfileUncheckedUpdateWithoutSentFriendRequestsInput>
  }

  export type ProfileUpdateOneRequiredWithoutReceivedFriendRequestsNestedInput = {
    create?: XOR<ProfileCreateWithoutReceivedFriendRequestsInput, ProfileUncheckedCreateWithoutReceivedFriendRequestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutReceivedFriendRequestsInput
    upsert?: ProfileUpsertWithoutReceivedFriendRequestsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutReceivedFriendRequestsInput, ProfileUpdateWithoutReceivedFriendRequestsInput>, ProfileUncheckedUpdateWithoutReceivedFriendRequestsInput>
  }

  export type NotificationUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput> | NotificationCreateWithoutRequestInput[] | NotificationUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRequestInput | NotificationCreateOrConnectWithoutRequestInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRequestInput | NotificationUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: NotificationCreateManyRequestInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRequestInput | NotificationUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRequestInput | NotificationUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutFriendshipsAInput = {
    create?: XOR<ProfileCreateWithoutFriendshipsAInput, ProfileUncheckedCreateWithoutFriendshipsAInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFriendshipsAInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutFriendshipsBInput = {
    create?: XOR<ProfileCreateWithoutFriendshipsBInput, ProfileUncheckedCreateWithoutFriendshipsBInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFriendshipsBInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutFriendshipsANestedInput = {
    create?: XOR<ProfileCreateWithoutFriendshipsAInput, ProfileUncheckedCreateWithoutFriendshipsAInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFriendshipsAInput
    upsert?: ProfileUpsertWithoutFriendshipsAInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutFriendshipsAInput, ProfileUpdateWithoutFriendshipsAInput>, ProfileUncheckedUpdateWithoutFriendshipsAInput>
  }

  export type ProfileUpdateOneRequiredWithoutFriendshipsBNestedInput = {
    create?: XOR<ProfileCreateWithoutFriendshipsBInput, ProfileUncheckedCreateWithoutFriendshipsBInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFriendshipsBInput
    upsert?: ProfileUpsertWithoutFriendshipsBInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutFriendshipsBInput, ProfileUpdateWithoutFriendshipsBInput>, ProfileUncheckedUpdateWithoutFriendshipsBInput>
  }

  export type ProfileClanCreateNestedManyWithoutClanInput = {
    create?: XOR<ProfileClanCreateWithoutClanInput, ProfileClanUncheckedCreateWithoutClanInput> | ProfileClanCreateWithoutClanInput[] | ProfileClanUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ProfileClanCreateOrConnectWithoutClanInput | ProfileClanCreateOrConnectWithoutClanInput[]
    createMany?: ProfileClanCreateManyClanInputEnvelope
    connect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
  }

  export type ProfileClanUncheckedCreateNestedManyWithoutClanInput = {
    create?: XOR<ProfileClanCreateWithoutClanInput, ProfileClanUncheckedCreateWithoutClanInput> | ProfileClanCreateWithoutClanInput[] | ProfileClanUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ProfileClanCreateOrConnectWithoutClanInput | ProfileClanCreateOrConnectWithoutClanInput[]
    createMany?: ProfileClanCreateManyClanInputEnvelope
    connect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
  }

  export type ProfileClanUpdateManyWithoutClanNestedInput = {
    create?: XOR<ProfileClanCreateWithoutClanInput, ProfileClanUncheckedCreateWithoutClanInput> | ProfileClanCreateWithoutClanInput[] | ProfileClanUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ProfileClanCreateOrConnectWithoutClanInput | ProfileClanCreateOrConnectWithoutClanInput[]
    upsert?: ProfileClanUpsertWithWhereUniqueWithoutClanInput | ProfileClanUpsertWithWhereUniqueWithoutClanInput[]
    createMany?: ProfileClanCreateManyClanInputEnvelope
    set?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    disconnect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    delete?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    connect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    update?: ProfileClanUpdateWithWhereUniqueWithoutClanInput | ProfileClanUpdateWithWhereUniqueWithoutClanInput[]
    updateMany?: ProfileClanUpdateManyWithWhereWithoutClanInput | ProfileClanUpdateManyWithWhereWithoutClanInput[]
    deleteMany?: ProfileClanScalarWhereInput | ProfileClanScalarWhereInput[]
  }

  export type ProfileClanUncheckedUpdateManyWithoutClanNestedInput = {
    create?: XOR<ProfileClanCreateWithoutClanInput, ProfileClanUncheckedCreateWithoutClanInput> | ProfileClanCreateWithoutClanInput[] | ProfileClanUncheckedCreateWithoutClanInput[]
    connectOrCreate?: ProfileClanCreateOrConnectWithoutClanInput | ProfileClanCreateOrConnectWithoutClanInput[]
    upsert?: ProfileClanUpsertWithWhereUniqueWithoutClanInput | ProfileClanUpsertWithWhereUniqueWithoutClanInput[]
    createMany?: ProfileClanCreateManyClanInputEnvelope
    set?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    disconnect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    delete?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    connect?: ProfileClanWhereUniqueInput | ProfileClanWhereUniqueInput[]
    update?: ProfileClanUpdateWithWhereUniqueWithoutClanInput | ProfileClanUpdateWithWhereUniqueWithoutClanInput[]
    updateMany?: ProfileClanUpdateManyWithWhereWithoutClanInput | ProfileClanUpdateManyWithWhereWithoutClanInput[]
    deleteMany?: ProfileClanScalarWhereInput | ProfileClanScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutClanTreeInput = {
    create?: XOR<ProfileCreateWithoutClanTreeInput, ProfileUncheckedCreateWithoutClanTreeInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutClanTreeInput
    connect?: ProfileWhereUniqueInput
  }

  export type ClanCreateNestedOneWithoutMembersInput = {
    create?: XOR<ClanCreateWithoutMembersInput, ClanUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClanCreateOrConnectWithoutMembersInput
    connect?: ClanWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProfileUpdateOneRequiredWithoutClanTreeNestedInput = {
    create?: XOR<ProfileCreateWithoutClanTreeInput, ProfileUncheckedCreateWithoutClanTreeInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutClanTreeInput
    upsert?: ProfileUpsertWithoutClanTreeInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutClanTreeInput, ProfileUpdateWithoutClanTreeInput>, ProfileUncheckedUpdateWithoutClanTreeInput>
  }

  export type ClanUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<ClanCreateWithoutMembersInput, ClanUncheckedCreateWithoutMembersInput>
    connectOrCreate?: ClanCreateOrConnectWithoutMembersInput
    upsert?: ClanUpsertWithoutMembersInput
    connect?: ClanWhereUniqueInput
    update?: XOR<XOR<ClanUpdateToOneWithWhereWithoutMembersInput, ClanUpdateWithoutMembersInput>, ClanUncheckedUpdateWithoutMembersInput>
  }

  export type ProfileCreateNestedOneWithoutLineagesCreatedInput = {
    create?: XOR<ProfileCreateWithoutLineagesCreatedInput, ProfileUncheckedCreateWithoutLineagesCreatedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineagesCreatedInput
    connect?: ProfileWhereUniqueInput
  }

  export type LineageMembershipCreateNestedManyWithoutLineageInput = {
    create?: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput> | LineageMembershipCreateWithoutLineageInput[] | LineageMembershipUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutLineageInput | LineageMembershipCreateOrConnectWithoutLineageInput[]
    createMany?: LineageMembershipCreateManyLineageInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutLineageInput = {
    create?: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput> | NotificationCreateWithoutLineageInput[] | NotificationUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLineageInput | NotificationCreateOrConnectWithoutLineageInput[]
    createMany?: NotificationCreateManyLineageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutLineageInput = {
    create?: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput> | PostCreateWithoutLineageInput[] | PostUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLineageInput | PostCreateOrConnectWithoutLineageInput[]
    createMany?: PostCreateManyLineageInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type LineageMembershipUncheckedCreateNestedManyWithoutLineageInput = {
    create?: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput> | LineageMembershipCreateWithoutLineageInput[] | LineageMembershipUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutLineageInput | LineageMembershipCreateOrConnectWithoutLineageInput[]
    createMany?: LineageMembershipCreateManyLineageInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutLineageInput = {
    create?: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput> | NotificationCreateWithoutLineageInput[] | NotificationUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLineageInput | NotificationCreateOrConnectWithoutLineageInput[]
    createMany?: NotificationCreateManyLineageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutLineageInput = {
    create?: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput> | PostCreateWithoutLineageInput[] | PostUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLineageInput | PostCreateOrConnectWithoutLineageInput[]
    createMany?: PostCreateManyLineageInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type EnumLineageTypeFieldUpdateOperationsInput = {
    set?: $Enums.LineageType
  }

  export type ProfileUpdateOneWithoutLineagesCreatedNestedInput = {
    create?: XOR<ProfileCreateWithoutLineagesCreatedInput, ProfileUncheckedCreateWithoutLineagesCreatedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineagesCreatedInput
    upsert?: ProfileUpsertWithoutLineagesCreatedInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutLineagesCreatedInput, ProfileUpdateWithoutLineagesCreatedInput>, ProfileUncheckedUpdateWithoutLineagesCreatedInput>
  }

  export type LineageMembershipUpdateManyWithoutLineageNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput> | LineageMembershipCreateWithoutLineageInput[] | LineageMembershipUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutLineageInput | LineageMembershipCreateOrConnectWithoutLineageInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutLineageInput | LineageMembershipUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: LineageMembershipCreateManyLineageInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutLineageInput | LineageMembershipUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutLineageInput | LineageMembershipUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutLineageNestedInput = {
    create?: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput> | NotificationCreateWithoutLineageInput[] | NotificationUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLineageInput | NotificationCreateOrConnectWithoutLineageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutLineageInput | NotificationUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: NotificationCreateManyLineageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutLineageInput | NotificationUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutLineageInput | NotificationUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostUpdateManyWithoutLineageNestedInput = {
    create?: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput> | PostCreateWithoutLineageInput[] | PostUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLineageInput | PostCreateOrConnectWithoutLineageInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutLineageInput | PostUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: PostCreateManyLineageInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutLineageInput | PostUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: PostUpdateManyWithWhereWithoutLineageInput | PostUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput> | LineageMembershipCreateWithoutLineageInput[] | LineageMembershipUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutLineageInput | LineageMembershipCreateOrConnectWithoutLineageInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutLineageInput | LineageMembershipUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: LineageMembershipCreateManyLineageInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutLineageInput | LineageMembershipUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutLineageInput | LineageMembershipUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutLineageNestedInput = {
    create?: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput> | NotificationCreateWithoutLineageInput[] | NotificationUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLineageInput | NotificationCreateOrConnectWithoutLineageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutLineageInput | NotificationUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: NotificationCreateManyLineageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutLineageInput | NotificationUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutLineageInput | NotificationUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutLineageNestedInput = {
    create?: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput> | PostCreateWithoutLineageInput[] | PostUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLineageInput | PostCreateOrConnectWithoutLineageInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutLineageInput | PostUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: PostCreateManyLineageInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutLineageInput | PostUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: PostUpdateManyWithWhereWithoutLineageInput | PostUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutLineageMembershipsAddedInput = {
    create?: XOR<ProfileCreateWithoutLineageMembershipsAddedInput, ProfileUncheckedCreateWithoutLineageMembershipsAddedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineageMembershipsAddedInput
    connect?: ProfileWhereUniqueInput
  }

  export type LineageCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<LineageCreateWithoutMembershipsInput, LineageUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutMembershipsInput
    connect?: LineageWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutLineageMembershipsInput = {
    create?: XOR<ProfileCreateWithoutLineageMembershipsInput, ProfileUncheckedCreateWithoutLineageMembershipsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineageMembershipsInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnumLineageRoleFieldUpdateOperationsInput = {
    set?: $Enums.LineageRole
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProfileUpdateOneWithoutLineageMembershipsAddedNestedInput = {
    create?: XOR<ProfileCreateWithoutLineageMembershipsAddedInput, ProfileUncheckedCreateWithoutLineageMembershipsAddedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineageMembershipsAddedInput
    upsert?: ProfileUpsertWithoutLineageMembershipsAddedInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutLineageMembershipsAddedInput, ProfileUpdateWithoutLineageMembershipsAddedInput>, ProfileUncheckedUpdateWithoutLineageMembershipsAddedInput>
  }

  export type LineageUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<LineageCreateWithoutMembershipsInput, LineageUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutMembershipsInput
    upsert?: LineageUpsertWithoutMembershipsInput
    connect?: LineageWhereUniqueInput
    update?: XOR<XOR<LineageUpdateToOneWithWhereWithoutMembershipsInput, LineageUpdateWithoutMembershipsInput>, LineageUncheckedUpdateWithoutMembershipsInput>
  }

  export type ProfileUpdateOneRequiredWithoutLineageMembershipsNestedInput = {
    create?: XOR<ProfileCreateWithoutLineageMembershipsInput, ProfileUncheckedCreateWithoutLineageMembershipsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineageMembershipsInput
    upsert?: ProfileUpsertWithoutLineageMembershipsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutLineageMembershipsInput, ProfileUpdateWithoutLineageMembershipsInput>, ProfileUncheckedUpdateWithoutLineageMembershipsInput>
  }

  export type ProfileCreateNestedOneWithoutKinshipsAInput = {
    create?: XOR<ProfileCreateWithoutKinshipsAInput, ProfileUncheckedCreateWithoutKinshipsAInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutKinshipsAInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutKinshipsBInput = {
    create?: XOR<ProfileCreateWithoutKinshipsBInput, ProfileUncheckedCreateWithoutKinshipsBInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutKinshipsBInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnumKinshipTypeFieldUpdateOperationsInput = {
    set?: $Enums.KinshipType
  }

  export type ProfileUpdateOneRequiredWithoutKinshipsANestedInput = {
    create?: XOR<ProfileCreateWithoutKinshipsAInput, ProfileUncheckedCreateWithoutKinshipsAInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutKinshipsAInput
    upsert?: ProfileUpsertWithoutKinshipsAInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutKinshipsAInput, ProfileUpdateWithoutKinshipsAInput>, ProfileUncheckedUpdateWithoutKinshipsAInput>
  }

  export type ProfileUpdateOneRequiredWithoutKinshipsBNestedInput = {
    create?: XOR<ProfileCreateWithoutKinshipsBInput, ProfileUncheckedCreateWithoutKinshipsBInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutKinshipsBInput
    upsert?: ProfileUpsertWithoutKinshipsBInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutKinshipsBInput, ProfileUpdateWithoutKinshipsBInput>, ProfileUncheckedUpdateWithoutKinshipsBInput>
  }

  export type ProfileCreateNestedOneWithoutBlocksAsBlockedInput = {
    create?: XOR<ProfileCreateWithoutBlocksAsBlockedInput, ProfileUncheckedCreateWithoutBlocksAsBlockedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlocksAsBlockedInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutBlocksAsBlockerInput = {
    create?: XOR<ProfileCreateWithoutBlocksAsBlockerInput, ProfileUncheckedCreateWithoutBlocksAsBlockerInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlocksAsBlockerInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutBlocksAsBlockedNestedInput = {
    create?: XOR<ProfileCreateWithoutBlocksAsBlockedInput, ProfileUncheckedCreateWithoutBlocksAsBlockedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlocksAsBlockedInput
    upsert?: ProfileUpsertWithoutBlocksAsBlockedInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutBlocksAsBlockedInput, ProfileUpdateWithoutBlocksAsBlockedInput>, ProfileUncheckedUpdateWithoutBlocksAsBlockedInput>
  }

  export type ProfileUpdateOneRequiredWithoutBlocksAsBlockerNestedInput = {
    create?: XOR<ProfileCreateWithoutBlocksAsBlockerInput, ProfileUncheckedCreateWithoutBlocksAsBlockerInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlocksAsBlockerInput
    upsert?: ProfileUpsertWithoutBlocksAsBlockerInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutBlocksAsBlockerInput, ProfileUpdateWithoutBlocksAsBlockerInput>, ProfileUncheckedUpdateWithoutBlocksAsBlockerInput>
  }

  export type ProfileCreateNestedOneWithoutMutesAsMutedInput = {
    create?: XOR<ProfileCreateWithoutMutesAsMutedInput, ProfileUncheckedCreateWithoutMutesAsMutedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMutesAsMutedInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutMutesAsMuterInput = {
    create?: XOR<ProfileCreateWithoutMutesAsMuterInput, ProfileUncheckedCreateWithoutMutesAsMuterInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMutesAsMuterInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutMutesAsMutedNestedInput = {
    create?: XOR<ProfileCreateWithoutMutesAsMutedInput, ProfileUncheckedCreateWithoutMutesAsMutedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMutesAsMutedInput
    upsert?: ProfileUpsertWithoutMutesAsMutedInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMutesAsMutedInput, ProfileUpdateWithoutMutesAsMutedInput>, ProfileUncheckedUpdateWithoutMutesAsMutedInput>
  }

  export type ProfileUpdateOneRequiredWithoutMutesAsMuterNestedInput = {
    create?: XOR<ProfileCreateWithoutMutesAsMuterInput, ProfileUncheckedCreateWithoutMutesAsMuterInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMutesAsMuterInput
    upsert?: ProfileUpsertWithoutMutesAsMuterInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMutesAsMuterInput, ProfileUpdateWithoutMutesAsMuterInput>, ProfileUncheckedUpdateWithoutMutesAsMuterInput>
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MediaFileCreateNestedManyWithoutPostInput = {
    create?: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput> | MediaFileCreateWithoutPostInput[] | MediaFileUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutPostInput | MediaFileCreateOrConnectWithoutPostInput[]
    createMany?: MediaFileCreateManyPostInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutPostInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LineageCreateNestedOneWithoutPostsInput = {
    create?: XOR<LineageCreateWithoutPostsInput, LineageUncheckedCreateWithoutPostsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutPostsInput
    connect?: LineageWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutPostsInput = {
    create?: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostsInput
    connect?: ProfileWhereUniqueInput
  }

  export type PostReactionCreateNestedManyWithoutPostInput = {
    create?: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput> | PostReactionCreateWithoutPostInput[] | PostReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutPostInput | PostReactionCreateOrConnectWithoutPostInput[]
    createMany?: PostReactionCreateManyPostInputEnvelope
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MediaFileUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput> | MediaFileCreateWithoutPostInput[] | MediaFileUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutPostInput | MediaFileCreateOrConnectWithoutPostInput[]
    createMany?: MediaFileCreateManyPostInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PostReactionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput> | PostReactionCreateWithoutPostInput[] | PostReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutPostInput | PostReactionCreateOrConnectWithoutPostInput[]
    createMany?: PostReactionCreateManyPostInputEnvelope
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
  }

  export type EnumPostVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.PostVisibility
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MediaFileUpdateManyWithoutPostNestedInput = {
    create?: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput> | MediaFileCreateWithoutPostInput[] | MediaFileUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutPostInput | MediaFileCreateOrConnectWithoutPostInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutPostInput | MediaFileUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: MediaFileCreateManyPostInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutPostInput | MediaFileUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutPostInput | MediaFileUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutPostNestedInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPostInput | NotificationUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPostInput | NotificationUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPostInput | NotificationUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LineageUpdateOneWithoutPostsNestedInput = {
    create?: XOR<LineageCreateWithoutPostsInput, LineageUncheckedCreateWithoutPostsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutPostsInput
    upsert?: LineageUpsertWithoutPostsInput
    disconnect?: LineageWhereInput | boolean
    delete?: LineageWhereInput | boolean
    connect?: LineageWhereUniqueInput
    update?: XOR<XOR<LineageUpdateToOneWithWhereWithoutPostsInput, LineageUpdateWithoutPostsInput>, LineageUncheckedUpdateWithoutPostsInput>
  }

  export type ProfileUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostsInput
    upsert?: ProfileUpsertWithoutPostsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostsInput, ProfileUpdateWithoutPostsInput>, ProfileUncheckedUpdateWithoutPostsInput>
  }

  export type PostReactionUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput> | PostReactionCreateWithoutPostInput[] | PostReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutPostInput | PostReactionCreateOrConnectWithoutPostInput[]
    upsert?: PostReactionUpsertWithWhereUniqueWithoutPostInput | PostReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostReactionCreateManyPostInputEnvelope
    set?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    disconnect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    delete?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    update?: PostReactionUpdateWithWhereUniqueWithoutPostInput | PostReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostReactionUpdateManyWithWhereWithoutPostInput | PostReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MediaFileUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput> | MediaFileCreateWithoutPostInput[] | MediaFileUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutPostInput | MediaFileCreateOrConnectWithoutPostInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutPostInput | MediaFileUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: MediaFileCreateManyPostInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutPostInput | MediaFileUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutPostInput | MediaFileUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPostInput | NotificationUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPostInput | NotificationUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPostInput | NotificationUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostReactionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput> | PostReactionCreateWithoutPostInput[] | PostReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutPostInput | PostReactionCreateOrConnectWithoutPostInput[]
    upsert?: PostReactionUpsertWithWhereUniqueWithoutPostInput | PostReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostReactionCreateManyPostInputEnvelope
    set?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    disconnect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    delete?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    update?: PostReactionUpdateWithWhereUniqueWithoutPostInput | PostReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostReactionUpdateManyWithWhereWithoutPostInput | PostReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutMediaFilesInput = {
    create?: XOR<PostCreateWithoutMediaFilesInput, PostUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: PostCreateOrConnectWithoutMediaFilesInput
    connect?: PostWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type PostUpdateOneRequiredWithoutMediaFilesNestedInput = {
    create?: XOR<PostCreateWithoutMediaFilesInput, PostUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: PostCreateOrConnectWithoutMediaFilesInput
    upsert?: PostUpsertWithoutMediaFilesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutMediaFilesInput, PostUpdateWithoutMediaFilesInput>, PostUncheckedUpdateWithoutMediaFilesInput>
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ProfileCreateWithoutCommentsInput, ProfileUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCommentsInput
    connect?: ProfileWhereUniqueInput
  }

  export type CommentReactionCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentReactionUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentCommentInput | CommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentCommentInput | CommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentCommentInput | CommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type ProfileUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ProfileCreateWithoutCommentsInput, ProfileUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCommentsInput
    upsert?: ProfileUpsertWithoutCommentsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutCommentsInput, ProfileUpdateWithoutCommentsInput>, ProfileUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentReactionUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutCommentInput | CommentReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutCommentInput | CommentReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutCommentInput | CommentReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCommentInput | NotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCommentInput | NotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCommentInput | NotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentCommentInput | CommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentCommentInput | CommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentCommentInput | CommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentReactionUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutCommentInput | CommentReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutCommentInput | CommentReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutCommentInput | CommentReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCommentInput | NotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCommentInput | NotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCommentInput | NotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutReactionsInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    connect?: PostWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutPostReactionsInput = {
    create?: XOR<ProfileCreateWithoutPostReactionsInput, ProfileUncheckedCreateWithoutPostReactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostReactionsInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType
  }

  export type PostUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    upsert?: PostUpsertWithoutReactionsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReactionsInput, PostUpdateWithoutReactionsInput>, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type ProfileUpdateOneRequiredWithoutPostReactionsNestedInput = {
    create?: XOR<ProfileCreateWithoutPostReactionsInput, ProfileUncheckedCreateWithoutPostReactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostReactionsInput
    upsert?: ProfileUpsertWithoutPostReactionsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostReactionsInput, ProfileUpdateWithoutPostReactionsInput>, ProfileUncheckedUpdateWithoutPostReactionsInput>
  }

  export type CommentCreateNestedOneWithoutReactionsInput = {
    create?: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionsInput
    connect?: CommentWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutCommentReactionsInput = {
    create?: XOR<ProfileCreateWithoutCommentReactionsInput, ProfileUncheckedCreateWithoutCommentReactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCommentReactionsInput
    connect?: ProfileWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionsInput
    upsert?: CommentUpsertWithoutReactionsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutReactionsInput, CommentUpdateWithoutReactionsInput>, CommentUncheckedUpdateWithoutReactionsInput>
  }

  export type ProfileUpdateOneRequiredWithoutCommentReactionsNestedInput = {
    create?: XOR<ProfileCreateWithoutCommentReactionsInput, ProfileUncheckedCreateWithoutCommentReactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCommentReactionsInput
    upsert?: ProfileUpsertWithoutCommentReactionsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutCommentReactionsInput, ProfileUpdateWithoutCommentReactionsInput>, ProfileUncheckedUpdateWithoutCommentReactionsInput>
  }

  export type ProfileCreateNestedOneWithoutConversationsOwnedInput = {
    create?: XOR<ProfileCreateWithoutConversationsOwnedInput, ProfileUncheckedCreateWithoutConversationsOwnedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationsOwnedInput
    connect?: ProfileWhereUniqueInput
  }

  export type ConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ProfileUpdateOneWithoutConversationsOwnedNestedInput = {
    create?: XOR<ProfileCreateWithoutConversationsOwnedInput, ProfileUncheckedCreateWithoutConversationsOwnedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationsOwnedInput
    upsert?: ProfileUpsertWithoutConversationsOwnedInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutConversationsOwnedInput, ProfileUpdateWithoutConversationsOwnedInput>, ProfileUncheckedUpdateWithoutConversationsOwnedInput>
  }

  export type ConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutConversationMembersInput = {
    create?: XOR<ProfileCreateWithoutConversationMembersInput, ProfileUncheckedCreateWithoutConversationMembersInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationMembersInput
    connect?: ProfileWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    upsert?: ConversationUpsertWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutParticipantsInput, ConversationUpdateWithoutParticipantsInput>, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ProfileUpdateOneRequiredWithoutConversationMembersNestedInput = {
    create?: XOR<ProfileCreateWithoutConversationMembersInput, ProfileUncheckedCreateWithoutConversationMembersInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationMembersInput
    upsert?: ProfileUpsertWithoutConversationMembersInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutConversationMembersInput, ProfileUpdateWithoutConversationMembersInput>, ProfileUncheckedUpdateWithoutConversationMembersInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ProfileCreateWithoutMessagesInput, ProfileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMessagesInput
    connect?: ProfileWhereUniqueInput
  }

  export type MessageReadCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutMessageInput = {
    create?: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput> | NotificationCreateWithoutMessageInput[] | NotificationUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMessageInput | NotificationCreateOrConnectWithoutMessageInput[]
    createMany?: NotificationCreateManyMessageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessageReadUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput> | NotificationCreateWithoutMessageInput[] | NotificationUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMessageInput | NotificationCreateOrConnectWithoutMessageInput[]
    createMany?: NotificationCreateManyMessageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ProfileUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ProfileCreateWithoutMessagesInput, ProfileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMessagesInput
    upsert?: ProfileUpsertWithoutMessagesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMessagesInput, ProfileUpdateWithoutMessagesInput>, ProfileUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageReadUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutMessageInput | MessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutMessageInput | MessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutMessageInput | MessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput> | NotificationCreateWithoutMessageInput[] | NotificationUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMessageInput | NotificationCreateOrConnectWithoutMessageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMessageInput | NotificationUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NotificationCreateManyMessageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMessageInput | NotificationUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMessageInput | NotificationUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessageReadUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutMessageInput | MessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutMessageInput | MessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutMessageInput | MessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput> | NotificationCreateWithoutMessageInput[] | NotificationUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMessageInput | NotificationCreateOrConnectWithoutMessageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMessageInput | NotificationUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NotificationCreateManyMessageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMessageInput | NotificationUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMessageInput | NotificationUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutNotificationsAsActorInput = {
    create?: XOR<ProfileCreateWithoutNotificationsAsActorInput, ProfileUncheckedCreateWithoutNotificationsAsActorInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutNotificationsAsActorInput
    connect?: ProfileWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotificationsInput
    connect?: CommentWhereUniqueInput
  }

  export type LineageCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<LineageCreateWithoutNotificationsInput, LineageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutNotificationsInput
    connect?: LineageWhereUniqueInput
  }

  export type FriendRequestCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<FriendRequestCreateWithoutNotificationsInput, FriendRequestUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: FriendRequestCreateOrConnectWithoutNotificationsInput
    connect?: FriendRequestWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<MessageCreateWithoutNotificationsInput, MessageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutNotificationsInput
    connect?: MessageWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotificationsInput
    connect?: PostWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ProfileCreateWithoutNotificationsInput, ProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutNotificationsInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type ProfileUpdateOneWithoutNotificationsAsActorNestedInput = {
    create?: XOR<ProfileCreateWithoutNotificationsAsActorInput, ProfileUncheckedCreateWithoutNotificationsAsActorInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutNotificationsAsActorInput
    upsert?: ProfileUpsertWithoutNotificationsAsActorInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutNotificationsAsActorInput, ProfileUpdateWithoutNotificationsAsActorInput>, ProfileUncheckedUpdateWithoutNotificationsAsActorInput>
  }

  export type CommentUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotificationsInput
    upsert?: CommentUpsertWithoutNotificationsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutNotificationsInput, CommentUpdateWithoutNotificationsInput>, CommentUncheckedUpdateWithoutNotificationsInput>
  }

  export type LineageUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<LineageCreateWithoutNotificationsInput, LineageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutNotificationsInput
    upsert?: LineageUpsertWithoutNotificationsInput
    disconnect?: LineageWhereInput | boolean
    delete?: LineageWhereInput | boolean
    connect?: LineageWhereUniqueInput
    update?: XOR<XOR<LineageUpdateToOneWithWhereWithoutNotificationsInput, LineageUpdateWithoutNotificationsInput>, LineageUncheckedUpdateWithoutNotificationsInput>
  }

  export type FriendRequestUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<FriendRequestCreateWithoutNotificationsInput, FriendRequestUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: FriendRequestCreateOrConnectWithoutNotificationsInput
    upsert?: FriendRequestUpsertWithoutNotificationsInput
    disconnect?: FriendRequestWhereInput | boolean
    delete?: FriendRequestWhereInput | boolean
    connect?: FriendRequestWhereUniqueInput
    update?: XOR<XOR<FriendRequestUpdateToOneWithWhereWithoutNotificationsInput, FriendRequestUpdateWithoutNotificationsInput>, FriendRequestUncheckedUpdateWithoutNotificationsInput>
  }

  export type MessageUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<MessageCreateWithoutNotificationsInput, MessageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutNotificationsInput
    upsert?: MessageUpsertWithoutNotificationsInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutNotificationsInput, MessageUpdateWithoutNotificationsInput>, MessageUncheckedUpdateWithoutNotificationsInput>
  }

  export type PostUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotificationsInput
    upsert?: PostUpsertWithoutNotificationsInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutNotificationsInput, PostUpdateWithoutNotificationsInput>, PostUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProfileUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<ProfileCreateWithoutNotificationsInput, ProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutNotificationsInput
    upsert?: ProfileUpsertWithoutNotificationsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutNotificationsInput, ProfileUpdateWithoutNotificationsInput>, ProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProfileInterestCreateNestedManyWithoutInterestInput = {
    create?: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput> | ProfileInterestCreateWithoutInterestInput[] | ProfileInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutInterestInput | ProfileInterestCreateOrConnectWithoutInterestInput[]
    createMany?: ProfileInterestCreateManyInterestInputEnvelope
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
  }

  export type ProfileInterestUncheckedCreateNestedManyWithoutInterestInput = {
    create?: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput> | ProfileInterestCreateWithoutInterestInput[] | ProfileInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutInterestInput | ProfileInterestCreateOrConnectWithoutInterestInput[]
    createMany?: ProfileInterestCreateManyInterestInputEnvelope
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
  }

  export type ProfileInterestUpdateManyWithoutInterestNestedInput = {
    create?: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput> | ProfileInterestCreateWithoutInterestInput[] | ProfileInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutInterestInput | ProfileInterestCreateOrConnectWithoutInterestInput[]
    upsert?: ProfileInterestUpsertWithWhereUniqueWithoutInterestInput | ProfileInterestUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: ProfileInterestCreateManyInterestInputEnvelope
    set?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    disconnect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    delete?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    update?: ProfileInterestUpdateWithWhereUniqueWithoutInterestInput | ProfileInterestUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: ProfileInterestUpdateManyWithWhereWithoutInterestInput | ProfileInterestUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
  }

  export type ProfileInterestUncheckedUpdateManyWithoutInterestNestedInput = {
    create?: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput> | ProfileInterestCreateWithoutInterestInput[] | ProfileInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutInterestInput | ProfileInterestCreateOrConnectWithoutInterestInput[]
    upsert?: ProfileInterestUpsertWithWhereUniqueWithoutInterestInput | ProfileInterestUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: ProfileInterestCreateManyInterestInputEnvelope
    set?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    disconnect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    delete?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    update?: ProfileInterestUpdateWithWhereUniqueWithoutInterestInput | ProfileInterestUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: ProfileInterestUpdateManyWithWhereWithoutInterestInput | ProfileInterestUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
  }

  export type ProfileAppInterestsCreateNestedManyWithoutInterestInput = {
    create?: XOR<ProfileAppInterestsCreateWithoutInterestInput, ProfileAppInterestsUncheckedCreateWithoutInterestInput> | ProfileAppInterestsCreateWithoutInterestInput[] | ProfileAppInterestsUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileAppInterestsCreateOrConnectWithoutInterestInput | ProfileAppInterestsCreateOrConnectWithoutInterestInput[]
    createMany?: ProfileAppInterestsCreateManyInterestInputEnvelope
    connect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
  }

  export type ProfileAppInterestsUncheckedCreateNestedManyWithoutInterestInput = {
    create?: XOR<ProfileAppInterestsCreateWithoutInterestInput, ProfileAppInterestsUncheckedCreateWithoutInterestInput> | ProfileAppInterestsCreateWithoutInterestInput[] | ProfileAppInterestsUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileAppInterestsCreateOrConnectWithoutInterestInput | ProfileAppInterestsCreateOrConnectWithoutInterestInput[]
    createMany?: ProfileAppInterestsCreateManyInterestInputEnvelope
    connect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
  }

  export type ProfileAppInterestsUpdateManyWithoutInterestNestedInput = {
    create?: XOR<ProfileAppInterestsCreateWithoutInterestInput, ProfileAppInterestsUncheckedCreateWithoutInterestInput> | ProfileAppInterestsCreateWithoutInterestInput[] | ProfileAppInterestsUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileAppInterestsCreateOrConnectWithoutInterestInput | ProfileAppInterestsCreateOrConnectWithoutInterestInput[]
    upsert?: ProfileAppInterestsUpsertWithWhereUniqueWithoutInterestInput | ProfileAppInterestsUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: ProfileAppInterestsCreateManyInterestInputEnvelope
    set?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    disconnect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    delete?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    connect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    update?: ProfileAppInterestsUpdateWithWhereUniqueWithoutInterestInput | ProfileAppInterestsUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: ProfileAppInterestsUpdateManyWithWhereWithoutInterestInput | ProfileAppInterestsUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: ProfileAppInterestsScalarWhereInput | ProfileAppInterestsScalarWhereInput[]
  }

  export type ProfileAppInterestsUncheckedUpdateManyWithoutInterestNestedInput = {
    create?: XOR<ProfileAppInterestsCreateWithoutInterestInput, ProfileAppInterestsUncheckedCreateWithoutInterestInput> | ProfileAppInterestsCreateWithoutInterestInput[] | ProfileAppInterestsUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileAppInterestsCreateOrConnectWithoutInterestInput | ProfileAppInterestsCreateOrConnectWithoutInterestInput[]
    upsert?: ProfileAppInterestsUpsertWithWhereUniqueWithoutInterestInput | ProfileAppInterestsUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: ProfileAppInterestsCreateManyInterestInputEnvelope
    set?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    disconnect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    delete?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    connect?: ProfileAppInterestsWhereUniqueInput | ProfileAppInterestsWhereUniqueInput[]
    update?: ProfileAppInterestsUpdateWithWhereUniqueWithoutInterestInput | ProfileAppInterestsUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: ProfileAppInterestsUpdateManyWithWhereWithoutInterestInput | ProfileAppInterestsUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: ProfileAppInterestsScalarWhereInput | ProfileAppInterestsScalarWhereInput[]
  }

  export type InterestCreateNestedOneWithoutUsersInput = {
    create?: XOR<InterestCreateWithoutUsersInput, InterestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InterestCreateOrConnectWithoutUsersInput
    connect?: InterestWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutInterestsInput = {
    create?: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutInterestsInput
    connect?: ProfileWhereUniqueInput
  }

  export type InterestUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<InterestCreateWithoutUsersInput, InterestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InterestCreateOrConnectWithoutUsersInput
    upsert?: InterestUpsertWithoutUsersInput
    connect?: InterestWhereUniqueInput
    update?: XOR<XOR<InterestUpdateToOneWithWhereWithoutUsersInput, InterestUpdateWithoutUsersInput>, InterestUncheckedUpdateWithoutUsersInput>
  }

  export type ProfileUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutInterestsInput
    upsert?: ProfileUpsertWithoutInterestsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutInterestsInput, ProfileUpdateWithoutInterestsInput>, ProfileUncheckedUpdateWithoutInterestsInput>
  }

  export type AppInterestCreateNestedOneWithoutUsersInput = {
    create?: XOR<AppInterestCreateWithoutUsersInput, AppInterestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AppInterestCreateOrConnectWithoutUsersInput
    connect?: AppInterestWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutAppInterestsInput = {
    create?: XOR<ProfileCreateWithoutAppInterestsInput, ProfileUncheckedCreateWithoutAppInterestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAppInterestsInput
    connect?: ProfileWhereUniqueInput
  }

  export type AppInterestUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<AppInterestCreateWithoutUsersInput, AppInterestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: AppInterestCreateOrConnectWithoutUsersInput
    upsert?: AppInterestUpsertWithoutUsersInput
    connect?: AppInterestWhereUniqueInput
    update?: XOR<XOR<AppInterestUpdateToOneWithWhereWithoutUsersInput, AppInterestUpdateWithoutUsersInput>, AppInterestUncheckedUpdateWithoutUsersInput>
  }

  export type ProfileUpdateOneRequiredWithoutAppInterestsNestedInput = {
    create?: XOR<ProfileCreateWithoutAppInterestsInput, ProfileUncheckedCreateWithoutAppInterestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAppInterestsInput
    upsert?: ProfileUpsertWithoutAppInterestsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutAppInterestsInput, ProfileUpdateWithoutAppInterestsInput>, ProfileUncheckedUpdateWithoutAppInterestsInput>
  }

  export type MessageCreateNestedOneWithoutReadsInput = {
    create?: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadsInput
    connect?: MessageWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutMessageReadsInput = {
    create?: XOR<ProfileCreateWithoutMessageReadsInput, ProfileUncheckedCreateWithoutMessageReadsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMessageReadsInput
    connect?: ProfileWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutReadsNestedInput = {
    create?: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadsInput
    upsert?: MessageUpsertWithoutReadsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReadsInput, MessageUpdateWithoutReadsInput>, MessageUncheckedUpdateWithoutReadsInput>
  }

  export type ProfileUpdateOneRequiredWithoutMessageReadsNestedInput = {
    create?: XOR<ProfileCreateWithoutMessageReadsInput, ProfileUncheckedCreateWithoutMessageReadsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMessageReadsInput
    upsert?: ProfileUpsertWithoutMessageReadsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMessageReadsInput, ProfileUpdateWithoutMessageReadsInput>, ProfileUncheckedUpdateWithoutMessageReadsInput>
  }

  export type ProfileCreateNestedOneWithoutProductInput = {
    create?: XOR<ProfileCreateWithoutProductInput, ProfileUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProductInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProductMediaCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductMediaCreateWithoutProductInput, ProductMediaUncheckedCreateWithoutProductInput> | ProductMediaCreateWithoutProductInput[] | ProductMediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductMediaCreateOrConnectWithoutProductInput | ProductMediaCreateOrConnectWithoutProductInput[]
    createMany?: ProductMediaCreateManyProductInputEnvelope
    connect?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
  }

  export type ProductMediaUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductMediaCreateWithoutProductInput, ProductMediaUncheckedCreateWithoutProductInput> | ProductMediaCreateWithoutProductInput[] | ProductMediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductMediaCreateOrConnectWithoutProductInput | ProductMediaCreateOrConnectWithoutProductInput[]
    createMany?: ProductMediaCreateManyProductInputEnvelope
    connect?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
  }

  export type EnumProductConditionFieldUpdateOperationsInput = {
    set?: $Enums.ProductCondition
  }

  export type EnumAvailableFieldUpdateOperationsInput = {
    set?: $Enums.Available
  }

  export type EnumListingStatusFieldUpdateOperationsInput = {
    set?: $Enums.ListingStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProfileUpdateOneRequiredWithoutProductNestedInput = {
    create?: XOR<ProfileCreateWithoutProductInput, ProfileUncheckedCreateWithoutProductInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutProductInput
    upsert?: ProfileUpsertWithoutProductInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutProductInput, ProfileUpdateWithoutProductInput>, ProfileUncheckedUpdateWithoutProductInput>
  }

  export type ProductMediaUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductMediaCreateWithoutProductInput, ProductMediaUncheckedCreateWithoutProductInput> | ProductMediaCreateWithoutProductInput[] | ProductMediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductMediaCreateOrConnectWithoutProductInput | ProductMediaCreateOrConnectWithoutProductInput[]
    upsert?: ProductMediaUpsertWithWhereUniqueWithoutProductInput | ProductMediaUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductMediaCreateManyProductInputEnvelope
    set?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
    disconnect?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
    delete?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
    connect?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
    update?: ProductMediaUpdateWithWhereUniqueWithoutProductInput | ProductMediaUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductMediaUpdateManyWithWhereWithoutProductInput | ProductMediaUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductMediaScalarWhereInput | ProductMediaScalarWhereInput[]
  }

  export type ProductMediaUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductMediaCreateWithoutProductInput, ProductMediaUncheckedCreateWithoutProductInput> | ProductMediaCreateWithoutProductInput[] | ProductMediaUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductMediaCreateOrConnectWithoutProductInput | ProductMediaCreateOrConnectWithoutProductInput[]
    upsert?: ProductMediaUpsertWithWhereUniqueWithoutProductInput | ProductMediaUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductMediaCreateManyProductInputEnvelope
    set?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
    disconnect?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
    delete?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
    connect?: ProductMediaWhereUniqueInput | ProductMediaWhereUniqueInput[]
    update?: ProductMediaUpdateWithWhereUniqueWithoutProductInput | ProductMediaUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductMediaUpdateManyWithWhereWithoutProductInput | ProductMediaUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductMediaScalarWhereInput | ProductMediaScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutMediaInput = {
    create?: XOR<ProductCreateWithoutMediaInput, ProductUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMediaInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<ProductCreateWithoutMediaInput, ProductUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ProductCreateOrConnectWithoutMediaInput
    upsert?: ProductUpsertWithoutMediaInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutMediaInput, ProductUpdateWithoutMediaInput>, ProductUncheckedUpdateWithoutMediaInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumFriendRequestStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendRequestStatus | EnumFriendRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendRequestStatusFilter<$PrismaModel> | $Enums.FriendRequestStatus
  }

  export type NestedEnumFriendRequestStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FriendRequestStatus | EnumFriendRequestStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FriendRequestStatus[] | ListEnumFriendRequestStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFriendRequestStatusWithAggregatesFilter<$PrismaModel> | $Enums.FriendRequestStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFriendRequestStatusFilter<$PrismaModel>
    _max?: NestedEnumFriendRequestStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumLineageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageType | EnumLineageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageTypeFilter<$PrismaModel> | $Enums.LineageType
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumLineageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageType | EnumLineageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageTypeWithAggregatesFilter<$PrismaModel> | $Enums.LineageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLineageTypeFilter<$PrismaModel>
    _max?: NestedEnumLineageTypeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumLineageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageRole | EnumLineageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageRoleFilter<$PrismaModel> | $Enums.LineageRole
  }

  export type NestedEnumLineageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageRole | EnumLineageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageRoleWithAggregatesFilter<$PrismaModel> | $Enums.LineageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLineageRoleFilter<$PrismaModel>
    _max?: NestedEnumLineageRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumKinshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KinshipType | EnumKinshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKinshipTypeFilter<$PrismaModel> | $Enums.KinshipType
  }

  export type NestedEnumKinshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KinshipType | EnumKinshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKinshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.KinshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKinshipTypeFilter<$PrismaModel>
    _max?: NestedEnumKinshipTypeFilter<$PrismaModel>
  }

  export type NestedEnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedEnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumProductConditionFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCondition | EnumProductConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumProductConditionFilter<$PrismaModel> | $Enums.ProductCondition
  }

  export type NestedEnumAvailableFilter<$PrismaModel = never> = {
    equals?: $Enums.Available | EnumAvailableFieldRefInput<$PrismaModel>
    in?: $Enums.Available[] | ListEnumAvailableFieldRefInput<$PrismaModel>
    notIn?: $Enums.Available[] | ListEnumAvailableFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailableFilter<$PrismaModel> | $Enums.Available
  }

  export type NestedEnumListingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusFilter<$PrismaModel> | $Enums.ListingStatus
  }

  export type NestedEnumProductConditionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductCondition | EnumProductConditionFieldRefInput<$PrismaModel>
    in?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductCondition[] | ListEnumProductConditionFieldRefInput<$PrismaModel>
    not?: NestedEnumProductConditionWithAggregatesFilter<$PrismaModel> | $Enums.ProductCondition
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductConditionFilter<$PrismaModel>
    _max?: NestedEnumProductConditionFilter<$PrismaModel>
  }

  export type NestedEnumAvailableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Available | EnumAvailableFieldRefInput<$PrismaModel>
    in?: $Enums.Available[] | ListEnumAvailableFieldRefInput<$PrismaModel>
    notIn?: $Enums.Available[] | ListEnumAvailableFieldRefInput<$PrismaModel>
    not?: NestedEnumAvailableWithAggregatesFilter<$PrismaModel> | $Enums.Available
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAvailableFilter<$PrismaModel>
    _max?: NestedEnumAvailableFilter<$PrismaModel>
  }

  export type NestedEnumListingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListingStatus | EnumListingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ListingStatus[] | ListEnumListingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumListingStatusWithAggregatesFilter<$PrismaModel> | $Enums.ListingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumListingStatusFilter<$PrismaModel>
    _max?: NestedEnumListingStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BlockCreateWithoutBlockedInput = {
    id?: string
    createdAt?: Date | string
    blocker: ProfileCreateNestedOneWithoutBlocksAsBlockerInput
  }

  export type BlockUncheckedCreateWithoutBlockedInput = {
    id?: string
    blockerId: string
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput>
  }

  export type BlockCreateManyBlockedInputEnvelope = {
    data: BlockCreateManyBlockedInput | BlockCreateManyBlockedInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutBlockerInput = {
    id?: string
    createdAt?: Date | string
    blocked: ProfileCreateNestedOneWithoutBlocksAsBlockedInput
  }

  export type BlockUncheckedCreateWithoutBlockerInput = {
    id?: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockCreateManyBlockerInputEnvelope = {
    data: BlockCreateManyBlockerInput | BlockCreateManyBlockerInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    postId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentReactionCreateWithoutProfileInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutReactionsInput
  }

  export type CommentReactionUncheckedCreateWithoutProfileInput = {
    id?: string
    commentId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentReactionCreateOrConnectWithoutProfileInput = {
    where: CommentReactionWhereUniqueInput
    create: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput>
  }

  export type CommentReactionCreateManyProfileInputEnvelope = {
    data: CommentReactionCreateManyProfileInput | CommentReactionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutCreatedByInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutCreatedByInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutCreatedByInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput>
  }

  export type ConversationCreateManyCreatedByInputEnvelope = {
    data: ConversationCreateManyCreatedByInput | ConversationCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutProfileInput = {
    id?: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutProfileInput = {
    id?: string
    conversationId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutProfileInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput>
  }

  export type ConversationParticipantCreateManyProfileInputEnvelope = {
    data: ConversationParticipantCreateManyProfileInput | ConversationParticipantCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileClanCreateWithoutProfileInput = {
    id?: string
    order: number
    clan: ClanCreateNestedOneWithoutMembersInput
  }

  export type ProfileClanUncheckedCreateWithoutProfileInput = {
    id?: string
    clanId: string
    order: number
  }

  export type ProfileClanCreateOrConnectWithoutProfileInput = {
    where: ProfileClanWhereUniqueInput
    create: XOR<ProfileClanCreateWithoutProfileInput, ProfileClanUncheckedCreateWithoutProfileInput>
  }

  export type ProfileClanCreateManyProfileInputEnvelope = {
    data: ProfileClanCreateManyProfileInput | ProfileClanCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type KinshipCreateWithoutProfileAInput = {
    id?: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
    profileB: ProfileCreateNestedOneWithoutKinshipsBInput
  }

  export type KinshipUncheckedCreateWithoutProfileAInput = {
    id?: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipCreateOrConnectWithoutProfileAInput = {
    where: KinshipWhereUniqueInput
    create: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput>
  }

  export type KinshipCreateManyProfileAInputEnvelope = {
    data: KinshipCreateManyProfileAInput | KinshipCreateManyProfileAInput[]
    skipDuplicates?: boolean
  }

  export type KinshipCreateWithoutProfileBInput = {
    id?: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
    profileA: ProfileCreateNestedOneWithoutKinshipsAInput
  }

  export type KinshipUncheckedCreateWithoutProfileBInput = {
    id?: string
    profileIdA: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipCreateOrConnectWithoutProfileBInput = {
    where: KinshipWhereUniqueInput
    create: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput>
  }

  export type KinshipCreateManyProfileBInputEnvelope = {
    data: KinshipCreateManyProfileBInput | KinshipCreateManyProfileBInput[]
    skipDuplicates?: boolean
  }

  export type LineageCreateWithoutCreatedByInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipCreateNestedManyWithoutLineageInput
    notifications?: NotificationCreateNestedManyWithoutLineageInput
    posts?: PostCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipUncheckedCreateNestedManyWithoutLineageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutLineageInput
    posts?: PostUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageCreateOrConnectWithoutCreatedByInput = {
    where: LineageWhereUniqueInput
    create: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput>
  }

  export type LineageCreateManyCreatedByInputEnvelope = {
    data: LineageCreateManyCreatedByInput | LineageCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type LineageMembershipCreateWithoutAddedByInput = {
    id?: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
    lineage: LineageCreateNestedOneWithoutMembershipsInput
    profile: ProfileCreateNestedOneWithoutLineageMembershipsInput
  }

  export type LineageMembershipUncheckedCreateWithoutAddedByInput = {
    id?: string
    lineageId: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
  }

  export type LineageMembershipCreateOrConnectWithoutAddedByInput = {
    where: LineageMembershipWhereUniqueInput
    create: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput>
  }

  export type LineageMembershipCreateManyAddedByInputEnvelope = {
    data: LineageMembershipCreateManyAddedByInput | LineageMembershipCreateManyAddedByInput[]
    skipDuplicates?: boolean
  }

  export type LineageMembershipCreateWithoutProfileInput = {
    id?: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
    addedBy?: ProfileCreateNestedOneWithoutLineageMembershipsAddedInput
    lineage: LineageCreateNestedOneWithoutMembershipsInput
  }

  export type LineageMembershipUncheckedCreateWithoutProfileInput = {
    id?: string
    lineageId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type LineageMembershipCreateOrConnectWithoutProfileInput = {
    where: LineageMembershipWhereUniqueInput
    create: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput>
  }

  export type LineageMembershipCreateManyProfileInputEnvelope = {
    data: LineageMembershipCreateManyProfileInput | LineageMembershipCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
    notifications?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageReadCreateWithoutUserInput = {
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadsInput
  }

  export type MessageReadUncheckedCreateWithoutUserInput = {
    messageId: string
    readAt?: Date | string
  }

  export type MessageReadCreateOrConnectWithoutUserInput = {
    where: MessageReadWhereUniqueInput
    create: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput>
  }

  export type MessageReadCreateManyUserInputEnvelope = {
    data: MessageReadCreateManyUserInput | MessageReadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MuteCreateWithoutMutedInput = {
    id?: string
    createdAt?: Date | string
    muter: ProfileCreateNestedOneWithoutMutesAsMuterInput
  }

  export type MuteUncheckedCreateWithoutMutedInput = {
    id?: string
    muterId: string
    createdAt?: Date | string
  }

  export type MuteCreateOrConnectWithoutMutedInput = {
    where: MuteWhereUniqueInput
    create: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput>
  }

  export type MuteCreateManyMutedInputEnvelope = {
    data: MuteCreateManyMutedInput | MuteCreateManyMutedInput[]
    skipDuplicates?: boolean
  }

  export type MuteCreateWithoutMuterInput = {
    id?: string
    createdAt?: Date | string
    muted: ProfileCreateNestedOneWithoutMutesAsMutedInput
  }

  export type MuteUncheckedCreateWithoutMuterInput = {
    id?: string
    mutedId: string
    createdAt?: Date | string
  }

  export type MuteCreateOrConnectWithoutMuterInput = {
    where: MuteWhereUniqueInput
    create: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput>
  }

  export type MuteCreateManyMuterInputEnvelope = {
    data: MuteCreateManyMuterInput | MuteCreateManyMuterInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutSenderInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    request?: FriendRequestCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutSenderInput = {
    id?: string
    recipientId: string
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationCreateManySenderInputEnvelope = {
    data: NotificationCreateManySenderInput | NotificationCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    sender?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    request?: FriendRequestCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type PostReactionCreateWithoutProfileInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutReactionsInput
  }

  export type PostReactionUncheckedCreateWithoutProfileInput = {
    id?: string
    postId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type PostReactionCreateOrConnectWithoutProfileInput = {
    where: PostReactionWhereUniqueInput
    create: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput>
  }

  export type PostReactionCreateManyProfileInputEnvelope = {
    data: PostReactionCreateManyProfileInput | PostReactionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutSellerInput = {
    id?: string
    visibility?: $Enums.PostVisibility
    title: string
    price: number
    currency?: string
    description: string
    category: string
    condition?: $Enums.ProductCondition
    negotiable?: boolean
    availability: $Enums.Available
    status?: $Enums.ListingStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    deletedAt?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    locationText?: string | null
    lat?: number | null
    lng?: number | null
    viewCount?: number
    saveCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ProductMediaCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutSellerInput = {
    id?: string
    visibility?: $Enums.PostVisibility
    title: string
    price: number
    currency?: string
    description: string
    category: string
    condition?: $Enums.ProductCondition
    negotiable?: boolean
    availability: $Enums.Available
    status?: $Enums.ListingStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    deletedAt?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    locationText?: string | null
    lat?: number | null
    lng?: number | null
    viewCount?: number
    saveCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ProductMediaUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutSellerInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput>
  }

  export type ProductCreateManySellerInputEnvelope = {
    data: ProductCreateManySellerInput | ProductCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type ProfileInterestCreateWithoutUserInput = {
    createdAt?: Date | string
    interest: InterestCreateNestedOneWithoutUsersInput
  }

  export type ProfileInterestUncheckedCreateWithoutUserInput = {
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileInterestCreateOrConnectWithoutUserInput = {
    where: ProfileInterestWhereUniqueInput
    create: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput>
  }

  export type ProfileInterestCreateManyUserInputEnvelope = {
    data: ProfileInterestCreateManyUserInput | ProfileInterestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileAppInterestsCreateWithoutUserInput = {
    createdAt?: Date | string
    interest: AppInterestCreateNestedOneWithoutUsersInput
  }

  export type ProfileAppInterestsUncheckedCreateWithoutUserInput = {
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileAppInterestsCreateOrConnectWithoutUserInput = {
    where: ProfileAppInterestsWhereUniqueInput
    create: XOR<ProfileAppInterestsCreateWithoutUserInput, ProfileAppInterestsUncheckedCreateWithoutUserInput>
  }

  export type ProfileAppInterestsCreateManyUserInputEnvelope = {
    data: ProfileAppInterestsCreateManyUserInput | ProfileAppInterestsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileSettingsCreateWithoutProfileInput = {
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileSettingsUncheckedCreateWithoutProfileInput = {
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileSettingsCreateOrConnectWithoutProfileInput = {
    where: ProfileSettingsWhereUniqueInput
    create: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
  }

  export type FriendRequestCreateWithoutRequesterInput = {
    id?: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    addressee: ProfileCreateNestedOneWithoutReceivedFriendRequestsInput
  }

  export type FriendRequestUncheckedCreateWithoutRequesterInput = {
    id?: string
    addresseeId: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
  }

  export type FriendRequestCreateOrConnectWithoutRequesterInput = {
    where: FriendRequestWhereUniqueInput
    create: XOR<FriendRequestCreateWithoutRequesterInput, FriendRequestUncheckedCreateWithoutRequesterInput>
  }

  export type FriendRequestCreateManyRequesterInputEnvelope = {
    data: FriendRequestCreateManyRequesterInput | FriendRequestCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type FriendRequestCreateWithoutAddresseeInput = {
    id?: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    notifications?: NotificationCreateNestedManyWithoutRequestInput
    requester: ProfileCreateNestedOneWithoutSentFriendRequestsInput
  }

  export type FriendRequestUncheckedCreateWithoutAddresseeInput = {
    id?: string
    requesterId: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    notifications?: NotificationUncheckedCreateNestedManyWithoutRequestInput
  }

  export type FriendRequestCreateOrConnectWithoutAddresseeInput = {
    where: FriendRequestWhereUniqueInput
    create: XOR<FriendRequestCreateWithoutAddresseeInput, FriendRequestUncheckedCreateWithoutAddresseeInput>
  }

  export type FriendRequestCreateManyAddresseeInputEnvelope = {
    data: FriendRequestCreateManyAddresseeInput | FriendRequestCreateManyAddresseeInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutUserAInput = {
    id?: string
    createdAt?: Date | string
    userB: ProfileCreateNestedOneWithoutFriendshipsBInput
  }

  export type FriendshipUncheckedCreateWithoutUserAInput = {
    id?: string
    userBId: string
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutUserAInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutUserAInput, FriendshipUncheckedCreateWithoutUserAInput>
  }

  export type FriendshipCreateManyUserAInputEnvelope = {
    data: FriendshipCreateManyUserAInput | FriendshipCreateManyUserAInput[]
    skipDuplicates?: boolean
  }

  export type FriendshipCreateWithoutUserBInput = {
    id?: string
    createdAt?: Date | string
    userA: ProfileCreateNestedOneWithoutFriendshipsAInput
  }

  export type FriendshipUncheckedCreateWithoutUserBInput = {
    id?: string
    userAId: string
    createdAt?: Date | string
  }

  export type FriendshipCreateOrConnectWithoutUserBInput = {
    where: FriendshipWhereUniqueInput
    create: XOR<FriendshipCreateWithoutUserBInput, FriendshipUncheckedCreateWithoutUserBInput>
  }

  export type FriendshipCreateManyUserBInputEnvelope = {
    data: FriendshipCreateManyUserBInput | FriendshipCreateManyUserBInput[]
    skipDuplicates?: boolean
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockedInput, BlockUncheckedUpdateWithoutBlockedInput>
    create: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockedInput, BlockUncheckedUpdateWithoutBlockedInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockedInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockedInput>
  }

  export type BlockScalarWhereInput = {
    AND?: BlockScalarWhereInput | BlockScalarWhereInput[]
    OR?: BlockScalarWhereInput[]
    NOT?: BlockScalarWhereInput | BlockScalarWhereInput[]
    id?: UuidFilter<"Block"> | string
    blockerId?: UuidFilter<"Block"> | string
    blockedId?: UuidFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockerInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockerInput>
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: UuidFilter<"Comment"> | string
    postId?: UuidFilter<"Comment"> | string
    profileId?: UuidFilter<"Comment"> | string
    parentCommentId?: UuidNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    likeCount?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type CommentReactionUpsertWithWhereUniqueWithoutProfileInput = {
    where: CommentReactionWhereUniqueInput
    update: XOR<CommentReactionUpdateWithoutProfileInput, CommentReactionUncheckedUpdateWithoutProfileInput>
    create: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput>
  }

  export type CommentReactionUpdateWithWhereUniqueWithoutProfileInput = {
    where: CommentReactionWhereUniqueInput
    data: XOR<CommentReactionUpdateWithoutProfileInput, CommentReactionUncheckedUpdateWithoutProfileInput>
  }

  export type CommentReactionUpdateManyWithWhereWithoutProfileInput = {
    where: CommentReactionScalarWhereInput
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyWithoutProfileInput>
  }

  export type CommentReactionScalarWhereInput = {
    AND?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
    OR?: CommentReactionScalarWhereInput[]
    NOT?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
    id?: UuidFilter<"CommentReaction"> | string
    commentId?: UuidFilter<"CommentReaction"> | string
    profileId?: UuidFilter<"CommentReaction"> | string
    type?: EnumReactionTypeFilter<"CommentReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"CommentReaction"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutCreatedByInput, ConversationUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutCreatedByInput, ConversationUncheckedUpdateWithoutCreatedByInput>
  }

  export type ConversationUpdateManyWithWhereWithoutCreatedByInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: UuidFilter<"Conversation"> | string
    isGroup?: BoolFilter<"Conversation"> | boolean
    title?: StringNullableFilter<"Conversation"> | string | null
    createdById?: UuidNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutProfileInput, ConversationParticipantUncheckedUpdateWithoutProfileInput>
    create: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutProfileInput, ConversationParticipantUncheckedUpdateWithoutProfileInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutProfileInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutProfileInput>
  }

  export type ConversationParticipantScalarWhereInput = {
    AND?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    OR?: ConversationParticipantScalarWhereInput[]
    NOT?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    id?: UuidFilter<"ConversationParticipant"> | string
    conversationId?: UuidFilter<"ConversationParticipant"> | string
    profileId?: UuidFilter<"ConversationParticipant"> | string
    role?: StringFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
  }

  export type ProfileClanUpsertWithWhereUniqueWithoutProfileInput = {
    where: ProfileClanWhereUniqueInput
    update: XOR<ProfileClanUpdateWithoutProfileInput, ProfileClanUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileClanCreateWithoutProfileInput, ProfileClanUncheckedCreateWithoutProfileInput>
  }

  export type ProfileClanUpdateWithWhereUniqueWithoutProfileInput = {
    where: ProfileClanWhereUniqueInput
    data: XOR<ProfileClanUpdateWithoutProfileInput, ProfileClanUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileClanUpdateManyWithWhereWithoutProfileInput = {
    where: ProfileClanScalarWhereInput
    data: XOR<ProfileClanUpdateManyMutationInput, ProfileClanUncheckedUpdateManyWithoutProfileInput>
  }

  export type ProfileClanScalarWhereInput = {
    AND?: ProfileClanScalarWhereInput | ProfileClanScalarWhereInput[]
    OR?: ProfileClanScalarWhereInput[]
    NOT?: ProfileClanScalarWhereInput | ProfileClanScalarWhereInput[]
    id?: UuidFilter<"ProfileClan"> | string
    profileId?: UuidFilter<"ProfileClan"> | string
    clanId?: UuidFilter<"ProfileClan"> | string
    order?: IntFilter<"ProfileClan"> | number
  }

  export type KinshipUpsertWithWhereUniqueWithoutProfileAInput = {
    where: KinshipWhereUniqueInput
    update: XOR<KinshipUpdateWithoutProfileAInput, KinshipUncheckedUpdateWithoutProfileAInput>
    create: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput>
  }

  export type KinshipUpdateWithWhereUniqueWithoutProfileAInput = {
    where: KinshipWhereUniqueInput
    data: XOR<KinshipUpdateWithoutProfileAInput, KinshipUncheckedUpdateWithoutProfileAInput>
  }

  export type KinshipUpdateManyWithWhereWithoutProfileAInput = {
    where: KinshipScalarWhereInput
    data: XOR<KinshipUpdateManyMutationInput, KinshipUncheckedUpdateManyWithoutProfileAInput>
  }

  export type KinshipScalarWhereInput = {
    AND?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
    OR?: KinshipScalarWhereInput[]
    NOT?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
    id?: UuidFilter<"Kinship"> | string
    profileIdA?: UuidFilter<"Kinship"> | string
    profileIdB?: UuidFilter<"Kinship"> | string
    relationAtoB?: EnumKinshipTypeFilter<"Kinship"> | $Enums.KinshipType
    verified?: BoolFilter<"Kinship"> | boolean
    verifiedById?: UuidNullableFilter<"Kinship"> | string | null
    createdAt?: DateTimeFilter<"Kinship"> | Date | string
  }

  export type KinshipUpsertWithWhereUniqueWithoutProfileBInput = {
    where: KinshipWhereUniqueInput
    update: XOR<KinshipUpdateWithoutProfileBInput, KinshipUncheckedUpdateWithoutProfileBInput>
    create: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput>
  }

  export type KinshipUpdateWithWhereUniqueWithoutProfileBInput = {
    where: KinshipWhereUniqueInput
    data: XOR<KinshipUpdateWithoutProfileBInput, KinshipUncheckedUpdateWithoutProfileBInput>
  }

  export type KinshipUpdateManyWithWhereWithoutProfileBInput = {
    where: KinshipScalarWhereInput
    data: XOR<KinshipUpdateManyMutationInput, KinshipUncheckedUpdateManyWithoutProfileBInput>
  }

  export type LineageUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: LineageWhereUniqueInput
    update: XOR<LineageUpdateWithoutCreatedByInput, LineageUncheckedUpdateWithoutCreatedByInput>
    create: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput>
  }

  export type LineageUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: LineageWhereUniqueInput
    data: XOR<LineageUpdateWithoutCreatedByInput, LineageUncheckedUpdateWithoutCreatedByInput>
  }

  export type LineageUpdateManyWithWhereWithoutCreatedByInput = {
    where: LineageScalarWhereInput
    data: XOR<LineageUpdateManyMutationInput, LineageUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type LineageScalarWhereInput = {
    AND?: LineageScalarWhereInput | LineageScalarWhereInput[]
    OR?: LineageScalarWhereInput[]
    NOT?: LineageScalarWhereInput | LineageScalarWhereInput[]
    id?: UuidFilter<"Lineage"> | string
    name?: StringFilter<"Lineage"> | string
    type?: EnumLineageTypeFilter<"Lineage"> | $Enums.LineageType
    primarySurname?: StringNullableFilter<"Lineage"> | string | null
    rootVillage?: StringNullableFilter<"Lineage"> | string | null
    rootRegion?: StringNullableFilter<"Lineage"> | string | null
    description?: StringNullableFilter<"Lineage"> | string | null
    createdById?: UuidNullableFilter<"Lineage"> | string | null
    createdAt?: DateTimeFilter<"Lineage"> | Date | string
    updatedAt?: DateTimeFilter<"Lineage"> | Date | string
  }

  export type LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput = {
    where: LineageMembershipWhereUniqueInput
    update: XOR<LineageMembershipUpdateWithoutAddedByInput, LineageMembershipUncheckedUpdateWithoutAddedByInput>
    create: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput>
  }

  export type LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput = {
    where: LineageMembershipWhereUniqueInput
    data: XOR<LineageMembershipUpdateWithoutAddedByInput, LineageMembershipUncheckedUpdateWithoutAddedByInput>
  }

  export type LineageMembershipUpdateManyWithWhereWithoutAddedByInput = {
    where: LineageMembershipScalarWhereInput
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyWithoutAddedByInput>
  }

  export type LineageMembershipScalarWhereInput = {
    AND?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
    OR?: LineageMembershipScalarWhereInput[]
    NOT?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
    id?: UuidFilter<"LineageMembership"> | string
    lineageId?: UuidFilter<"LineageMembership"> | string
    profileId?: UuidFilter<"LineageMembership"> | string
    role?: EnumLineageRoleFilter<"LineageMembership"> | $Enums.LineageRole
    generation?: IntNullableFilter<"LineageMembership"> | number | null
    isPrimaryLineage?: BoolFilter<"LineageMembership"> | boolean
    addedById?: UuidNullableFilter<"LineageMembership"> | string | null
    createdAt?: DateTimeFilter<"LineageMembership"> | Date | string
  }

  export type LineageMembershipUpsertWithWhereUniqueWithoutProfileInput = {
    where: LineageMembershipWhereUniqueInput
    update: XOR<LineageMembershipUpdateWithoutProfileInput, LineageMembershipUncheckedUpdateWithoutProfileInput>
    create: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput>
  }

  export type LineageMembershipUpdateWithWhereUniqueWithoutProfileInput = {
    where: LineageMembershipWhereUniqueInput
    data: XOR<LineageMembershipUpdateWithoutProfileInput, LineageMembershipUncheckedUpdateWithoutProfileInput>
  }

  export type LineageMembershipUpdateManyWithWhereWithoutProfileInput = {
    where: LineageMembershipScalarWhereInput
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyWithoutProfileInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: UuidFilter<"Message"> | string
    conversationId?: UuidFilter<"Message"> | string
    senderId?: UuidFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    timestamp?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageReadUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageReadWhereUniqueInput
    update: XOR<MessageReadUpdateWithoutUserInput, MessageReadUncheckedUpdateWithoutUserInput>
    create: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput>
  }

  export type MessageReadUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageReadWhereUniqueInput
    data: XOR<MessageReadUpdateWithoutUserInput, MessageReadUncheckedUpdateWithoutUserInput>
  }

  export type MessageReadUpdateManyWithWhereWithoutUserInput = {
    where: MessageReadScalarWhereInput
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageReadScalarWhereInput = {
    AND?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
    OR?: MessageReadScalarWhereInput[]
    NOT?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
    messageId?: UuidFilter<"MessageRead"> | string
    userId?: UuidFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
  }

  export type MuteUpsertWithWhereUniqueWithoutMutedInput = {
    where: MuteWhereUniqueInput
    update: XOR<MuteUpdateWithoutMutedInput, MuteUncheckedUpdateWithoutMutedInput>
    create: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput>
  }

  export type MuteUpdateWithWhereUniqueWithoutMutedInput = {
    where: MuteWhereUniqueInput
    data: XOR<MuteUpdateWithoutMutedInput, MuteUncheckedUpdateWithoutMutedInput>
  }

  export type MuteUpdateManyWithWhereWithoutMutedInput = {
    where: MuteScalarWhereInput
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyWithoutMutedInput>
  }

  export type MuteScalarWhereInput = {
    AND?: MuteScalarWhereInput | MuteScalarWhereInput[]
    OR?: MuteScalarWhereInput[]
    NOT?: MuteScalarWhereInput | MuteScalarWhereInput[]
    id?: UuidFilter<"Mute"> | string
    muterId?: UuidFilter<"Mute"> | string
    mutedId?: UuidFilter<"Mute"> | string
    createdAt?: DateTimeFilter<"Mute"> | Date | string
  }

  export type MuteUpsertWithWhereUniqueWithoutMuterInput = {
    where: MuteWhereUniqueInput
    update: XOR<MuteUpdateWithoutMuterInput, MuteUncheckedUpdateWithoutMuterInput>
    create: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput>
  }

  export type MuteUpdateWithWhereUniqueWithoutMuterInput = {
    where: MuteWhereUniqueInput
    data: XOR<MuteUpdateWithoutMuterInput, MuteUncheckedUpdateWithoutMuterInput>
  }

  export type MuteUpdateManyWithWhereWithoutMuterInput = {
    where: MuteScalarWhereInput
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyWithoutMuterInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
    create: XOR<NotificationCreateWithoutSenderInput, NotificationUncheckedCreateWithoutSenderInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutSenderInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutSenderInput, NotificationUncheckedUpdateWithoutSenderInput>
  }

  export type NotificationUpdateManyWithWhereWithoutSenderInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutSenderInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: UuidFilter<"Notification"> | string
    recipientId?: UuidFilter<"Notification"> | string
    senderId?: UuidNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    postId?: UuidNullableFilter<"Notification"> | string | null
    commentId?: UuidNullableFilter<"Notification"> | string | null
    requestId?: UuidNullableFilter<"Notification"> | string | null
    lineageId?: UuidNullableFilter<"Notification"> | string | null
    messageId?: UuidNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: UuidFilter<"Post"> | string
    profileId?: UuidFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    locationText?: StringNullableFilter<"Post"> | string | null
    lineageId?: UuidNullableFilter<"Post"> | string | null
    commentCount?: IntFilter<"Post"> | number
    likeCount?: IntFilter<"Post"> | number
    shareCount?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type PostReactionUpsertWithWhereUniqueWithoutProfileInput = {
    where: PostReactionWhereUniqueInput
    update: XOR<PostReactionUpdateWithoutProfileInput, PostReactionUncheckedUpdateWithoutProfileInput>
    create: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput>
  }

  export type PostReactionUpdateWithWhereUniqueWithoutProfileInput = {
    where: PostReactionWhereUniqueInput
    data: XOR<PostReactionUpdateWithoutProfileInput, PostReactionUncheckedUpdateWithoutProfileInput>
  }

  export type PostReactionUpdateManyWithWhereWithoutProfileInput = {
    where: PostReactionScalarWhereInput
    data: XOR<PostReactionUpdateManyMutationInput, PostReactionUncheckedUpdateManyWithoutProfileInput>
  }

  export type PostReactionScalarWhereInput = {
    AND?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
    OR?: PostReactionScalarWhereInput[]
    NOT?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
    id?: UuidFilter<"PostReaction"> | string
    postId?: UuidFilter<"PostReaction"> | string
    profileId?: UuidFilter<"PostReaction"> | string
    type?: EnumReactionTypeFilter<"PostReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"PostReaction"> | Date | string
  }

  export type ProductUpsertWithWhereUniqueWithoutSellerInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutSellerInput, ProductUncheckedUpdateWithoutSellerInput>
    create: XOR<ProductCreateWithoutSellerInput, ProductUncheckedCreateWithoutSellerInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutSellerInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutSellerInput, ProductUncheckedUpdateWithoutSellerInput>
  }

  export type ProductUpdateManyWithWhereWithoutSellerInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutSellerInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: UuidFilter<"Product"> | string
    sellerId?: UuidFilter<"Product"> | string
    visibility?: EnumPostVisibilityFilter<"Product"> | $Enums.PostVisibility
    title?: StringFilter<"Product"> | string
    price?: IntFilter<"Product"> | number
    currency?: StringFilter<"Product"> | string
    description?: StringFilter<"Product"> | string
    category?: StringFilter<"Product"> | string
    condition?: EnumProductConditionFilter<"Product"> | $Enums.ProductCondition
    negotiable?: BoolFilter<"Product"> | boolean
    availability?: EnumAvailableFilter<"Product"> | $Enums.Available
    status?: EnumListingStatusFilter<"Product"> | $Enums.ListingStatus
    publishedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    expiresAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    country?: StringNullableFilter<"Product"> | string | null
    city?: StringNullableFilter<"Product"> | string | null
    district?: StringNullableFilter<"Product"> | string | null
    locationText?: StringNullableFilter<"Product"> | string | null
    lat?: FloatNullableFilter<"Product"> | number | null
    lng?: FloatNullableFilter<"Product"> | number | null
    viewCount?: IntFilter<"Product"> | number
    saveCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProfileInterestUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfileInterestWhereUniqueInput
    update: XOR<ProfileInterestUpdateWithoutUserInput, ProfileInterestUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput>
  }

  export type ProfileInterestUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfileInterestWhereUniqueInput
    data: XOR<ProfileInterestUpdateWithoutUserInput, ProfileInterestUncheckedUpdateWithoutUserInput>
  }

  export type ProfileInterestUpdateManyWithWhereWithoutUserInput = {
    where: ProfileInterestScalarWhereInput
    data: XOR<ProfileInterestUpdateManyMutationInput, ProfileInterestUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfileInterestScalarWhereInput = {
    AND?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
    OR?: ProfileInterestScalarWhereInput[]
    NOT?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
    userId?: UuidFilter<"ProfileInterest"> | string
    interestId?: UuidFilter<"ProfileInterest"> | string
    createdAt?: DateTimeFilter<"ProfileInterest"> | Date | string
  }

  export type ProfileAppInterestsUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfileAppInterestsWhereUniqueInput
    update: XOR<ProfileAppInterestsUpdateWithoutUserInput, ProfileAppInterestsUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileAppInterestsCreateWithoutUserInput, ProfileAppInterestsUncheckedCreateWithoutUserInput>
  }

  export type ProfileAppInterestsUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfileAppInterestsWhereUniqueInput
    data: XOR<ProfileAppInterestsUpdateWithoutUserInput, ProfileAppInterestsUncheckedUpdateWithoutUserInput>
  }

  export type ProfileAppInterestsUpdateManyWithWhereWithoutUserInput = {
    where: ProfileAppInterestsScalarWhereInput
    data: XOR<ProfileAppInterestsUpdateManyMutationInput, ProfileAppInterestsUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfileAppInterestsScalarWhereInput = {
    AND?: ProfileAppInterestsScalarWhereInput | ProfileAppInterestsScalarWhereInput[]
    OR?: ProfileAppInterestsScalarWhereInput[]
    NOT?: ProfileAppInterestsScalarWhereInput | ProfileAppInterestsScalarWhereInput[]
    userId?: UuidFilter<"ProfileAppInterests"> | string
    interestId?: UuidFilter<"ProfileAppInterests"> | string
    createdAt?: DateTimeFilter<"ProfileAppInterests"> | Date | string
  }

  export type ProfileSettingsUpsertWithoutProfileInput = {
    update: XOR<ProfileSettingsUpdateWithoutProfileInput, ProfileSettingsUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    where?: ProfileSettingsWhereInput
  }

  export type ProfileSettingsUpdateToOneWithWhereWithoutProfileInput = {
    where?: ProfileSettingsWhereInput
    data: XOR<ProfileSettingsUpdateWithoutProfileInput, ProfileSettingsUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileSettingsUpdateWithoutProfileInput = {
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileSettingsUncheckedUpdateWithoutProfileInput = {
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: FriendRequestWhereUniqueInput
    update: XOR<FriendRequestUpdateWithoutRequesterInput, FriendRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<FriendRequestCreateWithoutRequesterInput, FriendRequestUncheckedCreateWithoutRequesterInput>
  }

  export type FriendRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: FriendRequestWhereUniqueInput
    data: XOR<FriendRequestUpdateWithoutRequesterInput, FriendRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type FriendRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: FriendRequestScalarWhereInput
    data: XOR<FriendRequestUpdateManyMutationInput, FriendRequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type FriendRequestScalarWhereInput = {
    AND?: FriendRequestScalarWhereInput | FriendRequestScalarWhereInput[]
    OR?: FriendRequestScalarWhereInput[]
    NOT?: FriendRequestScalarWhereInput | FriendRequestScalarWhereInput[]
    id?: UuidFilter<"FriendRequest"> | string
    requesterId?: UuidFilter<"FriendRequest"> | string
    addresseeId?: UuidFilter<"FriendRequest"> | string
    status?: EnumFriendRequestStatusFilter<"FriendRequest"> | $Enums.FriendRequestStatus
    createdAt?: DateTimeFilter<"FriendRequest"> | Date | string
    respondedAt?: DateTimeNullableFilter<"FriendRequest"> | Date | string | null
  }

  export type FriendRequestUpsertWithWhereUniqueWithoutAddresseeInput = {
    where: FriendRequestWhereUniqueInput
    update: XOR<FriendRequestUpdateWithoutAddresseeInput, FriendRequestUncheckedUpdateWithoutAddresseeInput>
    create: XOR<FriendRequestCreateWithoutAddresseeInput, FriendRequestUncheckedCreateWithoutAddresseeInput>
  }

  export type FriendRequestUpdateWithWhereUniqueWithoutAddresseeInput = {
    where: FriendRequestWhereUniqueInput
    data: XOR<FriendRequestUpdateWithoutAddresseeInput, FriendRequestUncheckedUpdateWithoutAddresseeInput>
  }

  export type FriendRequestUpdateManyWithWhereWithoutAddresseeInput = {
    where: FriendRequestScalarWhereInput
    data: XOR<FriendRequestUpdateManyMutationInput, FriendRequestUncheckedUpdateManyWithoutAddresseeInput>
  }

  export type FriendshipUpsertWithWhereUniqueWithoutUserAInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutUserAInput, FriendshipUncheckedUpdateWithoutUserAInput>
    create: XOR<FriendshipCreateWithoutUserAInput, FriendshipUncheckedCreateWithoutUserAInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutUserAInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutUserAInput, FriendshipUncheckedUpdateWithoutUserAInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutUserAInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutUserAInput>
  }

  export type FriendshipScalarWhereInput = {
    AND?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    OR?: FriendshipScalarWhereInput[]
    NOT?: FriendshipScalarWhereInput | FriendshipScalarWhereInput[]
    id?: UuidFilter<"Friendship"> | string
    userAId?: UuidFilter<"Friendship"> | string
    userBId?: UuidFilter<"Friendship"> | string
    createdAt?: DateTimeFilter<"Friendship"> | Date | string
  }

  export type FriendshipUpsertWithWhereUniqueWithoutUserBInput = {
    where: FriendshipWhereUniqueInput
    update: XOR<FriendshipUpdateWithoutUserBInput, FriendshipUncheckedUpdateWithoutUserBInput>
    create: XOR<FriendshipCreateWithoutUserBInput, FriendshipUncheckedCreateWithoutUserBInput>
  }

  export type FriendshipUpdateWithWhereUniqueWithoutUserBInput = {
    where: FriendshipWhereUniqueInput
    data: XOR<FriendshipUpdateWithoutUserBInput, FriendshipUncheckedUpdateWithoutUserBInput>
  }

  export type FriendshipUpdateManyWithWhereWithoutUserBInput = {
    where: FriendshipScalarWhereInput
    data: XOR<FriendshipUpdateManyMutationInput, FriendshipUncheckedUpdateManyWithoutUserBInput>
  }

  export type ProfileCreateWithoutSettingsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutSettingsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutSettingsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
  }

  export type ProfileUpsertWithoutSettingsInput = {
    update: XOR<ProfileUpdateWithoutSettingsInput, ProfileUncheckedUpdateWithoutSettingsInput>
    create: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutSettingsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutSettingsInput, ProfileUncheckedUpdateWithoutSettingsInput>
  }

  export type ProfileUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type NotificationCreateWithoutRequestInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    sender?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRequestInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRequestInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput>
  }

  export type NotificationCreateManyRequestInputEnvelope = {
    data: NotificationCreateManyRequestInput | NotificationCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type ProfileCreateWithoutSentFriendRequestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutSentFriendRequestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutSentFriendRequestsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutSentFriendRequestsInput, ProfileUncheckedCreateWithoutSentFriendRequestsInput>
  }

  export type ProfileCreateWithoutReceivedFriendRequestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutReceivedFriendRequestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutReceivedFriendRequestsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutReceivedFriendRequestsInput, ProfileUncheckedCreateWithoutReceivedFriendRequestsInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutRequestInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRequestInput, NotificationUncheckedUpdateWithoutRequestInput>
    create: XOR<NotificationCreateWithoutRequestInput, NotificationUncheckedCreateWithoutRequestInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRequestInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRequestInput, NotificationUncheckedUpdateWithoutRequestInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRequestInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRequestInput>
  }

  export type ProfileUpsertWithoutSentFriendRequestsInput = {
    update: XOR<ProfileUpdateWithoutSentFriendRequestsInput, ProfileUncheckedUpdateWithoutSentFriendRequestsInput>
    create: XOR<ProfileCreateWithoutSentFriendRequestsInput, ProfileUncheckedCreateWithoutSentFriendRequestsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutSentFriendRequestsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutSentFriendRequestsInput, ProfileUncheckedUpdateWithoutSentFriendRequestsInput>
  }

  export type ProfileUpdateWithoutSentFriendRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutSentFriendRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUpsertWithoutReceivedFriendRequestsInput = {
    update: XOR<ProfileUpdateWithoutReceivedFriendRequestsInput, ProfileUncheckedUpdateWithoutReceivedFriendRequestsInput>
    create: XOR<ProfileCreateWithoutReceivedFriendRequestsInput, ProfileUncheckedCreateWithoutReceivedFriendRequestsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutReceivedFriendRequestsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutReceivedFriendRequestsInput, ProfileUncheckedUpdateWithoutReceivedFriendRequestsInput>
  }

  export type ProfileUpdateWithoutReceivedFriendRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutReceivedFriendRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileCreateWithoutFriendshipsAInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutFriendshipsAInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutFriendshipsAInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutFriendshipsAInput, ProfileUncheckedCreateWithoutFriendshipsAInput>
  }

  export type ProfileCreateWithoutFriendshipsBInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
  }

  export type ProfileUncheckedCreateWithoutFriendshipsBInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
  }

  export type ProfileCreateOrConnectWithoutFriendshipsBInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutFriendshipsBInput, ProfileUncheckedCreateWithoutFriendshipsBInput>
  }

  export type ProfileUpsertWithoutFriendshipsAInput = {
    update: XOR<ProfileUpdateWithoutFriendshipsAInput, ProfileUncheckedUpdateWithoutFriendshipsAInput>
    create: XOR<ProfileCreateWithoutFriendshipsAInput, ProfileUncheckedCreateWithoutFriendshipsAInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutFriendshipsAInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutFriendshipsAInput, ProfileUncheckedUpdateWithoutFriendshipsAInput>
  }

  export type ProfileUpdateWithoutFriendshipsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutFriendshipsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUpsertWithoutFriendshipsBInput = {
    update: XOR<ProfileUpdateWithoutFriendshipsBInput, ProfileUncheckedUpdateWithoutFriendshipsBInput>
    create: XOR<ProfileCreateWithoutFriendshipsBInput, ProfileUncheckedCreateWithoutFriendshipsBInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutFriendshipsBInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutFriendshipsBInput, ProfileUncheckedUpdateWithoutFriendshipsBInput>
  }

  export type ProfileUpdateWithoutFriendshipsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
  }

  export type ProfileUncheckedUpdateWithoutFriendshipsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
  }

  export type ProfileClanCreateWithoutClanInput = {
    id?: string
    order: number
    profile: ProfileCreateNestedOneWithoutClanTreeInput
  }

  export type ProfileClanUncheckedCreateWithoutClanInput = {
    id?: string
    profileId: string
    order: number
  }

  export type ProfileClanCreateOrConnectWithoutClanInput = {
    where: ProfileClanWhereUniqueInput
    create: XOR<ProfileClanCreateWithoutClanInput, ProfileClanUncheckedCreateWithoutClanInput>
  }

  export type ProfileClanCreateManyClanInputEnvelope = {
    data: ProfileClanCreateManyClanInput | ProfileClanCreateManyClanInput[]
    skipDuplicates?: boolean
  }

  export type ProfileClanUpsertWithWhereUniqueWithoutClanInput = {
    where: ProfileClanWhereUniqueInput
    update: XOR<ProfileClanUpdateWithoutClanInput, ProfileClanUncheckedUpdateWithoutClanInput>
    create: XOR<ProfileClanCreateWithoutClanInput, ProfileClanUncheckedCreateWithoutClanInput>
  }

  export type ProfileClanUpdateWithWhereUniqueWithoutClanInput = {
    where: ProfileClanWhereUniqueInput
    data: XOR<ProfileClanUpdateWithoutClanInput, ProfileClanUncheckedUpdateWithoutClanInput>
  }

  export type ProfileClanUpdateManyWithWhereWithoutClanInput = {
    where: ProfileClanScalarWhereInput
    data: XOR<ProfileClanUpdateManyMutationInput, ProfileClanUncheckedUpdateManyWithoutClanInput>
  }

  export type ProfileCreateWithoutClanTreeInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutClanTreeInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutClanTreeInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutClanTreeInput, ProfileUncheckedCreateWithoutClanTreeInput>
  }

  export type ClanCreateWithoutMembersInput = {
    id?: string
    name: string
  }

  export type ClanUncheckedCreateWithoutMembersInput = {
    id?: string
    name: string
  }

  export type ClanCreateOrConnectWithoutMembersInput = {
    where: ClanWhereUniqueInput
    create: XOR<ClanCreateWithoutMembersInput, ClanUncheckedCreateWithoutMembersInput>
  }

  export type ProfileUpsertWithoutClanTreeInput = {
    update: XOR<ProfileUpdateWithoutClanTreeInput, ProfileUncheckedUpdateWithoutClanTreeInput>
    create: XOR<ProfileCreateWithoutClanTreeInput, ProfileUncheckedCreateWithoutClanTreeInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutClanTreeInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutClanTreeInput, ProfileUncheckedUpdateWithoutClanTreeInput>
  }

  export type ProfileUpdateWithoutClanTreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutClanTreeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ClanUpsertWithoutMembersInput = {
    update: XOR<ClanUpdateWithoutMembersInput, ClanUncheckedUpdateWithoutMembersInput>
    create: XOR<ClanCreateWithoutMembersInput, ClanUncheckedCreateWithoutMembersInput>
    where?: ClanWhereInput
  }

  export type ClanUpdateToOneWithWhereWithoutMembersInput = {
    where?: ClanWhereInput
    data: XOR<ClanUpdateWithoutMembersInput, ClanUncheckedUpdateWithoutMembersInput>
  }

  export type ClanUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ClanUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileCreateWithoutLineagesCreatedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutLineagesCreatedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutLineagesCreatedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLineagesCreatedInput, ProfileUncheckedCreateWithoutLineagesCreatedInput>
  }

  export type LineageMembershipCreateWithoutLineageInput = {
    id?: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
    addedBy?: ProfileCreateNestedOneWithoutLineageMembershipsAddedInput
    profile: ProfileCreateNestedOneWithoutLineageMembershipsInput
  }

  export type LineageMembershipUncheckedCreateWithoutLineageInput = {
    id?: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type LineageMembershipCreateOrConnectWithoutLineageInput = {
    where: LineageMembershipWhereUniqueInput
    create: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput>
  }

  export type LineageMembershipCreateManyLineageInputEnvelope = {
    data: LineageMembershipCreateManyLineageInput | LineageMembershipCreateManyLineageInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutLineageInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    sender?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    request?: FriendRequestCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutLineageInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutLineageInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput>
  }

  export type NotificationCreateManyLineageInputEnvelope = {
    data: NotificationCreateManyLineageInput | NotificationCreateManyLineageInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutLineageInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
    author: ProfileCreateNestedOneWithoutPostsInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutLineageInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutLineageInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput>
  }

  export type PostCreateManyLineageInputEnvelope = {
    data: PostCreateManyLineageInput | PostCreateManyLineageInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutLineagesCreatedInput = {
    update: XOR<ProfileUpdateWithoutLineagesCreatedInput, ProfileUncheckedUpdateWithoutLineagesCreatedInput>
    create: XOR<ProfileCreateWithoutLineagesCreatedInput, ProfileUncheckedCreateWithoutLineagesCreatedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutLineagesCreatedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutLineagesCreatedInput, ProfileUncheckedUpdateWithoutLineagesCreatedInput>
  }

  export type ProfileUpdateWithoutLineagesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLineagesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type LineageMembershipUpsertWithWhereUniqueWithoutLineageInput = {
    where: LineageMembershipWhereUniqueInput
    update: XOR<LineageMembershipUpdateWithoutLineageInput, LineageMembershipUncheckedUpdateWithoutLineageInput>
    create: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput>
  }

  export type LineageMembershipUpdateWithWhereUniqueWithoutLineageInput = {
    where: LineageMembershipWhereUniqueInput
    data: XOR<LineageMembershipUpdateWithoutLineageInput, LineageMembershipUncheckedUpdateWithoutLineageInput>
  }

  export type LineageMembershipUpdateManyWithWhereWithoutLineageInput = {
    where: LineageMembershipScalarWhereInput
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyWithoutLineageInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutLineageInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutLineageInput, NotificationUncheckedUpdateWithoutLineageInput>
    create: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutLineageInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutLineageInput, NotificationUncheckedUpdateWithoutLineageInput>
  }

  export type NotificationUpdateManyWithWhereWithoutLineageInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutLineageInput>
  }

  export type PostUpsertWithWhereUniqueWithoutLineageInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutLineageInput, PostUncheckedUpdateWithoutLineageInput>
    create: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput>
  }

  export type PostUpdateWithWhereUniqueWithoutLineageInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutLineageInput, PostUncheckedUpdateWithoutLineageInput>
  }

  export type PostUpdateManyWithWhereWithoutLineageInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutLineageInput>
  }

  export type ProfileCreateWithoutLineageMembershipsAddedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutLineageMembershipsAddedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutLineageMembershipsAddedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLineageMembershipsAddedInput, ProfileUncheckedCreateWithoutLineageMembershipsAddedInput>
  }

  export type LineageCreateWithoutMembershipsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutLineagesCreatedInput
    notifications?: NotificationCreateNestedManyWithoutLineageInput
    posts?: PostCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutLineageInput
    posts?: PostUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageCreateOrConnectWithoutMembershipsInput = {
    where: LineageWhereUniqueInput
    create: XOR<LineageCreateWithoutMembershipsInput, LineageUncheckedCreateWithoutMembershipsInput>
  }

  export type ProfileCreateWithoutLineageMembershipsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutLineageMembershipsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutLineageMembershipsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLineageMembershipsInput, ProfileUncheckedCreateWithoutLineageMembershipsInput>
  }

  export type ProfileUpsertWithoutLineageMembershipsAddedInput = {
    update: XOR<ProfileUpdateWithoutLineageMembershipsAddedInput, ProfileUncheckedUpdateWithoutLineageMembershipsAddedInput>
    create: XOR<ProfileCreateWithoutLineageMembershipsAddedInput, ProfileUncheckedCreateWithoutLineageMembershipsAddedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutLineageMembershipsAddedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutLineageMembershipsAddedInput, ProfileUncheckedUpdateWithoutLineageMembershipsAddedInput>
  }

  export type ProfileUpdateWithoutLineageMembershipsAddedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLineageMembershipsAddedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type LineageUpsertWithoutMembershipsInput = {
    update: XOR<LineageUpdateWithoutMembershipsInput, LineageUncheckedUpdateWithoutMembershipsInput>
    create: XOR<LineageCreateWithoutMembershipsInput, LineageUncheckedCreateWithoutMembershipsInput>
    where?: LineageWhereInput
  }

  export type LineageUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: LineageWhereInput
    data: XOR<LineageUpdateWithoutMembershipsInput, LineageUncheckedUpdateWithoutMembershipsInput>
  }

  export type LineageUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutLineagesCreatedNestedInput
    notifications?: NotificationUpdateManyWithoutLineageNestedInput
    posts?: PostUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutLineageNestedInput
    posts?: PostUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type ProfileUpsertWithoutLineageMembershipsInput = {
    update: XOR<ProfileUpdateWithoutLineageMembershipsInput, ProfileUncheckedUpdateWithoutLineageMembershipsInput>
    create: XOR<ProfileCreateWithoutLineageMembershipsInput, ProfileUncheckedCreateWithoutLineageMembershipsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutLineageMembershipsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutLineageMembershipsInput, ProfileUncheckedUpdateWithoutLineageMembershipsInput>
  }

  export type ProfileUpdateWithoutLineageMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLineageMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileCreateWithoutKinshipsAInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutKinshipsAInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutKinshipsAInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutKinshipsAInput, ProfileUncheckedCreateWithoutKinshipsAInput>
  }

  export type ProfileCreateWithoutKinshipsBInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutKinshipsBInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutKinshipsBInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutKinshipsBInput, ProfileUncheckedCreateWithoutKinshipsBInput>
  }

  export type ProfileUpsertWithoutKinshipsAInput = {
    update: XOR<ProfileUpdateWithoutKinshipsAInput, ProfileUncheckedUpdateWithoutKinshipsAInput>
    create: XOR<ProfileCreateWithoutKinshipsAInput, ProfileUncheckedCreateWithoutKinshipsAInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutKinshipsAInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutKinshipsAInput, ProfileUncheckedUpdateWithoutKinshipsAInput>
  }

  export type ProfileUpdateWithoutKinshipsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutKinshipsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUpsertWithoutKinshipsBInput = {
    update: XOR<ProfileUpdateWithoutKinshipsBInput, ProfileUncheckedUpdateWithoutKinshipsBInput>
    create: XOR<ProfileCreateWithoutKinshipsBInput, ProfileUncheckedCreateWithoutKinshipsBInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutKinshipsBInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutKinshipsBInput, ProfileUncheckedUpdateWithoutKinshipsBInput>
  }

  export type ProfileUpdateWithoutKinshipsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutKinshipsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileCreateWithoutBlocksAsBlockedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutBlocksAsBlockedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutBlocksAsBlockedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutBlocksAsBlockedInput, ProfileUncheckedCreateWithoutBlocksAsBlockedInput>
  }

  export type ProfileCreateWithoutBlocksAsBlockerInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutBlocksAsBlockerInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutBlocksAsBlockerInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutBlocksAsBlockerInput, ProfileUncheckedCreateWithoutBlocksAsBlockerInput>
  }

  export type ProfileUpsertWithoutBlocksAsBlockedInput = {
    update: XOR<ProfileUpdateWithoutBlocksAsBlockedInput, ProfileUncheckedUpdateWithoutBlocksAsBlockedInput>
    create: XOR<ProfileCreateWithoutBlocksAsBlockedInput, ProfileUncheckedCreateWithoutBlocksAsBlockedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutBlocksAsBlockedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutBlocksAsBlockedInput, ProfileUncheckedUpdateWithoutBlocksAsBlockedInput>
  }

  export type ProfileUpdateWithoutBlocksAsBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutBlocksAsBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUpsertWithoutBlocksAsBlockerInput = {
    update: XOR<ProfileUpdateWithoutBlocksAsBlockerInput, ProfileUncheckedUpdateWithoutBlocksAsBlockerInput>
    create: XOR<ProfileCreateWithoutBlocksAsBlockerInput, ProfileUncheckedCreateWithoutBlocksAsBlockerInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutBlocksAsBlockerInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutBlocksAsBlockerInput, ProfileUncheckedUpdateWithoutBlocksAsBlockerInput>
  }

  export type ProfileUpdateWithoutBlocksAsBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutBlocksAsBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileCreateWithoutMutesAsMutedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutMutesAsMutedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutMutesAsMutedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMutesAsMutedInput, ProfileUncheckedCreateWithoutMutesAsMutedInput>
  }

  export type ProfileCreateWithoutMutesAsMuterInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutMutesAsMuterInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutMutesAsMuterInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMutesAsMuterInput, ProfileUncheckedCreateWithoutMutesAsMuterInput>
  }

  export type ProfileUpsertWithoutMutesAsMutedInput = {
    update: XOR<ProfileUpdateWithoutMutesAsMutedInput, ProfileUncheckedUpdateWithoutMutesAsMutedInput>
    create: XOR<ProfileCreateWithoutMutesAsMutedInput, ProfileUncheckedCreateWithoutMutesAsMutedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMutesAsMutedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMutesAsMutedInput, ProfileUncheckedUpdateWithoutMutesAsMutedInput>
  }

  export type ProfileUpdateWithoutMutesAsMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMutesAsMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUpsertWithoutMutesAsMuterInput = {
    update: XOR<ProfileUpdateWithoutMutesAsMuterInput, ProfileUncheckedUpdateWithoutMutesAsMuterInput>
    create: XOR<ProfileCreateWithoutMutesAsMuterInput, ProfileUncheckedCreateWithoutMutesAsMuterInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMutesAsMuterInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMutesAsMuterInput, ProfileUncheckedUpdateWithoutMutesAsMuterInput>
  }

  export type ProfileUpdateWithoutMutesAsMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMutesAsMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type MediaFileCreateWithoutPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaFileUncheckedCreateWithoutPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaFileCreateOrConnectWithoutPostInput = {
    where: MediaFileWhereUniqueInput
    create: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput>
  }

  export type MediaFileCreateManyPostInputEnvelope = {
    data: MediaFileCreateManyPostInput | MediaFileCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutPostInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    sender?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    request?: FriendRequestCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutPostInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutPostInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput>
  }

  export type NotificationCreateManyPostInputEnvelope = {
    data: NotificationCreateManyPostInput | NotificationCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type LineageCreateWithoutPostsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutLineagesCreatedInput
    memberships?: LineageMembershipCreateNestedManyWithoutLineageInput
    notifications?: NotificationCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipUncheckedCreateNestedManyWithoutLineageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageCreateOrConnectWithoutPostsInput = {
    where: LineageWhereUniqueInput
    create: XOR<LineageCreateWithoutPostsInput, LineageUncheckedCreateWithoutPostsInput>
  }

  export type ProfileCreateWithoutPostsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutPostsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutPostsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
  }

  export type PostReactionCreateWithoutPostInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostReactionsInput
  }

  export type PostReactionUncheckedCreateWithoutPostInput = {
    id?: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type PostReactionCreateOrConnectWithoutPostInput = {
    where: PostReactionWhereUniqueInput
    create: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput>
  }

  export type PostReactionCreateManyPostInputEnvelope = {
    data: PostReactionCreateManyPostInput | PostReactionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type MediaFileUpsertWithWhereUniqueWithoutPostInput = {
    where: MediaFileWhereUniqueInput
    update: XOR<MediaFileUpdateWithoutPostInput, MediaFileUncheckedUpdateWithoutPostInput>
    create: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput>
  }

  export type MediaFileUpdateWithWhereUniqueWithoutPostInput = {
    where: MediaFileWhereUniqueInput
    data: XOR<MediaFileUpdateWithoutPostInput, MediaFileUncheckedUpdateWithoutPostInput>
  }

  export type MediaFileUpdateManyWithWhereWithoutPostInput = {
    where: MediaFileScalarWhereInput
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyWithoutPostInput>
  }

  export type MediaFileScalarWhereInput = {
    AND?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
    OR?: MediaFileScalarWhereInput[]
    NOT?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
    id?: UuidFilter<"MediaFile"> | string
    postId?: UuidFilter<"MediaFile"> | string
    type?: EnumMediaTypeFilter<"MediaFile"> | $Enums.MediaType
    url?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    width?: IntNullableFilter<"MediaFile"> | number | null
    height?: IntNullableFilter<"MediaFile"> | number | null
    sizeBytes?: IntFilter<"MediaFile"> | number
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    updatedAt?: DateTimeFilter<"MediaFile"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutPostInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutPostInput, NotificationUncheckedUpdateWithoutPostInput>
    create: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutPostInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutPostInput, NotificationUncheckedUpdateWithoutPostInput>
  }

  export type NotificationUpdateManyWithWhereWithoutPostInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutPostInput>
  }

  export type LineageUpsertWithoutPostsInput = {
    update: XOR<LineageUpdateWithoutPostsInput, LineageUncheckedUpdateWithoutPostsInput>
    create: XOR<LineageCreateWithoutPostsInput, LineageUncheckedCreateWithoutPostsInput>
    where?: LineageWhereInput
  }

  export type LineageUpdateToOneWithWhereWithoutPostsInput = {
    where?: LineageWhereInput
    data: XOR<LineageUpdateWithoutPostsInput, LineageUncheckedUpdateWithoutPostsInput>
  }

  export type LineageUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutLineagesCreatedNestedInput
    memberships?: LineageMembershipUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type ProfileUpsertWithoutPostsInput = {
    update: XOR<ProfileUpdateWithoutPostsInput, ProfileUncheckedUpdateWithoutPostsInput>
    create: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostsInput, ProfileUncheckedUpdateWithoutPostsInput>
  }

  export type ProfileUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type PostReactionUpsertWithWhereUniqueWithoutPostInput = {
    where: PostReactionWhereUniqueInput
    update: XOR<PostReactionUpdateWithoutPostInput, PostReactionUncheckedUpdateWithoutPostInput>
    create: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput>
  }

  export type PostReactionUpdateWithWhereUniqueWithoutPostInput = {
    where: PostReactionWhereUniqueInput
    data: XOR<PostReactionUpdateWithoutPostInput, PostReactionUncheckedUpdateWithoutPostInput>
  }

  export type PostReactionUpdateManyWithWhereWithoutPostInput = {
    where: PostReactionScalarWhereInput
    data: XOR<PostReactionUpdateManyMutationInput, PostReactionUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutMediaFilesInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    author: ProfileCreateNestedOneWithoutPostsInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutMediaFilesInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutMediaFilesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutMediaFilesInput, PostUncheckedCreateWithoutMediaFilesInput>
  }

  export type PostUpsertWithoutMediaFilesInput = {
    update: XOR<PostUpdateWithoutMediaFilesInput, PostUncheckedUpdateWithoutMediaFilesInput>
    create: XOR<PostCreateWithoutMediaFilesInput, PostUncheckedCreateWithoutMediaFilesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutMediaFilesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutMediaFilesInput, PostUncheckedUpdateWithoutMediaFilesInput>
  }

  export type PostUpdateWithoutMediaFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutMediaFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentCommentInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutParentCommentInput = {
    id?: string
    postId: string
    profileId: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentCreateManyParentCommentInputEnvelope = {
    data: CommentCreateManyParentCommentInput | CommentCreateManyParentCommentInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    author: ProfileCreateNestedOneWithoutPostsInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type ProfileCreateWithoutCommentsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutCommentsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutCommentsInput, ProfileUncheckedCreateWithoutCommentsInput>
  }

  export type CommentReactionCreateWithoutCommentInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutCommentReactionsInput
  }

  export type CommentReactionUncheckedCreateWithoutCommentInput = {
    id?: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentReactionCreateOrConnectWithoutCommentInput = {
    where: CommentReactionWhereUniqueInput
    create: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput>
  }

  export type CommentReactionCreateManyCommentInputEnvelope = {
    data: CommentReactionCreateManyCommentInput | CommentReactionCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutCommentInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    sender?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    request?: FriendRequestCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCommentInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput>
  }

  export type NotificationCreateManyCommentInputEnvelope = {
    data: NotificationCreateManyCommentInput | NotificationCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentCommentInput>
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ProfileUpsertWithoutCommentsInput = {
    update: XOR<ProfileUpdateWithoutCommentsInput, ProfileUncheckedUpdateWithoutCommentsInput>
    create: XOR<ProfileCreateWithoutCommentsInput, ProfileUncheckedCreateWithoutCommentsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutCommentsInput, ProfileUncheckedUpdateWithoutCommentsInput>
  }

  export type ProfileUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type CommentReactionUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentReactionWhereUniqueInput
    update: XOR<CommentReactionUpdateWithoutCommentInput, CommentReactionUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput>
  }

  export type CommentReactionUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentReactionWhereUniqueInput
    data: XOR<CommentReactionUpdateWithoutCommentInput, CommentReactionUncheckedUpdateWithoutCommentInput>
  }

  export type CommentReactionUpdateManyWithWhereWithoutCommentInput = {
    where: CommentReactionScalarWhereInput
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyWithoutCommentInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCommentInput, NotificationUncheckedUpdateWithoutCommentInput>
    create: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCommentInput, NotificationUncheckedUpdateWithoutCommentInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCommentInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCommentInput>
  }

  export type PostCreateWithoutReactionsInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    author: ProfileCreateNestedOneWithoutPostsInput
  }

  export type PostUncheckedCreateWithoutReactionsInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutReactionsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
  }

  export type ProfileCreateWithoutPostReactionsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutPostReactionsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutPostReactionsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostReactionsInput, ProfileUncheckedCreateWithoutPostReactionsInput>
  }

  export type PostUpsertWithoutReactionsInput = {
    update: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReactionsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type PostUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
  }

  export type PostUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ProfileUpsertWithoutPostReactionsInput = {
    update: XOR<ProfileUpdateWithoutPostReactionsInput, ProfileUncheckedUpdateWithoutPostReactionsInput>
    create: XOR<ProfileCreateWithoutPostReactionsInput, ProfileUncheckedCreateWithoutPostReactionsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostReactionsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostReactionsInput, ProfileUncheckedUpdateWithoutPostReactionsInput>
  }

  export type ProfileUpdateWithoutPostReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type CommentCreateWithoutReactionsInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutReactionsInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutReactionsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
  }

  export type ProfileCreateWithoutCommentReactionsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutCommentReactionsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutCommentReactionsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutCommentReactionsInput, ProfileUncheckedCreateWithoutCommentReactionsInput>
  }

  export type CommentUpsertWithoutReactionsInput = {
    update: XOR<CommentUpdateWithoutReactionsInput, CommentUncheckedUpdateWithoutReactionsInput>
    create: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutReactionsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutReactionsInput, CommentUncheckedUpdateWithoutReactionsInput>
  }

  export type CommentUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ProfileUpsertWithoutCommentReactionsInput = {
    update: XOR<ProfileUpdateWithoutCommentReactionsInput, ProfileUncheckedUpdateWithoutCommentReactionsInput>
    create: XOR<ProfileCreateWithoutCommentReactionsInput, ProfileUncheckedCreateWithoutCommentReactionsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutCommentReactionsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutCommentReactionsInput, ProfileUncheckedUpdateWithoutCommentReactionsInput>
  }

  export type ProfileUpdateWithoutCommentReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutCommentReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileCreateWithoutConversationsOwnedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutConversationsOwnedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutConversationsOwnedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutConversationsOwnedInput, ProfileUncheckedCreateWithoutConversationsOwnedInput>
  }

  export type ConversationParticipantCreateWithoutConversationInput = {
    id?: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutConversationMembersInput
  }

  export type ConversationParticipantUncheckedCreateWithoutConversationInput = {
    id?: string
    profileId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantCreateManyConversationInputEnvelope = {
    data: ConversationParticipantCreateManyConversationInput | ConversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    sender: ProfileCreateNestedOneWithoutMessagesInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
    notifications?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutConversationsOwnedInput = {
    update: XOR<ProfileUpdateWithoutConversationsOwnedInput, ProfileUncheckedUpdateWithoutConversationsOwnedInput>
    create: XOR<ProfileCreateWithoutConversationsOwnedInput, ProfileUncheckedCreateWithoutConversationsOwnedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutConversationsOwnedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutConversationsOwnedInput, ProfileUncheckedUpdateWithoutConversationsOwnedInput>
  }

  export type ProfileUpdateWithoutConversationsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutConversationsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutParticipantsInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutConversationsOwnedInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById?: string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type ProfileCreateWithoutConversationMembersInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutConversationMembersInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutConversationMembersInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutConversationMembersInput, ProfileUncheckedCreateWithoutConversationMembersInput>
  }

  export type ConversationUpsertWithoutParticipantsInput = {
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutConversationsOwnedNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ProfileUpsertWithoutConversationMembersInput = {
    update: XOR<ProfileUpdateWithoutConversationMembersInput, ProfileUncheckedUpdateWithoutConversationMembersInput>
    create: XOR<ProfileCreateWithoutConversationMembersInput, ProfileUncheckedCreateWithoutConversationMembersInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutConversationMembersInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutConversationMembersInput, ProfileUncheckedUpdateWithoutConversationMembersInput>
  }

  export type ProfileUpdateWithoutConversationMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutConversationMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutConversationsOwnedInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById?: string | null
    createdAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ProfileCreateWithoutMessagesInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutMessagesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMessagesInput, ProfileUncheckedCreateWithoutMessagesInput>
  }

  export type MessageReadCreateWithoutMessageInput = {
    readAt?: Date | string
    user: ProfileCreateNestedOneWithoutMessageReadsInput
  }

  export type MessageReadUncheckedCreateWithoutMessageInput = {
    userId: string
    readAt?: Date | string
  }

  export type MessageReadCreateOrConnectWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    create: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadCreateManyMessageInputEnvelope = {
    data: MessageReadCreateManyMessageInput | MessageReadCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutMessageInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    sender?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    request?: FriendRequestCreateNestedOneWithoutNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutMessageInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutMessageInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput>
  }

  export type NotificationCreateManyMessageInputEnvelope = {
    data: NotificationCreateManyMessageInput | NotificationCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutConversationsOwnedNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ProfileUpsertWithoutMessagesInput = {
    update: XOR<ProfileUpdateWithoutMessagesInput, ProfileUncheckedUpdateWithoutMessagesInput>
    create: XOR<ProfileCreateWithoutMessagesInput, ProfileUncheckedCreateWithoutMessagesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMessagesInput, ProfileUncheckedUpdateWithoutMessagesInput>
  }

  export type ProfileUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type MessageReadUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    update: XOR<MessageReadUpdateWithoutMessageInput, MessageReadUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    data: XOR<MessageReadUpdateWithoutMessageInput, MessageReadUncheckedUpdateWithoutMessageInput>
  }

  export type MessageReadUpdateManyWithWhereWithoutMessageInput = {
    where: MessageReadScalarWhereInput
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyWithoutMessageInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutMessageInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutMessageInput, NotificationUncheckedUpdateWithoutMessageInput>
    create: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutMessageInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutMessageInput, NotificationUncheckedUpdateWithoutMessageInput>
  }

  export type NotificationUpdateManyWithWhereWithoutMessageInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutMessageInput>
  }

  export type ProfileCreateWithoutNotificationsAsActorInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutNotificationsAsActorInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutNotificationsAsActorInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutNotificationsAsActorInput, ProfileUncheckedCreateWithoutNotificationsAsActorInput>
  }

  export type CommentCreateWithoutNotificationsInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutNotificationsInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutNotificationsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
  }

  export type LineageCreateWithoutNotificationsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutLineagesCreatedInput
    memberships?: LineageMembershipCreateNestedManyWithoutLineageInput
    posts?: PostCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipUncheckedCreateNestedManyWithoutLineageInput
    posts?: PostUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageCreateOrConnectWithoutNotificationsInput = {
    where: LineageWhereUniqueInput
    create: XOR<LineageCreateWithoutNotificationsInput, LineageUncheckedCreateWithoutNotificationsInput>
  }

  export type FriendRequestCreateWithoutNotificationsInput = {
    id?: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
    requester: ProfileCreateNestedOneWithoutSentFriendRequestsInput
    addressee: ProfileCreateNestedOneWithoutReceivedFriendRequestsInput
  }

  export type FriendRequestUncheckedCreateWithoutNotificationsInput = {
    id?: string
    requesterId: string
    addresseeId: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type FriendRequestCreateOrConnectWithoutNotificationsInput = {
    where: FriendRequestWhereUniqueInput
    create: XOR<FriendRequestCreateWithoutNotificationsInput, FriendRequestUncheckedCreateWithoutNotificationsInput>
  }

  export type MessageCreateWithoutNotificationsInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: ProfileCreateNestedOneWithoutMessagesInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutNotificationsInput = {
    id?: string
    conversationId: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutNotificationsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutNotificationsInput, MessageUncheckedCreateWithoutNotificationsInput>
  }

  export type PostCreateWithoutNotificationsInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    author: ProfileCreateNestedOneWithoutPostsInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutNotificationsInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutNotificationsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
  }

  export type ProfileCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutNotificationsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutNotificationsInput, ProfileUncheckedCreateWithoutNotificationsInput>
  }

  export type ProfileUpsertWithoutNotificationsAsActorInput = {
    update: XOR<ProfileUpdateWithoutNotificationsAsActorInput, ProfileUncheckedUpdateWithoutNotificationsAsActorInput>
    create: XOR<ProfileCreateWithoutNotificationsAsActorInput, ProfileUncheckedCreateWithoutNotificationsAsActorInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutNotificationsAsActorInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutNotificationsAsActorInput, ProfileUncheckedUpdateWithoutNotificationsAsActorInput>
  }

  export type ProfileUpdateWithoutNotificationsAsActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutNotificationsAsActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type CommentUpsertWithoutNotificationsInput = {
    update: XOR<CommentUpdateWithoutNotificationsInput, CommentUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutNotificationsInput, CommentUncheckedUpdateWithoutNotificationsInput>
  }

  export type CommentUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type LineageUpsertWithoutNotificationsInput = {
    update: XOR<LineageUpdateWithoutNotificationsInput, LineageUncheckedUpdateWithoutNotificationsInput>
    create: XOR<LineageCreateWithoutNotificationsInput, LineageUncheckedCreateWithoutNotificationsInput>
    where?: LineageWhereInput
  }

  export type LineageUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: LineageWhereInput
    data: XOR<LineageUpdateWithoutNotificationsInput, LineageUncheckedUpdateWithoutNotificationsInput>
  }

  export type LineageUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutLineagesCreatedNestedInput
    memberships?: LineageMembershipUpdateManyWithoutLineageNestedInput
    posts?: PostUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput
    posts?: PostUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type FriendRequestUpsertWithoutNotificationsInput = {
    update: XOR<FriendRequestUpdateWithoutNotificationsInput, FriendRequestUncheckedUpdateWithoutNotificationsInput>
    create: XOR<FriendRequestCreateWithoutNotificationsInput, FriendRequestUncheckedCreateWithoutNotificationsInput>
    where?: FriendRequestWhereInput
  }

  export type FriendRequestUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: FriendRequestWhereInput
    data: XOR<FriendRequestUpdateWithoutNotificationsInput, FriendRequestUncheckedUpdateWithoutNotificationsInput>
  }

  export type FriendRequestUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requester?: ProfileUpdateOneRequiredWithoutSentFriendRequestsNestedInput
    addressee?: ProfileUpdateOneRequiredWithoutReceivedFriendRequestsNestedInput
  }

  export type FriendRequestUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpsertWithoutNotificationsInput = {
    update: XOR<MessageUpdateWithoutNotificationsInput, MessageUncheckedUpdateWithoutNotificationsInput>
    create: XOR<MessageCreateWithoutNotificationsInput, MessageUncheckedCreateWithoutNotificationsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutNotificationsInput, MessageUncheckedUpdateWithoutNotificationsInput>
  }

  export type MessageUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: ProfileUpdateOneRequiredWithoutMessagesNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type PostUpsertWithoutNotificationsInput = {
    update: XOR<PostUpdateWithoutNotificationsInput, PostUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutNotificationsInput, PostUncheckedUpdateWithoutNotificationsInput>
  }

  export type PostUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ProfileUpsertWithoutNotificationsInput = {
    update: XOR<ProfileUpdateWithoutNotificationsInput, ProfileUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ProfileCreateWithoutNotificationsInput, ProfileUncheckedCreateWithoutNotificationsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutNotificationsInput, ProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProfileUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileInterestCreateWithoutInterestInput = {
    createdAt?: Date | string
    user: ProfileCreateNestedOneWithoutInterestsInput
  }

  export type ProfileInterestUncheckedCreateWithoutInterestInput = {
    userId: string
    createdAt?: Date | string
  }

  export type ProfileInterestCreateOrConnectWithoutInterestInput = {
    where: ProfileInterestWhereUniqueInput
    create: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput>
  }

  export type ProfileInterestCreateManyInterestInputEnvelope = {
    data: ProfileInterestCreateManyInterestInput | ProfileInterestCreateManyInterestInput[]
    skipDuplicates?: boolean
  }

  export type ProfileInterestUpsertWithWhereUniqueWithoutInterestInput = {
    where: ProfileInterestWhereUniqueInput
    update: XOR<ProfileInterestUpdateWithoutInterestInput, ProfileInterestUncheckedUpdateWithoutInterestInput>
    create: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput>
  }

  export type ProfileInterestUpdateWithWhereUniqueWithoutInterestInput = {
    where: ProfileInterestWhereUniqueInput
    data: XOR<ProfileInterestUpdateWithoutInterestInput, ProfileInterestUncheckedUpdateWithoutInterestInput>
  }

  export type ProfileInterestUpdateManyWithWhereWithoutInterestInput = {
    where: ProfileInterestScalarWhereInput
    data: XOR<ProfileInterestUpdateManyMutationInput, ProfileInterestUncheckedUpdateManyWithoutInterestInput>
  }

  export type ProfileAppInterestsCreateWithoutInterestInput = {
    createdAt?: Date | string
    user: ProfileCreateNestedOneWithoutAppInterestsInput
  }

  export type ProfileAppInterestsUncheckedCreateWithoutInterestInput = {
    userId: string
    createdAt?: Date | string
  }

  export type ProfileAppInterestsCreateOrConnectWithoutInterestInput = {
    where: ProfileAppInterestsWhereUniqueInput
    create: XOR<ProfileAppInterestsCreateWithoutInterestInput, ProfileAppInterestsUncheckedCreateWithoutInterestInput>
  }

  export type ProfileAppInterestsCreateManyInterestInputEnvelope = {
    data: ProfileAppInterestsCreateManyInterestInput | ProfileAppInterestsCreateManyInterestInput[]
    skipDuplicates?: boolean
  }

  export type ProfileAppInterestsUpsertWithWhereUniqueWithoutInterestInput = {
    where: ProfileAppInterestsWhereUniqueInput
    update: XOR<ProfileAppInterestsUpdateWithoutInterestInput, ProfileAppInterestsUncheckedUpdateWithoutInterestInput>
    create: XOR<ProfileAppInterestsCreateWithoutInterestInput, ProfileAppInterestsUncheckedCreateWithoutInterestInput>
  }

  export type ProfileAppInterestsUpdateWithWhereUniqueWithoutInterestInput = {
    where: ProfileAppInterestsWhereUniqueInput
    data: XOR<ProfileAppInterestsUpdateWithoutInterestInput, ProfileAppInterestsUncheckedUpdateWithoutInterestInput>
  }

  export type ProfileAppInterestsUpdateManyWithWhereWithoutInterestInput = {
    where: ProfileAppInterestsScalarWhereInput
    data: XOR<ProfileAppInterestsUpdateManyMutationInput, ProfileAppInterestsUncheckedUpdateManyWithoutInterestInput>
  }

  export type InterestCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type InterestUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type InterestCreateOrConnectWithoutUsersInput = {
    where: InterestWhereUniqueInput
    create: XOR<InterestCreateWithoutUsersInput, InterestUncheckedCreateWithoutUsersInput>
  }

  export type ProfileCreateWithoutInterestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutInterestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutInterestsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
  }

  export type InterestUpsertWithoutUsersInput = {
    update: XOR<InterestUpdateWithoutUsersInput, InterestUncheckedUpdateWithoutUsersInput>
    create: XOR<InterestCreateWithoutUsersInput, InterestUncheckedCreateWithoutUsersInput>
    where?: InterestWhereInput
  }

  export type InterestUpdateToOneWithWhereWithoutUsersInput = {
    where?: InterestWhereInput
    data: XOR<InterestUpdateWithoutUsersInput, InterestUncheckedUpdateWithoutUsersInput>
  }

  export type InterestUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InterestUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUpsertWithoutInterestsInput = {
    update: XOR<ProfileUpdateWithoutInterestsInput, ProfileUncheckedUpdateWithoutInterestsInput>
    create: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutInterestsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutInterestsInput, ProfileUncheckedUpdateWithoutInterestsInput>
  }

  export type ProfileUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type AppInterestCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type AppInterestUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type AppInterestCreateOrConnectWithoutUsersInput = {
    where: AppInterestWhereUniqueInput
    create: XOR<AppInterestCreateWithoutUsersInput, AppInterestUncheckedCreateWithoutUsersInput>
  }

  export type ProfileCreateWithoutAppInterestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutAppInterestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutAppInterestsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutAppInterestsInput, ProfileUncheckedCreateWithoutAppInterestsInput>
  }

  export type AppInterestUpsertWithoutUsersInput = {
    update: XOR<AppInterestUpdateWithoutUsersInput, AppInterestUncheckedUpdateWithoutUsersInput>
    create: XOR<AppInterestCreateWithoutUsersInput, AppInterestUncheckedCreateWithoutUsersInput>
    where?: AppInterestWhereInput
  }

  export type AppInterestUpdateToOneWithWhereWithoutUsersInput = {
    where?: AppInterestWhereInput
    data: XOR<AppInterestUpdateWithoutUsersInput, AppInterestUncheckedUpdateWithoutUsersInput>
  }

  export type AppInterestUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type AppInterestUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileUpsertWithoutAppInterestsInput = {
    update: XOR<ProfileUpdateWithoutAppInterestsInput, ProfileUncheckedUpdateWithoutAppInterestsInput>
    create: XOR<ProfileCreateWithoutAppInterestsInput, ProfileUncheckedCreateWithoutAppInterestsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutAppInterestsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutAppInterestsInput, ProfileUncheckedUpdateWithoutAppInterestsInput>
  }

  export type ProfileUpdateWithoutAppInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutAppInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type MessageCreateWithoutReadsInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: ProfileCreateNestedOneWithoutMessagesInput
    notifications?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutReadsInput = {
    id?: string
    conversationId: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutReadsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
  }

  export type ProfileCreateWithoutMessageReadsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    product?: ProductCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutMessageReadsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    product?: ProductUncheckedCreateNestedManyWithoutSellerInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutMessageReadsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMessageReadsInput, ProfileUncheckedCreateWithoutMessageReadsInput>
  }

  export type MessageUpsertWithoutReadsInput = {
    update: XOR<MessageUpdateWithoutReadsInput, MessageUncheckedUpdateWithoutReadsInput>
    create: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReadsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReadsInput, MessageUncheckedUpdateWithoutReadsInput>
  }

  export type MessageUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: ProfileUpdateOneRequiredWithoutMessagesNestedInput
    notifications?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type ProfileUpsertWithoutMessageReadsInput = {
    update: XOR<ProfileUpdateWithoutMessageReadsInput, ProfileUncheckedUpdateWithoutMessageReadsInput>
    create: XOR<ProfileCreateWithoutMessageReadsInput, ProfileUncheckedCreateWithoutMessageReadsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMessageReadsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMessageReadsInput, ProfileUncheckedUpdateWithoutMessageReadsInput>
  }

  export type ProfileUpdateWithoutMessageReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    product?: ProductUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMessageReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    product?: ProductUncheckedUpdateManyWithoutSellerNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProfileCreateWithoutProductInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutSenderInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipCreateNestedManyWithoutUserBInput
  }

  export type ProfileUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    fullName?: string | null
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    email: string
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    profession?: string | null
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ethnicity?: string | null
    occupation?: string | null
    isProfileComplete?: boolean
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    clanTree?: ProfileClanUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutSenderInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    appInterests?: ProfileAppInterestsUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    sentFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutRequesterInput
    receivedFriendRequests?: FriendRequestUncheckedCreateNestedManyWithoutAddresseeInput
    friendshipsA?: FriendshipUncheckedCreateNestedManyWithoutUserAInput
    friendshipsB?: FriendshipUncheckedCreateNestedManyWithoutUserBInput
  }

  export type ProfileCreateOrConnectWithoutProductInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutProductInput, ProfileUncheckedCreateWithoutProductInput>
  }

  export type ProductMediaCreateWithoutProductInput = {
    id?: string
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    orderIndex?: number
    isCover?: boolean
    createdAt?: Date | string
  }

  export type ProductMediaUncheckedCreateWithoutProductInput = {
    id?: string
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    orderIndex?: number
    isCover?: boolean
    createdAt?: Date | string
  }

  export type ProductMediaCreateOrConnectWithoutProductInput = {
    where: ProductMediaWhereUniqueInput
    create: XOR<ProductMediaCreateWithoutProductInput, ProductMediaUncheckedCreateWithoutProductInput>
  }

  export type ProductMediaCreateManyProductInputEnvelope = {
    data: ProductMediaCreateManyProductInput | ProductMediaCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutProductInput = {
    update: XOR<ProfileUpdateWithoutProductInput, ProfileUncheckedUpdateWithoutProductInput>
    create: XOR<ProfileCreateWithoutProductInput, ProfileUncheckedCreateWithoutProductInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutProductInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutProductInput, ProfileUncheckedUpdateWithoutProductInput>
  }

  export type ProfileUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUpdateManyWithoutUserBNestedInput
  }

  export type ProfileUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    email?: StringFieldUpdateOperationsInput | string
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    occupation?: NullableStringFieldUpdateOperationsInput | string | null
    isProfileComplete?: BoolFieldUpdateOperationsInput | boolean
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    clanTree?: ProfileClanUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutSenderNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    appInterests?: ProfileAppInterestsUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    sentFriendRequests?: FriendRequestUncheckedUpdateManyWithoutRequesterNestedInput
    receivedFriendRequests?: FriendRequestUncheckedUpdateManyWithoutAddresseeNestedInput
    friendshipsA?: FriendshipUncheckedUpdateManyWithoutUserANestedInput
    friendshipsB?: FriendshipUncheckedUpdateManyWithoutUserBNestedInput
  }

  export type ProductMediaUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductMediaWhereUniqueInput
    update: XOR<ProductMediaUpdateWithoutProductInput, ProductMediaUncheckedUpdateWithoutProductInput>
    create: XOR<ProductMediaCreateWithoutProductInput, ProductMediaUncheckedCreateWithoutProductInput>
  }

  export type ProductMediaUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductMediaWhereUniqueInput
    data: XOR<ProductMediaUpdateWithoutProductInput, ProductMediaUncheckedUpdateWithoutProductInput>
  }

  export type ProductMediaUpdateManyWithWhereWithoutProductInput = {
    where: ProductMediaScalarWhereInput
    data: XOR<ProductMediaUpdateManyMutationInput, ProductMediaUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductMediaScalarWhereInput = {
    AND?: ProductMediaScalarWhereInput | ProductMediaScalarWhereInput[]
    OR?: ProductMediaScalarWhereInput[]
    NOT?: ProductMediaScalarWhereInput | ProductMediaScalarWhereInput[]
    id?: UuidFilter<"ProductMedia"> | string
    productId?: UuidFilter<"ProductMedia"> | string
    url?: StringFilter<"ProductMedia"> | string
    mimeType?: StringFilter<"ProductMedia"> | string
    width?: IntNullableFilter<"ProductMedia"> | number | null
    height?: IntNullableFilter<"ProductMedia"> | number | null
    sizeBytes?: IntFilter<"ProductMedia"> | number
    orderIndex?: IntFilter<"ProductMedia"> | number
    isCover?: BoolFilter<"ProductMedia"> | boolean
    createdAt?: DateTimeFilter<"ProductMedia"> | Date | string
  }

  export type ProductCreateWithoutMediaInput = {
    id?: string
    visibility?: $Enums.PostVisibility
    title: string
    price: number
    currency?: string
    description: string
    category: string
    condition?: $Enums.ProductCondition
    negotiable?: boolean
    availability: $Enums.Available
    status?: $Enums.ListingStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    deletedAt?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    locationText?: string | null
    lat?: number | null
    lng?: number | null
    viewCount?: number
    saveCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    seller: ProfileCreateNestedOneWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutMediaInput = {
    id?: string
    sellerId: string
    visibility?: $Enums.PostVisibility
    title: string
    price: number
    currency?: string
    description: string
    category: string
    condition?: $Enums.ProductCondition
    negotiable?: boolean
    availability: $Enums.Available
    status?: $Enums.ListingStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    deletedAt?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    locationText?: string | null
    lat?: number | null
    lng?: number | null
    viewCount?: number
    saveCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutMediaInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutMediaInput, ProductUncheckedCreateWithoutMediaInput>
  }

  export type ProductUpsertWithoutMediaInput = {
    update: XOR<ProductUpdateWithoutMediaInput, ProductUncheckedUpdateWithoutMediaInput>
    create: XOR<ProductCreateWithoutMediaInput, ProductUncheckedCreateWithoutMediaInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutMediaInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutMediaInput, ProductUncheckedUpdateWithoutMediaInput>
  }

  export type ProductUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    negotiable?: BoolFieldUpdateOperationsInput | boolean
    availability?: EnumAvailableFieldUpdateOperationsInput | $Enums.Available
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    saveCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: ProfileUpdateOneRequiredWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    sellerId?: StringFieldUpdateOperationsInput | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    negotiable?: BoolFieldUpdateOperationsInput | boolean
    availability?: EnumAvailableFieldUpdateOperationsInput | $Enums.Available
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    saveCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyBlockedInput = {
    id?: string
    blockerId: string
    createdAt?: Date | string
  }

  export type BlockCreateManyBlockerInput = {
    id?: string
    blockedId: string
    createdAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    postId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentReactionCreateManyProfileInput = {
    id?: string
    commentId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ConversationCreateManyCreatedByInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
  }

  export type ConversationParticipantCreateManyProfileInput = {
    id?: string
    conversationId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ProfileClanCreateManyProfileInput = {
    id?: string
    clanId: string
    order: number
  }

  export type KinshipCreateManyProfileAInput = {
    id?: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipCreateManyProfileBInput = {
    id?: string
    profileIdA: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type LineageCreateManyCreatedByInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LineageMembershipCreateManyAddedByInput = {
    id?: string
    lineageId: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
  }

  export type LineageMembershipCreateManyProfileInput = {
    id?: string
    lineageId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type MessageReadCreateManyUserInput = {
    messageId: string
    readAt?: Date | string
  }

  export type MuteCreateManyMutedInput = {
    id?: string
    muterId: string
    createdAt?: Date | string
  }

  export type MuteCreateManyMuterInput = {
    id?: string
    mutedId: string
    createdAt?: Date | string
  }

  export type NotificationCreateManySenderInput = {
    id?: string
    recipientId: string
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostReactionCreateManyProfileInput = {
    id?: string
    postId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type ProductCreateManySellerInput = {
    id?: string
    visibility?: $Enums.PostVisibility
    title: string
    price: number
    currency?: string
    description: string
    category: string
    condition?: $Enums.ProductCondition
    negotiable?: boolean
    availability: $Enums.Available
    status?: $Enums.ListingStatus
    publishedAt?: Date | string | null
    expiresAt?: Date | string | null
    deletedAt?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    locationText?: string | null
    lat?: number | null
    lng?: number | null
    viewCount?: number
    saveCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileInterestCreateManyUserInput = {
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileAppInterestsCreateManyUserInput = {
    interestId: string
    createdAt?: Date | string
  }

  export type FriendRequestCreateManyRequesterInput = {
    id?: string
    addresseeId: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type FriendRequestCreateManyAddresseeInput = {
    id?: string
    requesterId: string
    status?: $Enums.FriendRequestStatus
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type FriendshipCreateManyUserAInput = {
    id?: string
    userBId: string
    createdAt?: Date | string
  }

  export type FriendshipCreateManyUserBInput = {
    id?: string
    userAId: string
    createdAt?: Date | string
  }

  export type BlockUpdateWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: ProfileUpdateOneRequiredWithoutBlocksAsBlockerNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocked?: ProfileUpdateOneRequiredWithoutBlocksAsBlockedNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type CommentReactionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileClanUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    clan?: ClanUpdateOneRequiredWithoutMembersNestedInput
  }

  export type ProfileClanUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    clanId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProfileClanUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    clanId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type KinshipUpdateWithoutProfileAInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileB?: ProfileUpdateOneRequiredWithoutKinshipsBNestedInput
  }

  export type KinshipUncheckedUpdateWithoutProfileAInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdB?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipUncheckedUpdateManyWithoutProfileAInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdB?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipUpdateWithoutProfileBInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileA?: ProfileUpdateOneRequiredWithoutKinshipsANestedInput
  }

  export type KinshipUncheckedUpdateWithoutProfileBInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdA?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipUncheckedUpdateManyWithoutProfileBInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdA?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUpdateManyWithoutLineageNestedInput
    posts?: PostUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutLineageNestedInput
    posts?: PostUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUpdateWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineage?: LineageUpdateOneRequiredWithoutMembershipsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutLineageMembershipsNestedInput
  }

  export type LineageMembershipUncheckedUpdateWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUncheckedUpdateManyWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: ProfileUpdateOneWithoutLineageMembershipsAddedNestedInput
    lineage?: LineageUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type LineageMembershipUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUpdateWithoutUserInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadsNestedInput
  }

  export type MessageReadUncheckedUpdateWithoutUserInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyWithoutUserInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUpdateWithoutMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    muter?: ProfileUpdateOneRequiredWithoutMutesAsMuterNestedInput
  }

  export type MuteUncheckedUpdateWithoutMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUncheckedUpdateManyWithoutMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUpdateWithoutMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    muted?: ProfileUpdateOneRequiredWithoutMutesAsMutedNestedInput
  }

  export type MuteUncheckedUpdateWithoutMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    mutedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUncheckedUpdateManyWithoutMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    mutedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    request?: FriendRequestUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    request?: FriendRequestUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type PostReactionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    negotiable?: BoolFieldUpdateOperationsInput | boolean
    availability?: EnumAvailableFieldUpdateOperationsInput | $Enums.Available
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    saveCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ProductMediaUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    negotiable?: BoolFieldUpdateOperationsInput | boolean
    availability?: EnumAvailableFieldUpdateOperationsInput | $Enums.Available
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    saveCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ProductMediaUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    title?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    condition?: EnumProductConditionFieldUpdateOperationsInput | $Enums.ProductCondition
    negotiable?: BoolFieldUpdateOperationsInput | boolean
    availability?: EnumAvailableFieldUpdateOperationsInput | $Enums.Available
    status?: EnumListingStatusFieldUpdateOperationsInput | $Enums.ListingStatus
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lat?: NullableFloatFieldUpdateOperationsInput | number | null
    lng?: NullableFloatFieldUpdateOperationsInput | number | null
    viewCount?: IntFieldUpdateOperationsInput | number
    saveCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interest?: InterestUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ProfileInterestUncheckedUpdateWithoutUserInput = {
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestUncheckedUpdateManyWithoutUserInput = {
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileAppInterestsUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interest?: AppInterestUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ProfileAppInterestsUncheckedUpdateWithoutUserInput = {
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileAppInterestsUncheckedUpdateManyWithoutUserInput = {
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendRequestUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    addressee?: ProfileUpdateOneRequiredWithoutReceivedFriendRequestsNestedInput
  }

  export type FriendRequestUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type FriendRequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    addresseeId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FriendRequestUpdateWithoutAddresseeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUpdateManyWithoutRequestNestedInput
    requester?: ProfileUpdateOneRequiredWithoutSentFriendRequestsNestedInput
  }

  export type FriendRequestUncheckedUpdateWithoutAddresseeInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notifications?: NotificationUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type FriendRequestUncheckedUpdateManyWithoutAddresseeInput = {
    id?: StringFieldUpdateOperationsInput | string
    requesterId?: StringFieldUpdateOperationsInput | string
    status?: EnumFriendRequestStatusFieldUpdateOperationsInput | $Enums.FriendRequestStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FriendshipUpdateWithoutUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userB?: ProfileUpdateOneRequiredWithoutFriendshipsBNestedInput
  }

  export type FriendshipUncheckedUpdateWithoutUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutUserAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userBId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUpdateWithoutUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userA?: ProfileUpdateOneRequiredWithoutFriendshipsANestedInput
  }

  export type FriendshipUncheckedUpdateWithoutUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendshipUncheckedUpdateManyWithoutUserBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userAId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyRequestInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileClanCreateManyClanInput = {
    id?: string
    profileId: string
    order: number
  }

  export type ProfileClanUpdateWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    profile?: ProfileUpdateOneRequiredWithoutClanTreeNestedInput
  }

  export type ProfileClanUncheckedUpdateWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ProfileClanUncheckedUpdateManyWithoutClanInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type LineageMembershipCreateManyLineageInput = {
    id?: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyLineageInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type PostCreateManyLineageInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LineageMembershipUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    addedBy?: ProfileUpdateOneWithoutLineageMembershipsAddedNestedInput
    profile?: ProfileUpdateOneRequiredWithoutLineageMembershipsNestedInput
  }

  export type LineageMembershipUncheckedUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUncheckedUpdateManyWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    request?: FriendRequestUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaFileCreateManyPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyPostInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type PostReactionCreateManyPostInput = {
    id?: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    request?: FriendRequestUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostReactionsNestedInput
  }

  export type PostReactionUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentCommentInput = {
    id?: string
    postId: string
    profileId: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentReactionCreateManyCommentInput = {
    id?: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type NotificationCreateManyCommentInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    requestId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutCommentReactionsNestedInput
  }

  export type CommentReactionUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    request?: FriendRequestUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyConversationInput = {
    id?: string
    profileId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type ConversationParticipantUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutConversationMembersNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: ProfileUpdateOneRequiredWithoutMessagesNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateManyMessageInput = {
    userId: string
    readAt?: Date | string
  }

  export type NotificationCreateManyMessageInput = {
    id?: string
    recipientId: string
    senderId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    requestId?: string | null
    lineageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageReadUpdateWithoutMessageInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ProfileUpdateOneRequiredWithoutMessageReadsNestedInput
  }

  export type MessageReadUncheckedUpdateWithoutMessageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyWithoutMessageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    request?: FriendRequestUpdateOneWithoutNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    requestId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestCreateManyInterestInput = {
    userId: string
    createdAt?: Date | string
  }

  export type ProfileInterestUpdateWithoutInterestInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ProfileUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type ProfileInterestUncheckedUpdateWithoutInterestInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestUncheckedUpdateManyWithoutInterestInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileAppInterestsCreateManyInterestInput = {
    userId: string
    createdAt?: Date | string
  }

  export type ProfileAppInterestsUpdateWithoutInterestInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ProfileUpdateOneRequiredWithoutAppInterestsNestedInput
  }

  export type ProfileAppInterestsUncheckedUpdateWithoutInterestInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileAppInterestsUncheckedUpdateManyWithoutInterestInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMediaCreateManyProductInput = {
    id?: string
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: number
    orderIndex?: number
    isCover?: boolean
    createdAt?: Date | string
  }

  export type ProductMediaUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    isCover?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMediaUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    isCover?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductMediaUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: IntFieldUpdateOperationsInput | number
    orderIndex?: IntFieldUpdateOperationsInput | number
    isCover?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}