
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model ProfileSettings
 * 
 */
export type ProfileSettings = $Result.DefaultSelection<Prisma.$ProfileSettingsPayload>
/**
 * Model Lineage
 * 
 */
export type Lineage = $Result.DefaultSelection<Prisma.$LineagePayload>
/**
 * Model LineageMembership
 * 
 */
export type LineageMembership = $Result.DefaultSelection<Prisma.$LineageMembershipPayload>
/**
 * Model Kinship
 * 
 */
export type Kinship = $Result.DefaultSelection<Prisma.$KinshipPayload>
/**
 * Model Follow
 * 
 */
export type Follow = $Result.DefaultSelection<Prisma.$FollowPayload>
/**
 * Model Block
 * 
 */
export type Block = $Result.DefaultSelection<Prisma.$BlockPayload>
/**
 * Model Mute
 * 
 */
export type Mute = $Result.DefaultSelection<Prisma.$MutePayload>
/**
 * Model Post
 * 
 */
export type Post = $Result.DefaultSelection<Prisma.$PostPayload>
/**
 * Model MediaFile
 * 
 */
export type MediaFile = $Result.DefaultSelection<Prisma.$MediaFilePayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model PostReaction
 * 
 */
export type PostReaction = $Result.DefaultSelection<Prisma.$PostReactionPayload>
/**
 * Model CommentReaction
 * 
 */
export type CommentReaction = $Result.DefaultSelection<Prisma.$CommentReactionPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model ConversationParticipant
 * 
 */
export type ConversationParticipant = $Result.DefaultSelection<Prisma.$ConversationParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Interest
 * 
 */
export type Interest = $Result.DefaultSelection<Prisma.$InterestPayload>
/**
 * Model ProfileInterest
 * 
 */
export type ProfileInterest = $Result.DefaultSelection<Prisma.$ProfileInterestPayload>
/**
 * Model MessageRead
 * 
 */
export type MessageRead = $Result.DefaultSelection<Prisma.$MessageReadPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MediaType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  DOCUMENT: 'DOCUMENT',
  AUDIO: 'AUDIO',
  OTHER: 'OTHER'
};

export type MediaType = (typeof MediaType)[keyof typeof MediaType]


export const LineageType: {
  FAMILY: 'FAMILY',
  CLAN: 'CLAN',
  SURNAME_LINE: 'SURNAME_LINE',
  TRIBE: 'TRIBE'
};

export type LineageType = (typeof LineageType)[keyof typeof LineageType]


export const LineageRole: {
  ANCESTOR: 'ANCESTOR',
  DESCENDANT: 'DESCENDANT',
  SPOUSE: 'SPOUSE',
  EXTENDED: 'EXTENDED'
};

export type LineageRole = (typeof LineageRole)[keyof typeof LineageRole]


export const KinshipType: {
  PARENT: 'PARENT',
  CHILD: 'CHILD',
  SIBLING: 'SIBLING',
  SPOUSE: 'SPOUSE',
  GRANDPARENT: 'GRANDPARENT',
  GRANDCHILD: 'GRANDCHILD',
  COUSIN: 'COUSIN',
  UNCLE_AUNT: 'UNCLE_AUNT',
  NEPHEW_NIECE: 'NEPHEW_NIECE',
  OTHER: 'OTHER'
};

export type KinshipType = (typeof KinshipType)[keyof typeof KinshipType]


export const PostVisibility: {
  PUBLIC: 'PUBLIC',
  FOLLOWERS: 'FOLLOWERS',
  LINEAGE_ONLY: 'LINEAGE_ONLY',
  PRIVATE: 'PRIVATE'
};

export type PostVisibility = (typeof PostVisibility)[keyof typeof PostVisibility]


export const ReactionType: {
  LIKE: 'LIKE',
  LOVE: 'LOVE',
  LAUGH: 'LAUGH',
  ANGRY: 'ANGRY',
  SAD: 'SAD'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const NotificationType: {
  FOLLOW: 'FOLLOW',
  LIKE: 'LIKE',
  COMMENT: 'COMMENT',
  MENTION: 'MENTION',
  MESSAGE: 'MESSAGE',
  LINEAGE_INVITE: 'LINEAGE_INVITE',
  LINEAGE_ACCEPT: 'LINEAGE_ACCEPT'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type MediaType = $Enums.MediaType

export const MediaType: typeof $Enums.MediaType

export type LineageType = $Enums.LineageType

export const LineageType: typeof $Enums.LineageType

export type LineageRole = $Enums.LineageRole

export const LineageRole: typeof $Enums.LineageRole

export type KinshipType = $Enums.KinshipType

export const KinshipType: typeof $Enums.KinshipType

export type PostVisibility = $Enums.PostVisibility

export const PostVisibility: typeof $Enums.PostVisibility

export type ReactionType = $Enums.ReactionType

export const ReactionType: typeof $Enums.ReactionType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Profiles
 * const profiles = await prisma.profile.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Profiles
   * const profiles = await prisma.profile.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profileSettings`: Exposes CRUD operations for the **ProfileSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileSettings
    * const profileSettings = await prisma.profileSettings.findMany()
    * ```
    */
  get profileSettings(): Prisma.ProfileSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lineage`: Exposes CRUD operations for the **Lineage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lineages
    * const lineages = await prisma.lineage.findMany()
    * ```
    */
  get lineage(): Prisma.LineageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lineageMembership`: Exposes CRUD operations for the **LineageMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LineageMemberships
    * const lineageMemberships = await prisma.lineageMembership.findMany()
    * ```
    */
  get lineageMembership(): Prisma.LineageMembershipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kinship`: Exposes CRUD operations for the **Kinship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kinships
    * const kinships = await prisma.kinship.findMany()
    * ```
    */
  get kinship(): Prisma.KinshipDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.follow`: Exposes CRUD operations for the **Follow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Follows
    * const follows = await prisma.follow.findMany()
    * ```
    */
  get follow(): Prisma.FollowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.block`: Exposes CRUD operations for the **Block** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blocks
    * const blocks = await prisma.block.findMany()
    * ```
    */
  get block(): Prisma.BlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mute`: Exposes CRUD operations for the **Mute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mutes
    * const mutes = await prisma.mute.findMany()
    * ```
    */
  get mute(): Prisma.MuteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.post`: Exposes CRUD operations for the **Post** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Posts
    * const posts = await prisma.post.findMany()
    * ```
    */
  get post(): Prisma.PostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaFile`: Exposes CRUD operations for the **MediaFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaFiles
    * const mediaFiles = await prisma.mediaFile.findMany()
    * ```
    */
  get mediaFile(): Prisma.MediaFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.postReaction`: Exposes CRUD operations for the **PostReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostReactions
    * const postReactions = await prisma.postReaction.findMany()
    * ```
    */
  get postReaction(): Prisma.PostReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.commentReaction`: Exposes CRUD operations for the **CommentReaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentReactions
    * const commentReactions = await prisma.commentReaction.findMany()
    * ```
    */
  get commentReaction(): Prisma.CommentReactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversationParticipant`: Exposes CRUD operations for the **ConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConversationParticipants
    * const conversationParticipants = await prisma.conversationParticipant.findMany()
    * ```
    */
  get conversationParticipant(): Prisma.ConversationParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interest`: Exposes CRUD operations for the **Interest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interests
    * const interests = await prisma.interest.findMany()
    * ```
    */
  get interest(): Prisma.InterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profileInterest`: Exposes CRUD operations for the **ProfileInterest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProfileInterests
    * const profileInterests = await prisma.profileInterest.findMany()
    * ```
    */
  get profileInterest(): Prisma.ProfileInterestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageRead`: Exposes CRUD operations for the **MessageRead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageReads
    * const messageReads = await prisma.messageRead.findMany()
    * ```
    */
  get messageRead(): Prisma.MessageReadDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.0.0
   * Query Engine version: 0c19ccc313cf9911a90d99d2ac2eb0280c76c513
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Profile: 'Profile',
    ProfileSettings: 'ProfileSettings',
    Lineage: 'Lineage',
    LineageMembership: 'LineageMembership',
    Kinship: 'Kinship',
    Follow: 'Follow',
    Block: 'Block',
    Mute: 'Mute',
    Post: 'Post',
    MediaFile: 'MediaFile',
    Comment: 'Comment',
    PostReaction: 'PostReaction',
    CommentReaction: 'CommentReaction',
    Conversation: 'Conversation',
    ConversationParticipant: 'ConversationParticipant',
    Message: 'Message',
    Notification: 'Notification',
    Interest: 'Interest',
    ProfileInterest: 'ProfileInterest',
    MessageRead: 'MessageRead'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "profile" | "profileSettings" | "lineage" | "lineageMembership" | "kinship" | "follow" | "block" | "mute" | "post" | "mediaFile" | "comment" | "postReaction" | "commentReaction" | "conversation" | "conversationParticipant" | "message" | "notification" | "interest" | "profileInterest" | "messageRead"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      ProfileSettings: {
        payload: Prisma.$ProfileSettingsPayload<ExtArgs>
        fields: Prisma.ProfileSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          findFirst: {
            args: Prisma.ProfileSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          findMany: {
            args: Prisma.ProfileSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>[]
          }
          create: {
            args: Prisma.ProfileSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          createMany: {
            args: Prisma.ProfileSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>[]
          }
          delete: {
            args: Prisma.ProfileSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          update: {
            args: Prisma.ProfileSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          deleteMany: {
            args: Prisma.ProfileSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>[]
          }
          upsert: {
            args: Prisma.ProfileSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileSettingsPayload>
          }
          aggregate: {
            args: Prisma.ProfileSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileSettings>
          }
          groupBy: {
            args: Prisma.ProfileSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileSettingsCountAggregateOutputType> | number
          }
        }
      }
      Lineage: {
        payload: Prisma.$LineagePayload<ExtArgs>
        fields: Prisma.LineageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LineageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LineageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          findFirst: {
            args: Prisma.LineageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LineageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          findMany: {
            args: Prisma.LineageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>[]
          }
          create: {
            args: Prisma.LineageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          createMany: {
            args: Prisma.LineageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LineageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>[]
          }
          delete: {
            args: Prisma.LineageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          update: {
            args: Prisma.LineageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          deleteMany: {
            args: Prisma.LineageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LineageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LineageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>[]
          }
          upsert: {
            args: Prisma.LineageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineagePayload>
          }
          aggregate: {
            args: Prisma.LineageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLineage>
          }
          groupBy: {
            args: Prisma.LineageGroupByArgs<ExtArgs>
            result: $Utils.Optional<LineageGroupByOutputType>[]
          }
          count: {
            args: Prisma.LineageCountArgs<ExtArgs>
            result: $Utils.Optional<LineageCountAggregateOutputType> | number
          }
        }
      }
      LineageMembership: {
        payload: Prisma.$LineageMembershipPayload<ExtArgs>
        fields: Prisma.LineageMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LineageMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LineageMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          findFirst: {
            args: Prisma.LineageMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LineageMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          findMany: {
            args: Prisma.LineageMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>[]
          }
          create: {
            args: Prisma.LineageMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          createMany: {
            args: Prisma.LineageMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LineageMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>[]
          }
          delete: {
            args: Prisma.LineageMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          update: {
            args: Prisma.LineageMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          deleteMany: {
            args: Prisma.LineageMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LineageMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LineageMembershipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>[]
          }
          upsert: {
            args: Prisma.LineageMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LineageMembershipPayload>
          }
          aggregate: {
            args: Prisma.LineageMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLineageMembership>
          }
          groupBy: {
            args: Prisma.LineageMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<LineageMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.LineageMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<LineageMembershipCountAggregateOutputType> | number
          }
        }
      }
      Kinship: {
        payload: Prisma.$KinshipPayload<ExtArgs>
        fields: Prisma.KinshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KinshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KinshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          findFirst: {
            args: Prisma.KinshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KinshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          findMany: {
            args: Prisma.KinshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>[]
          }
          create: {
            args: Prisma.KinshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          createMany: {
            args: Prisma.KinshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KinshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>[]
          }
          delete: {
            args: Prisma.KinshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          update: {
            args: Prisma.KinshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          deleteMany: {
            args: Prisma.KinshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KinshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KinshipUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>[]
          }
          upsert: {
            args: Prisma.KinshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KinshipPayload>
          }
          aggregate: {
            args: Prisma.KinshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKinship>
          }
          groupBy: {
            args: Prisma.KinshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<KinshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.KinshipCountArgs<ExtArgs>
            result: $Utils.Optional<KinshipCountAggregateOutputType> | number
          }
        }
      }
      Follow: {
        payload: Prisma.$FollowPayload<ExtArgs>
        fields: Prisma.FollowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FollowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FollowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findFirst: {
            args: Prisma.FollowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FollowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          findMany: {
            args: Prisma.FollowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          create: {
            args: Prisma.FollowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          createMany: {
            args: Prisma.FollowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FollowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          delete: {
            args: Prisma.FollowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          update: {
            args: Prisma.FollowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          deleteMany: {
            args: Prisma.FollowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FollowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FollowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>[]
          }
          upsert: {
            args: Prisma.FollowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FollowPayload>
          }
          aggregate: {
            args: Prisma.FollowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollow>
          }
          groupBy: {
            args: Prisma.FollowGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowGroupByOutputType>[]
          }
          count: {
            args: Prisma.FollowCountArgs<ExtArgs>
            result: $Utils.Optional<FollowCountAggregateOutputType> | number
          }
        }
      }
      Block: {
        payload: Prisma.$BlockPayload<ExtArgs>
        fields: Prisma.BlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findFirst: {
            args: Prisma.BlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          findMany: {
            args: Prisma.BlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          create: {
            args: Prisma.BlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          createMany: {
            args: Prisma.BlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          delete: {
            args: Prisma.BlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          update: {
            args: Prisma.BlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          deleteMany: {
            args: Prisma.BlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>[]
          }
          upsert: {
            args: Prisma.BlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockPayload>
          }
          aggregate: {
            args: Prisma.BlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlock>
          }
          groupBy: {
            args: Prisma.BlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockCountArgs<ExtArgs>
            result: $Utils.Optional<BlockCountAggregateOutputType> | number
          }
        }
      }
      Mute: {
        payload: Prisma.$MutePayload<ExtArgs>
        fields: Prisma.MuteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MuteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MuteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          findFirst: {
            args: Prisma.MuteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MuteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          findMany: {
            args: Prisma.MuteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>[]
          }
          create: {
            args: Prisma.MuteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          createMany: {
            args: Prisma.MuteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MuteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>[]
          }
          delete: {
            args: Prisma.MuteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          update: {
            args: Prisma.MuteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          deleteMany: {
            args: Prisma.MuteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MuteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MuteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>[]
          }
          upsert: {
            args: Prisma.MuteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutePayload>
          }
          aggregate: {
            args: Prisma.MuteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMute>
          }
          groupBy: {
            args: Prisma.MuteGroupByArgs<ExtArgs>
            result: $Utils.Optional<MuteGroupByOutputType>[]
          }
          count: {
            args: Prisma.MuteCountArgs<ExtArgs>
            result: $Utils.Optional<MuteCountAggregateOutputType> | number
          }
        }
      }
      Post: {
        payload: Prisma.$PostPayload<ExtArgs>
        fields: Prisma.PostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findFirst: {
            args: Prisma.PostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          findMany: {
            args: Prisma.PostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          create: {
            args: Prisma.PostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          createMany: {
            args: Prisma.PostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          delete: {
            args: Prisma.PostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          update: {
            args: Prisma.PostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          deleteMany: {
            args: Prisma.PostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>[]
          }
          upsert: {
            args: Prisma.PostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostPayload>
          }
          aggregate: {
            args: Prisma.PostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePost>
          }
          groupBy: {
            args: Prisma.PostGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostCountArgs<ExtArgs>
            result: $Utils.Optional<PostCountAggregateOutputType> | number
          }
        }
      }
      MediaFile: {
        payload: Prisma.$MediaFilePayload<ExtArgs>
        fields: Prisma.MediaFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          findFirst: {
            args: Prisma.MediaFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          findMany: {
            args: Prisma.MediaFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          create: {
            args: Prisma.MediaFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          createMany: {
            args: Prisma.MediaFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          delete: {
            args: Prisma.MediaFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          update: {
            args: Prisma.MediaFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          deleteMany: {
            args: Prisma.MediaFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          upsert: {
            args: Prisma.MediaFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          aggregate: {
            args: Prisma.MediaFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaFile>
          }
          groupBy: {
            args: Prisma.MediaFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaFileCountArgs<ExtArgs>
            result: $Utils.Optional<MediaFileCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      PostReaction: {
        payload: Prisma.$PostReactionPayload<ExtArgs>
        fields: Prisma.PostReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          findFirst: {
            args: Prisma.PostReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          findMany: {
            args: Prisma.PostReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>[]
          }
          create: {
            args: Prisma.PostReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          createMany: {
            args: Prisma.PostReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>[]
          }
          delete: {
            args: Prisma.PostReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          update: {
            args: Prisma.PostReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          deleteMany: {
            args: Prisma.PostReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PostReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>[]
          }
          upsert: {
            args: Prisma.PostReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostReactionPayload>
          }
          aggregate: {
            args: Prisma.PostReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostReaction>
          }
          groupBy: {
            args: Prisma.PostReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostReactionCountArgs<ExtArgs>
            result: $Utils.Optional<PostReactionCountAggregateOutputType> | number
          }
        }
      }
      CommentReaction: {
        payload: Prisma.$CommentReactionPayload<ExtArgs>
        fields: Prisma.CommentReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          findFirst: {
            args: Prisma.CommentReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          findMany: {
            args: Prisma.CommentReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>[]
          }
          create: {
            args: Prisma.CommentReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          createMany: {
            args: Prisma.CommentReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>[]
          }
          delete: {
            args: Prisma.CommentReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          update: {
            args: Prisma.CommentReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          deleteMany: {
            args: Prisma.CommentReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CommentReactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>[]
          }
          upsert: {
            args: Prisma.CommentReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentReactionPayload>
          }
          aggregate: {
            args: Prisma.CommentReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentReaction>
          }
          groupBy: {
            args: Prisma.CommentReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentReactionCountArgs<ExtArgs>
            result: $Utils.Optional<CommentReactionCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      ConversationParticipant: {
        payload: Prisma.$ConversationParticipantPayload<ExtArgs>
        fields: Prisma.ConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.ConversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.ConversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.ConversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.ConversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.ConversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          update: {
            args: Prisma.ConversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ConversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ConversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.ConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversationParticipant>
          }
          groupBy: {
            args: Prisma.ConversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Interest: {
        payload: Prisma.$InterestPayload<ExtArgs>
        fields: Prisma.InterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findFirst: {
            args: Prisma.InterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          findMany: {
            args: Prisma.InterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          create: {
            args: Prisma.InterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          createMany: {
            args: Prisma.InterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          delete: {
            args: Prisma.InterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          update: {
            args: Prisma.InterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          deleteMany: {
            args: Prisma.InterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>[]
          }
          upsert: {
            args: Prisma.InterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InterestPayload>
          }
          aggregate: {
            args: Prisma.InterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInterest>
          }
          groupBy: {
            args: Prisma.InterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<InterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.InterestCountArgs<ExtArgs>
            result: $Utils.Optional<InterestCountAggregateOutputType> | number
          }
        }
      }
      ProfileInterest: {
        payload: Prisma.$ProfileInterestPayload<ExtArgs>
        fields: Prisma.ProfileInterestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileInterestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileInterestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          findFirst: {
            args: Prisma.ProfileInterestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileInterestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          findMany: {
            args: Prisma.ProfileInterestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>[]
          }
          create: {
            args: Prisma.ProfileInterestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          createMany: {
            args: Prisma.ProfileInterestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileInterestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>[]
          }
          delete: {
            args: Prisma.ProfileInterestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          update: {
            args: Prisma.ProfileInterestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          deleteMany: {
            args: Prisma.ProfileInterestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileInterestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileInterestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>[]
          }
          upsert: {
            args: Prisma.ProfileInterestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfileInterestPayload>
          }
          aggregate: {
            args: Prisma.ProfileInterestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfileInterest>
          }
          groupBy: {
            args: Prisma.ProfileInterestGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileInterestGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileInterestCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileInterestCountAggregateOutputType> | number
          }
        }
      }
      MessageRead: {
        payload: Prisma.$MessageReadPayload<ExtArgs>
        fields: Prisma.MessageReadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageReadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageReadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          findFirst: {
            args: Prisma.MessageReadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageReadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          findMany: {
            args: Prisma.MessageReadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          create: {
            args: Prisma.MessageReadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          createMany: {
            args: Prisma.MessageReadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageReadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          delete: {
            args: Prisma.MessageReadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          update: {
            args: Prisma.MessageReadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          deleteMany: {
            args: Prisma.MessageReadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageReadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageReadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>[]
          }
          upsert: {
            args: Prisma.MessageReadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageReadPayload>
          }
          aggregate: {
            args: Prisma.MessageReadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageRead>
          }
          groupBy: {
            args: Prisma.MessageReadGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageReadGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageReadCountArgs<ExtArgs>
            result: $Utils.Optional<MessageReadCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    profile?: ProfileOmit
    profileSettings?: ProfileSettingsOmit
    lineage?: LineageOmit
    lineageMembership?: LineageMembershipOmit
    kinship?: KinshipOmit
    follow?: FollowOmit
    block?: BlockOmit
    mute?: MuteOmit
    post?: PostOmit
    mediaFile?: MediaFileOmit
    comment?: CommentOmit
    postReaction?: PostReactionOmit
    commentReaction?: CommentReactionOmit
    conversation?: ConversationOmit
    conversationParticipant?: ConversationParticipantOmit
    message?: MessageOmit
    notification?: NotificationOmit
    interest?: InterestOmit
    profileInterest?: ProfileInterestOmit
    messageRead?: MessageReadOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    interests: number
    posts: number
    comments: number
    messages: number
    messageReads: number
    postReactions: number
    lineageMemberships: number
    kinshipsA: number
    kinshipsB: number
    commentReactions: number
    followsAsFollower: number
    followsAsFollowee: number
    blocksAsBlocker: number
    blocksAsBlocked: number
    mutesAsMuter: number
    mutesAsMuted: number
    conversationsOwned: number
    conversationMembers: number
    notifications: number
    notificationsAsActor: number
    lineagesCreated: number
    lineageMembershipsAdded: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | ProfileCountOutputTypeCountInterestsArgs
    posts?: boolean | ProfileCountOutputTypeCountPostsArgs
    comments?: boolean | ProfileCountOutputTypeCountCommentsArgs
    messages?: boolean | ProfileCountOutputTypeCountMessagesArgs
    messageReads?: boolean | ProfileCountOutputTypeCountMessageReadsArgs
    postReactions?: boolean | ProfileCountOutputTypeCountPostReactionsArgs
    lineageMemberships?: boolean | ProfileCountOutputTypeCountLineageMembershipsArgs
    kinshipsA?: boolean | ProfileCountOutputTypeCountKinshipsAArgs
    kinshipsB?: boolean | ProfileCountOutputTypeCountKinshipsBArgs
    commentReactions?: boolean | ProfileCountOutputTypeCountCommentReactionsArgs
    followsAsFollower?: boolean | ProfileCountOutputTypeCountFollowsAsFollowerArgs
    followsAsFollowee?: boolean | ProfileCountOutputTypeCountFollowsAsFolloweeArgs
    blocksAsBlocker?: boolean | ProfileCountOutputTypeCountBlocksAsBlockerArgs
    blocksAsBlocked?: boolean | ProfileCountOutputTypeCountBlocksAsBlockedArgs
    mutesAsMuter?: boolean | ProfileCountOutputTypeCountMutesAsMuterArgs
    mutesAsMuted?: boolean | ProfileCountOutputTypeCountMutesAsMutedArgs
    conversationsOwned?: boolean | ProfileCountOutputTypeCountConversationsOwnedArgs
    conversationMembers?: boolean | ProfileCountOutputTypeCountConversationMembersArgs
    notifications?: boolean | ProfileCountOutputTypeCountNotificationsArgs
    notificationsAsActor?: boolean | ProfileCountOutputTypeCountNotificationsAsActorArgs
    lineagesCreated?: boolean | ProfileCountOutputTypeCountLineagesCreatedArgs
    lineageMembershipsAdded?: boolean | ProfileCountOutputTypeCountLineageMembershipsAddedArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountInterestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileInterestWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMessageReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountPostReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostReactionWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLineageMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageMembershipWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountKinshipsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KinshipWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountKinshipsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KinshipWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountCommentReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReactionWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountFollowsAsFollowerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountFollowsAsFolloweeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountBlocksAsBlockerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountBlocksAsBlockedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMutesAsMuterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuteWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountMutesAsMutedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuteWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountConversationsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountConversationMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountNotificationsAsActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLineagesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountLineageMembershipsAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageMembershipWhereInput
  }


  /**
   * Count Type LineageCountOutputType
   */

  export type LineageCountOutputType = {
    memberships: number
    posts: number
    notifications: number
  }

  export type LineageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | LineageCountOutputTypeCountMembershipsArgs
    posts?: boolean | LineageCountOutputTypeCountPostsArgs
    notifications?: boolean | LineageCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * LineageCountOutputType without action
   */
  export type LineageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageCountOutputType
     */
    select?: LineageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LineageCountOutputType without action
   */
  export type LineageCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageMembershipWhereInput
  }

  /**
   * LineageCountOutputType without action
   */
  export type LineageCountOutputTypeCountPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
  }

  /**
   * LineageCountOutputType without action
   */
  export type LineageCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PostCountOutputType
   */

  export type PostCountOutputType = {
    comments: number
    reactions: number
    mediaFiles: number
    notifications: number
  }

  export type PostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | PostCountOutputTypeCountCommentsArgs
    reactions?: boolean | PostCountOutputTypeCountReactionsArgs
    mediaFiles?: boolean | PostCountOutputTypeCountMediaFilesArgs
    notifications?: boolean | PostCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostCountOutputType
     */
    select?: PostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostReactionWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountMediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFileWhereInput
  }

  /**
   * PostCountOutputType without action
   */
  export type PostCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    replies: number
    reactions: number
    notifications: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | CommentCountOutputTypeCountRepliesArgs
    reactions?: boolean | CommentCountOutputTypeCountReactionsArgs
    notifications?: boolean | CommentCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReactionWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    participants: number
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | ConversationCountOutputTypeCountParticipantsArgs
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    reads: number
    notifications: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reads?: boolean | MessageCountOutputTypeCountReadsArgs
    notifications?: boolean | MessageCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type InterestCountOutputType
   */

  export type InterestCountOutputType = {
    users: number
  }

  export type InterestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | InterestCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * InterestCountOutputType without action
   */
  export type InterestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InterestCountOutputType
     */
    select?: InterestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InterestCountOutputType without action
   */
  export type InterestCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileInterestWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    gender: string | null
    dateOfBirth: Date | null
    country: string | null
    city: string | null
    district: string | null
    location: string | null
    bio: string | null
    countryCode: string | null
    avatarUrl: string | null
    coverUrl: string | null
    lineageMainSurname: string | null
    lineageRootVillage: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    gender: string | null
    dateOfBirth: Date | null
    country: string | null
    city: string | null
    district: string | null
    location: string | null
    bio: string | null
    countryCode: string | null
    avatarUrl: string | null
    coverUrl: string | null
    lineageMainSurname: string | null
    lineageRootVillage: string | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    firstName: number
    lastName: number
    username: number
    gender: number
    dateOfBirth: number
    country: number
    city: number
    district: number
    location: number
    bio: number
    countryCode: number
    avatarUrl: number
    coverUrl: number
    lineageMainSurname: number
    lineageRootVillage: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    username?: true
    gender?: true
    dateOfBirth?: true
    country?: true
    city?: true
    district?: true
    location?: true
    bio?: true
    countryCode?: true
    avatarUrl?: true
    coverUrl?: true
    lineageMainSurname?: true
    lineageRootVillage?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    username?: true
    gender?: true
    dateOfBirth?: true
    country?: true
    city?: true
    district?: true
    location?: true
    bio?: true
    countryCode?: true
    avatarUrl?: true
    coverUrl?: true
    lineageMainSurname?: true
    lineageRootVillage?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    firstName?: true
    lastName?: true
    username?: true
    gender?: true
    dateOfBirth?: true
    country?: true
    city?: true
    district?: true
    location?: true
    bio?: true
    countryCode?: true
    avatarUrl?: true
    coverUrl?: true
    lineageMainSurname?: true
    lineageRootVillage?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    firstName: string
    lastName: string
    username: string
    gender: string | null
    dateOfBirth: Date | null
    country: string | null
    city: string | null
    district: string | null
    location: string
    bio: string
    countryCode: string | null
    avatarUrl: string | null
    coverUrl: string | null
    lineageMainSurname: string | null
    lineageRootVillage: string | null
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    location?: boolean
    bio?: boolean
    countryCode?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    lineageMainSurname?: boolean
    lineageRootVillage?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    interests?: boolean | Profile$interestsArgs<ExtArgs>
    posts?: boolean | Profile$postsArgs<ExtArgs>
    comments?: boolean | Profile$commentsArgs<ExtArgs>
    messages?: boolean | Profile$messagesArgs<ExtArgs>
    messageReads?: boolean | Profile$messageReadsArgs<ExtArgs>
    postReactions?: boolean | Profile$postReactionsArgs<ExtArgs>
    settings?: boolean | Profile$settingsArgs<ExtArgs>
    lineageMemberships?: boolean | Profile$lineageMembershipsArgs<ExtArgs>
    kinshipsA?: boolean | Profile$kinshipsAArgs<ExtArgs>
    kinshipsB?: boolean | Profile$kinshipsBArgs<ExtArgs>
    commentReactions?: boolean | Profile$commentReactionsArgs<ExtArgs>
    followsAsFollower?: boolean | Profile$followsAsFollowerArgs<ExtArgs>
    followsAsFollowee?: boolean | Profile$followsAsFolloweeArgs<ExtArgs>
    blocksAsBlocker?: boolean | Profile$blocksAsBlockerArgs<ExtArgs>
    blocksAsBlocked?: boolean | Profile$blocksAsBlockedArgs<ExtArgs>
    mutesAsMuter?: boolean | Profile$mutesAsMuterArgs<ExtArgs>
    mutesAsMuted?: boolean | Profile$mutesAsMutedArgs<ExtArgs>
    conversationsOwned?: boolean | Profile$conversationsOwnedArgs<ExtArgs>
    conversationMembers?: boolean | Profile$conversationMembersArgs<ExtArgs>
    notifications?: boolean | Profile$notificationsArgs<ExtArgs>
    notificationsAsActor?: boolean | Profile$notificationsAsActorArgs<ExtArgs>
    lineagesCreated?: boolean | Profile$lineagesCreatedArgs<ExtArgs>
    lineageMembershipsAdded?: boolean | Profile$lineageMembershipsAddedArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    location?: boolean
    bio?: boolean
    countryCode?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    lineageMainSurname?: boolean
    lineageRootVillage?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    location?: boolean
    bio?: boolean
    countryCode?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    lineageMainSurname?: boolean
    lineageRootVillage?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    gender?: boolean
    dateOfBirth?: boolean
    country?: boolean
    city?: boolean
    district?: boolean
    location?: boolean
    bio?: boolean
    countryCode?: boolean
    avatarUrl?: boolean
    coverUrl?: boolean
    lineageMainSurname?: boolean
    lineageRootVillage?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "firstName" | "lastName" | "username" | "gender" | "dateOfBirth" | "country" | "city" | "district" | "location" | "bio" | "countryCode" | "avatarUrl" | "coverUrl" | "lineageMainSurname" | "lineageRootVillage" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interests?: boolean | Profile$interestsArgs<ExtArgs>
    posts?: boolean | Profile$postsArgs<ExtArgs>
    comments?: boolean | Profile$commentsArgs<ExtArgs>
    messages?: boolean | Profile$messagesArgs<ExtArgs>
    messageReads?: boolean | Profile$messageReadsArgs<ExtArgs>
    postReactions?: boolean | Profile$postReactionsArgs<ExtArgs>
    settings?: boolean | Profile$settingsArgs<ExtArgs>
    lineageMemberships?: boolean | Profile$lineageMembershipsArgs<ExtArgs>
    kinshipsA?: boolean | Profile$kinshipsAArgs<ExtArgs>
    kinshipsB?: boolean | Profile$kinshipsBArgs<ExtArgs>
    commentReactions?: boolean | Profile$commentReactionsArgs<ExtArgs>
    followsAsFollower?: boolean | Profile$followsAsFollowerArgs<ExtArgs>
    followsAsFollowee?: boolean | Profile$followsAsFolloweeArgs<ExtArgs>
    blocksAsBlocker?: boolean | Profile$blocksAsBlockerArgs<ExtArgs>
    blocksAsBlocked?: boolean | Profile$blocksAsBlockedArgs<ExtArgs>
    mutesAsMuter?: boolean | Profile$mutesAsMuterArgs<ExtArgs>
    mutesAsMuted?: boolean | Profile$mutesAsMutedArgs<ExtArgs>
    conversationsOwned?: boolean | Profile$conversationsOwnedArgs<ExtArgs>
    conversationMembers?: boolean | Profile$conversationMembersArgs<ExtArgs>
    notifications?: boolean | Profile$notificationsArgs<ExtArgs>
    notificationsAsActor?: boolean | Profile$notificationsAsActorArgs<ExtArgs>
    lineagesCreated?: boolean | Profile$lineagesCreatedArgs<ExtArgs>
    lineageMembershipsAdded?: boolean | Profile$lineageMembershipsAddedArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      interests: Prisma.$ProfileInterestPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      messageReads: Prisma.$MessageReadPayload<ExtArgs>[]
      postReactions: Prisma.$PostReactionPayload<ExtArgs>[]
      settings: Prisma.$ProfileSettingsPayload<ExtArgs> | null
      lineageMemberships: Prisma.$LineageMembershipPayload<ExtArgs>[]
      kinshipsA: Prisma.$KinshipPayload<ExtArgs>[]
      kinshipsB: Prisma.$KinshipPayload<ExtArgs>[]
      commentReactions: Prisma.$CommentReactionPayload<ExtArgs>[]
      followsAsFollower: Prisma.$FollowPayload<ExtArgs>[]
      followsAsFollowee: Prisma.$FollowPayload<ExtArgs>[]
      blocksAsBlocker: Prisma.$BlockPayload<ExtArgs>[]
      blocksAsBlocked: Prisma.$BlockPayload<ExtArgs>[]
      mutesAsMuter: Prisma.$MutePayload<ExtArgs>[]
      mutesAsMuted: Prisma.$MutePayload<ExtArgs>[]
      conversationsOwned: Prisma.$ConversationPayload<ExtArgs>[]
      conversationMembers: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      notificationsAsActor: Prisma.$NotificationPayload<ExtArgs>[]
      lineagesCreated: Prisma.$LineagePayload<ExtArgs>[]
      lineageMembershipsAdded: Prisma.$LineageMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      firstName: string
      lastName: string
      username: string
      gender: string | null
      dateOfBirth: Date | null
      country: string | null
      city: string | null
      district: string | null
      location: string
      bio: string
      countryCode: string | null
      avatarUrl: string | null
      coverUrl: string | null
      lineageMainSurname: string | null
      lineageRootVillage: string | null
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    interests<T extends Profile$interestsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$interestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Profile$postsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    comments<T extends Profile$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Profile$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messageReads<T extends Profile$messageReadsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$messageReadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    postReactions<T extends Profile$postReactionsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$postReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    settings<T extends Profile$settingsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$settingsArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lineageMemberships<T extends Profile$lineageMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$lineageMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kinshipsA<T extends Profile$kinshipsAArgs<ExtArgs> = {}>(args?: Subset<T, Profile$kinshipsAArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kinshipsB<T extends Profile$kinshipsBArgs<ExtArgs> = {}>(args?: Subset<T, Profile$kinshipsBArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    commentReactions<T extends Profile$commentReactionsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$commentReactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followsAsFollower<T extends Profile$followsAsFollowerArgs<ExtArgs> = {}>(args?: Subset<T, Profile$followsAsFollowerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followsAsFollowee<T extends Profile$followsAsFolloweeArgs<ExtArgs> = {}>(args?: Subset<T, Profile$followsAsFolloweeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocksAsBlocker<T extends Profile$blocksAsBlockerArgs<ExtArgs> = {}>(args?: Subset<T, Profile$blocksAsBlockerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blocksAsBlocked<T extends Profile$blocksAsBlockedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$blocksAsBlockedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mutesAsMuter<T extends Profile$mutesAsMuterArgs<ExtArgs> = {}>(args?: Subset<T, Profile$mutesAsMuterArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mutesAsMuted<T extends Profile$mutesAsMutedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$mutesAsMutedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationsOwned<T extends Profile$conversationsOwnedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$conversationsOwnedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationMembers<T extends Profile$conversationMembersArgs<ExtArgs> = {}>(args?: Subset<T, Profile$conversationMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Profile$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationsAsActor<T extends Profile$notificationsAsActorArgs<ExtArgs> = {}>(args?: Subset<T, Profile$notificationsAsActorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lineagesCreated<T extends Profile$lineagesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$lineagesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lineageMembershipsAdded<T extends Profile$lineageMembershipsAddedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$lineageMembershipsAddedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly firstName: FieldRef<"Profile", 'String'>
    readonly lastName: FieldRef<"Profile", 'String'>
    readonly username: FieldRef<"Profile", 'String'>
    readonly gender: FieldRef<"Profile", 'String'>
    readonly dateOfBirth: FieldRef<"Profile", 'DateTime'>
    readonly country: FieldRef<"Profile", 'String'>
    readonly city: FieldRef<"Profile", 'String'>
    readonly district: FieldRef<"Profile", 'String'>
    readonly location: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly countryCode: FieldRef<"Profile", 'String'>
    readonly avatarUrl: FieldRef<"Profile", 'String'>
    readonly coverUrl: FieldRef<"Profile", 'String'>
    readonly lineageMainSurname: FieldRef<"Profile", 'String'>
    readonly lineageRootVillage: FieldRef<"Profile", 'String'>
    readonly isVerified: FieldRef<"Profile", 'Boolean'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.interests
   */
  export type Profile$interestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    where?: ProfileInterestWhereInput
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    cursor?: ProfileInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * Profile.posts
   */
  export type Profile$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Profile.comments
   */
  export type Profile$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Profile.messages
   */
  export type Profile$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Profile.messageReads
   */
  export type Profile$messageReadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    cursor?: MessageReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * Profile.postReactions
   */
  export type Profile$postReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    where?: PostReactionWhereInput
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    cursor?: PostReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * Profile.settings
   */
  export type Profile$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    where?: ProfileSettingsWhereInput
  }

  /**
   * Profile.lineageMemberships
   */
  export type Profile$lineageMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    where?: LineageMembershipWhereInput
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    cursor?: LineageMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * Profile.kinshipsA
   */
  export type Profile$kinshipsAArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    where?: KinshipWhereInput
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    cursor?: KinshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Profile.kinshipsB
   */
  export type Profile$kinshipsBArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    where?: KinshipWhereInput
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    cursor?: KinshipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Profile.commentReactions
   */
  export type Profile$commentReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    where?: CommentReactionWhereInput
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    cursor?: CommentReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * Profile.followsAsFollower
   */
  export type Profile$followsAsFollowerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Profile.followsAsFollowee
   */
  export type Profile$followsAsFolloweeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    cursor?: FollowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Profile.blocksAsBlocker
   */
  export type Profile$blocksAsBlockerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Profile.blocksAsBlocked
   */
  export type Profile$blocksAsBlockedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    cursor?: BlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Profile.mutesAsMuter
   */
  export type Profile$mutesAsMuterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    where?: MuteWhereInput
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    cursor?: MuteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Profile.mutesAsMuted
   */
  export type Profile$mutesAsMutedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    where?: MuteWhereInput
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    cursor?: MuteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Profile.conversationsOwned
   */
  export type Profile$conversationsOwnedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Profile.conversationMembers
   */
  export type Profile$conversationMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Profile.notifications
   */
  export type Profile$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Profile.notificationsAsActor
   */
  export type Profile$notificationsAsActorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Profile.lineagesCreated
   */
  export type Profile$lineagesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    where?: LineageWhereInput
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    cursor?: LineageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineageScalarFieldEnum | LineageScalarFieldEnum[]
  }

  /**
   * Profile.lineageMembershipsAdded
   */
  export type Profile$lineageMembershipsAddedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    where?: LineageMembershipWhereInput
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    cursor?: LineageMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model ProfileSettings
   */

  export type AggregateProfileSettings = {
    _count: ProfileSettingsCountAggregateOutputType | null
    _min: ProfileSettingsMinAggregateOutputType | null
    _max: ProfileSettingsMaxAggregateOutputType | null
  }

  export type ProfileSettingsMinAggregateOutputType = {
    profileId: string | null
    isPrivate: boolean | null
    showLastSeen: boolean | null
    allowTagging: boolean | null
    allowMessagesFrom: string | null
    discoveryAllowLineage: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileSettingsMaxAggregateOutputType = {
    profileId: string | null
    isPrivate: boolean | null
    showLastSeen: boolean | null
    allowTagging: boolean | null
    allowMessagesFrom: string | null
    discoveryAllowLineage: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileSettingsCountAggregateOutputType = {
    profileId: number
    isPrivate: number
    showLastSeen: number
    allowTagging: number
    allowMessagesFrom: number
    discoveryAllowLineage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileSettingsMinAggregateInputType = {
    profileId?: true
    isPrivate?: true
    showLastSeen?: true
    allowTagging?: true
    allowMessagesFrom?: true
    discoveryAllowLineage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileSettingsMaxAggregateInputType = {
    profileId?: true
    isPrivate?: true
    showLastSeen?: true
    allowTagging?: true
    allowMessagesFrom?: true
    discoveryAllowLineage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileSettingsCountAggregateInputType = {
    profileId?: true
    isPrivate?: true
    showLastSeen?: true
    allowTagging?: true
    allowMessagesFrom?: true
    discoveryAllowLineage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileSettings to aggregate.
     */
    where?: ProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileSettings to fetch.
     */
    orderBy?: ProfileSettingsOrderByWithRelationInput | ProfileSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileSettings
    **/
    _count?: true | ProfileSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileSettingsMaxAggregateInputType
  }

  export type GetProfileSettingsAggregateType<T extends ProfileSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileSettings[P]>
      : GetScalarType<T[P], AggregateProfileSettings[P]>
  }




  export type ProfileSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileSettingsWhereInput
    orderBy?: ProfileSettingsOrderByWithAggregationInput | ProfileSettingsOrderByWithAggregationInput[]
    by: ProfileSettingsScalarFieldEnum[] | ProfileSettingsScalarFieldEnum
    having?: ProfileSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileSettingsCountAggregateInputType | true
    _min?: ProfileSettingsMinAggregateInputType
    _max?: ProfileSettingsMaxAggregateInputType
  }

  export type ProfileSettingsGroupByOutputType = {
    profileId: string
    isPrivate: boolean
    showLastSeen: boolean
    allowTagging: boolean
    allowMessagesFrom: string
    discoveryAllowLineage: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProfileSettingsCountAggregateOutputType | null
    _min: ProfileSettingsMinAggregateOutputType | null
    _max: ProfileSettingsMaxAggregateOutputType | null
  }

  type GetProfileSettingsGroupByPayload<T extends ProfileSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileSettingsGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: boolean
    discoveryAllowLineage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileSettings"]>

  export type ProfileSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: boolean
    discoveryAllowLineage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileSettings"]>

  export type ProfileSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    profileId?: boolean
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: boolean
    discoveryAllowLineage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileSettings"]>

  export type ProfileSettingsSelectScalar = {
    profileId?: boolean
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: boolean
    discoveryAllowLineage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"profileId" | "isPrivate" | "showLastSeen" | "allowTagging" | "allowMessagesFrom" | "discoveryAllowLineage" | "createdAt" | "updatedAt", ExtArgs["result"]["profileSettings"]>
  export type ProfileSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ProfileSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ProfileSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileSettings"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      profileId: string
      isPrivate: boolean
      showLastSeen: boolean
      allowTagging: boolean
      allowMessagesFrom: string
      discoveryAllowLineage: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profileSettings"]>
    composites: {}
  }

  type ProfileSettingsGetPayload<S extends boolean | null | undefined | ProfileSettingsDefaultArgs> = $Result.GetResult<Prisma.$ProfileSettingsPayload, S>

  type ProfileSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileSettingsCountAggregateInputType | true
    }

  export interface ProfileSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileSettings'], meta: { name: 'ProfileSettings' } }
    /**
     * Find zero or one ProfileSettings that matches the filter.
     * @param {ProfileSettingsFindUniqueArgs} args - Arguments to find a ProfileSettings
     * @example
     * // Get one ProfileSettings
     * const profileSettings = await prisma.profileSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileSettingsFindUniqueArgs>(args: SelectSubset<T, ProfileSettingsFindUniqueArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileSettingsFindUniqueOrThrowArgs} args - Arguments to find a ProfileSettings
     * @example
     * // Get one ProfileSettings
     * const profileSettings = await prisma.profileSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsFindFirstArgs} args - Arguments to find a ProfileSettings
     * @example
     * // Get one ProfileSettings
     * const profileSettings = await prisma.profileSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileSettingsFindFirstArgs>(args?: SelectSubset<T, ProfileSettingsFindFirstArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsFindFirstOrThrowArgs} args - Arguments to find a ProfileSettings
     * @example
     * // Get one ProfileSettings
     * const profileSettings = await prisma.profileSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileSettings
     * const profileSettings = await prisma.profileSettings.findMany()
     * 
     * // Get first 10 ProfileSettings
     * const profileSettings = await prisma.profileSettings.findMany({ take: 10 })
     * 
     * // Only select the `profileId`
     * const profileSettingsWithProfileIdOnly = await prisma.profileSettings.findMany({ select: { profileId: true } })
     * 
     */
    findMany<T extends ProfileSettingsFindManyArgs>(args?: SelectSubset<T, ProfileSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileSettings.
     * @param {ProfileSettingsCreateArgs} args - Arguments to create a ProfileSettings.
     * @example
     * // Create one ProfileSettings
     * const ProfileSettings = await prisma.profileSettings.create({
     *   data: {
     *     // ... data to create a ProfileSettings
     *   }
     * })
     * 
     */
    create<T extends ProfileSettingsCreateArgs>(args: SelectSubset<T, ProfileSettingsCreateArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileSettings.
     * @param {ProfileSettingsCreateManyArgs} args - Arguments to create many ProfileSettings.
     * @example
     * // Create many ProfileSettings
     * const profileSettings = await prisma.profileSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileSettingsCreateManyArgs>(args?: SelectSubset<T, ProfileSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileSettings and returns the data saved in the database.
     * @param {ProfileSettingsCreateManyAndReturnArgs} args - Arguments to create many ProfileSettings.
     * @example
     * // Create many ProfileSettings
     * const profileSettings = await prisma.profileSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileSettings and only return the `profileId`
     * const profileSettingsWithProfileIdOnly = await prisma.profileSettings.createManyAndReturn({
     *   select: { profileId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfileSettings.
     * @param {ProfileSettingsDeleteArgs} args - Arguments to delete one ProfileSettings.
     * @example
     * // Delete one ProfileSettings
     * const ProfileSettings = await prisma.profileSettings.delete({
     *   where: {
     *     // ... filter to delete one ProfileSettings
     *   }
     * })
     * 
     */
    delete<T extends ProfileSettingsDeleteArgs>(args: SelectSubset<T, ProfileSettingsDeleteArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileSettings.
     * @param {ProfileSettingsUpdateArgs} args - Arguments to update one ProfileSettings.
     * @example
     * // Update one ProfileSettings
     * const profileSettings = await prisma.profileSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileSettingsUpdateArgs>(args: SelectSubset<T, ProfileSettingsUpdateArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileSettings.
     * @param {ProfileSettingsDeleteManyArgs} args - Arguments to filter ProfileSettings to delete.
     * @example
     * // Delete a few ProfileSettings
     * const { count } = await prisma.profileSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileSettingsDeleteManyArgs>(args?: SelectSubset<T, ProfileSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileSettings
     * const profileSettings = await prisma.profileSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileSettingsUpdateManyArgs>(args: SelectSubset<T, ProfileSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileSettings and returns the data updated in the database.
     * @param {ProfileSettingsUpdateManyAndReturnArgs} args - Arguments to update many ProfileSettings.
     * @example
     * // Update many ProfileSettings
     * const profileSettings = await prisma.profileSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfileSettings and only return the `profileId`
     * const profileSettingsWithProfileIdOnly = await prisma.profileSettings.updateManyAndReturn({
     *   select: { profileId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfileSettings.
     * @param {ProfileSettingsUpsertArgs} args - Arguments to update or create a ProfileSettings.
     * @example
     * // Update or create a ProfileSettings
     * const profileSettings = await prisma.profileSettings.upsert({
     *   create: {
     *     // ... data to create a ProfileSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileSettings we want to update
     *   }
     * })
     */
    upsert<T extends ProfileSettingsUpsertArgs>(args: SelectSubset<T, ProfileSettingsUpsertArgs<ExtArgs>>): Prisma__ProfileSettingsClient<$Result.GetResult<Prisma.$ProfileSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsCountArgs} args - Arguments to filter ProfileSettings to count.
     * @example
     * // Count the number of ProfileSettings
     * const count = await prisma.profileSettings.count({
     *   where: {
     *     // ... the filter for the ProfileSettings we want to count
     *   }
     * })
    **/
    count<T extends ProfileSettingsCountArgs>(
      args?: Subset<T, ProfileSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileSettingsAggregateArgs>(args: Subset<T, ProfileSettingsAggregateArgs>): Prisma.PrismaPromise<GetProfileSettingsAggregateType<T>>

    /**
     * Group by ProfileSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileSettingsGroupByArgs['orderBy'] }
        : { orderBy?: ProfileSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileSettings model
   */
  readonly fields: ProfileSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileSettings model
   */
  interface ProfileSettingsFieldRefs {
    readonly profileId: FieldRef<"ProfileSettings", 'String'>
    readonly isPrivate: FieldRef<"ProfileSettings", 'Boolean'>
    readonly showLastSeen: FieldRef<"ProfileSettings", 'Boolean'>
    readonly allowTagging: FieldRef<"ProfileSettings", 'Boolean'>
    readonly allowMessagesFrom: FieldRef<"ProfileSettings", 'String'>
    readonly discoveryAllowLineage: FieldRef<"ProfileSettings", 'Boolean'>
    readonly createdAt: FieldRef<"ProfileSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"ProfileSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileSettings findUnique
   */
  export type ProfileSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where: ProfileSettingsWhereUniqueInput
  }

  /**
   * ProfileSettings findUniqueOrThrow
   */
  export type ProfileSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where: ProfileSettingsWhereUniqueInput
  }

  /**
   * ProfileSettings findFirst
   */
  export type ProfileSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where?: ProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileSettings to fetch.
     */
    orderBy?: ProfileSettingsOrderByWithRelationInput | ProfileSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileSettings.
     */
    cursor?: ProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileSettings.
     */
    distinct?: ProfileSettingsScalarFieldEnum | ProfileSettingsScalarFieldEnum[]
  }

  /**
   * ProfileSettings findFirstOrThrow
   */
  export type ProfileSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where?: ProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileSettings to fetch.
     */
    orderBy?: ProfileSettingsOrderByWithRelationInput | ProfileSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileSettings.
     */
    cursor?: ProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileSettings.
     */
    distinct?: ProfileSettingsScalarFieldEnum | ProfileSettingsScalarFieldEnum[]
  }

  /**
   * ProfileSettings findMany
   */
  export type ProfileSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter, which ProfileSettings to fetch.
     */
    where?: ProfileSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileSettings to fetch.
     */
    orderBy?: ProfileSettingsOrderByWithRelationInput | ProfileSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileSettings.
     */
    cursor?: ProfileSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileSettings.
     */
    skip?: number
    distinct?: ProfileSettingsScalarFieldEnum | ProfileSettingsScalarFieldEnum[]
  }

  /**
   * ProfileSettings create
   */
  export type ProfileSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileSettings.
     */
    data: XOR<ProfileSettingsCreateInput, ProfileSettingsUncheckedCreateInput>
  }

  /**
   * ProfileSettings createMany
   */
  export type ProfileSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileSettings.
     */
    data: ProfileSettingsCreateManyInput | ProfileSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileSettings createManyAndReturn
   */
  export type ProfileSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many ProfileSettings.
     */
    data: ProfileSettingsCreateManyInput | ProfileSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileSettings update
   */
  export type ProfileSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileSettings.
     */
    data: XOR<ProfileSettingsUpdateInput, ProfileSettingsUncheckedUpdateInput>
    /**
     * Choose, which ProfileSettings to update.
     */
    where: ProfileSettingsWhereUniqueInput
  }

  /**
   * ProfileSettings updateMany
   */
  export type ProfileSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileSettings.
     */
    data: XOR<ProfileSettingsUpdateManyMutationInput, ProfileSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ProfileSettings to update
     */
    where?: ProfileSettingsWhereInput
    /**
     * Limit how many ProfileSettings to update.
     */
    limit?: number
  }

  /**
   * ProfileSettings updateManyAndReturn
   */
  export type ProfileSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * The data used to update ProfileSettings.
     */
    data: XOR<ProfileSettingsUpdateManyMutationInput, ProfileSettingsUncheckedUpdateManyInput>
    /**
     * Filter which ProfileSettings to update
     */
    where?: ProfileSettingsWhereInput
    /**
     * Limit how many ProfileSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileSettings upsert
   */
  export type ProfileSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileSettings to update in case it exists.
     */
    where: ProfileSettingsWhereUniqueInput
    /**
     * In case the ProfileSettings found by the `where` argument doesn't exist, create a new ProfileSettings with this data.
     */
    create: XOR<ProfileSettingsCreateInput, ProfileSettingsUncheckedCreateInput>
    /**
     * In case the ProfileSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileSettingsUpdateInput, ProfileSettingsUncheckedUpdateInput>
  }

  /**
   * ProfileSettings delete
   */
  export type ProfileSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
    /**
     * Filter which ProfileSettings to delete.
     */
    where: ProfileSettingsWhereUniqueInput
  }

  /**
   * ProfileSettings deleteMany
   */
  export type ProfileSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileSettings to delete
     */
    where?: ProfileSettingsWhereInput
    /**
     * Limit how many ProfileSettings to delete.
     */
    limit?: number
  }

  /**
   * ProfileSettings without action
   */
  export type ProfileSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileSettings
     */
    select?: ProfileSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileSettings
     */
    omit?: ProfileSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Lineage
   */

  export type AggregateLineage = {
    _count: LineageCountAggregateOutputType | null
    _min: LineageMinAggregateOutputType | null
    _max: LineageMaxAggregateOutputType | null
  }

  export type LineageMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.LineageType | null
    primarySurname: string | null
    rootVillage: string | null
    rootRegion: string | null
    description: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LineageMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.LineageType | null
    primarySurname: string | null
    rootVillage: string | null
    rootRegion: string | null
    description: string | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LineageCountAggregateOutputType = {
    id: number
    name: number
    type: number
    primarySurname: number
    rootVillage: number
    rootRegion: number
    description: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LineageMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    primarySurname?: true
    rootVillage?: true
    rootRegion?: true
    description?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LineageMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    primarySurname?: true
    rootVillage?: true
    rootRegion?: true
    description?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LineageCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    primarySurname?: true
    rootVillage?: true
    rootRegion?: true
    description?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LineageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lineage to aggregate.
     */
    where?: LineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineages to fetch.
     */
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lineages
    **/
    _count?: true | LineageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LineageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LineageMaxAggregateInputType
  }

  export type GetLineageAggregateType<T extends LineageAggregateArgs> = {
        [P in keyof T & keyof AggregateLineage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineage[P]>
      : GetScalarType<T[P], AggregateLineage[P]>
  }




  export type LineageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageWhereInput
    orderBy?: LineageOrderByWithAggregationInput | LineageOrderByWithAggregationInput[]
    by: LineageScalarFieldEnum[] | LineageScalarFieldEnum
    having?: LineageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LineageCountAggregateInputType | true
    _min?: LineageMinAggregateInputType
    _max?: LineageMaxAggregateInputType
  }

  export type LineageGroupByOutputType = {
    id: string
    name: string
    type: $Enums.LineageType
    primarySurname: string | null
    rootVillage: string | null
    rootRegion: string | null
    description: string | null
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: LineageCountAggregateOutputType | null
    _min: LineageMinAggregateOutputType | null
    _max: LineageMaxAggregateOutputType | null
  }

  type GetLineageGroupByPayload<T extends LineageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LineageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LineageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineageGroupByOutputType[P]>
            : GetScalarType<T[P], LineageGroupByOutputType[P]>
        }
      >
    >


  export type LineageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    primarySurname?: boolean
    rootVillage?: boolean
    rootRegion?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
    memberships?: boolean | Lineage$membershipsArgs<ExtArgs>
    posts?: boolean | Lineage$postsArgs<ExtArgs>
    notifications?: boolean | Lineage$notificationsArgs<ExtArgs>
    _count?: boolean | LineageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lineage"]>

  export type LineageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    primarySurname?: boolean
    rootVillage?: boolean
    rootRegion?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["lineage"]>

  export type LineageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    primarySurname?: boolean
    rootVillage?: boolean
    rootRegion?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["lineage"]>

  export type LineageSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    primarySurname?: boolean
    rootVillage?: boolean
    rootRegion?: boolean
    description?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LineageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "primarySurname" | "rootVillage" | "rootRegion" | "description" | "createdById" | "createdAt" | "updatedAt", ExtArgs["result"]["lineage"]>
  export type LineageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
    memberships?: boolean | Lineage$membershipsArgs<ExtArgs>
    posts?: boolean | Lineage$postsArgs<ExtArgs>
    notifications?: boolean | Lineage$notificationsArgs<ExtArgs>
    _count?: boolean | LineageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LineageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
  }
  export type LineageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Lineage$createdByArgs<ExtArgs>
  }

  export type $LineagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lineage"
    objects: {
      createdBy: Prisma.$ProfilePayload<ExtArgs> | null
      memberships: Prisma.$LineageMembershipPayload<ExtArgs>[]
      posts: Prisma.$PostPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.LineageType
      primarySurname: string | null
      rootVillage: string | null
      rootRegion: string | null
      description: string | null
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lineage"]>
    composites: {}
  }

  type LineageGetPayload<S extends boolean | null | undefined | LineageDefaultArgs> = $Result.GetResult<Prisma.$LineagePayload, S>

  type LineageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LineageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LineageCountAggregateInputType | true
    }

  export interface LineageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lineage'], meta: { name: 'Lineage' } }
    /**
     * Find zero or one Lineage that matches the filter.
     * @param {LineageFindUniqueArgs} args - Arguments to find a Lineage
     * @example
     * // Get one Lineage
     * const lineage = await prisma.lineage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LineageFindUniqueArgs>(args: SelectSubset<T, LineageFindUniqueArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lineage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LineageFindUniqueOrThrowArgs} args - Arguments to find a Lineage
     * @example
     * // Get one Lineage
     * const lineage = await prisma.lineage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LineageFindUniqueOrThrowArgs>(args: SelectSubset<T, LineageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lineage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageFindFirstArgs} args - Arguments to find a Lineage
     * @example
     * // Get one Lineage
     * const lineage = await prisma.lineage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LineageFindFirstArgs>(args?: SelectSubset<T, LineageFindFirstArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lineage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageFindFirstOrThrowArgs} args - Arguments to find a Lineage
     * @example
     * // Get one Lineage
     * const lineage = await prisma.lineage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LineageFindFirstOrThrowArgs>(args?: SelectSubset<T, LineageFindFirstOrThrowArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lineages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lineages
     * const lineages = await prisma.lineage.findMany()
     * 
     * // Get first 10 Lineages
     * const lineages = await prisma.lineage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lineageWithIdOnly = await prisma.lineage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LineageFindManyArgs>(args?: SelectSubset<T, LineageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lineage.
     * @param {LineageCreateArgs} args - Arguments to create a Lineage.
     * @example
     * // Create one Lineage
     * const Lineage = await prisma.lineage.create({
     *   data: {
     *     // ... data to create a Lineage
     *   }
     * })
     * 
     */
    create<T extends LineageCreateArgs>(args: SelectSubset<T, LineageCreateArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lineages.
     * @param {LineageCreateManyArgs} args - Arguments to create many Lineages.
     * @example
     * // Create many Lineages
     * const lineage = await prisma.lineage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LineageCreateManyArgs>(args?: SelectSubset<T, LineageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lineages and returns the data saved in the database.
     * @param {LineageCreateManyAndReturnArgs} args - Arguments to create many Lineages.
     * @example
     * // Create many Lineages
     * const lineage = await prisma.lineage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lineages and only return the `id`
     * const lineageWithIdOnly = await prisma.lineage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LineageCreateManyAndReturnArgs>(args?: SelectSubset<T, LineageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lineage.
     * @param {LineageDeleteArgs} args - Arguments to delete one Lineage.
     * @example
     * // Delete one Lineage
     * const Lineage = await prisma.lineage.delete({
     *   where: {
     *     // ... filter to delete one Lineage
     *   }
     * })
     * 
     */
    delete<T extends LineageDeleteArgs>(args: SelectSubset<T, LineageDeleteArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lineage.
     * @param {LineageUpdateArgs} args - Arguments to update one Lineage.
     * @example
     * // Update one Lineage
     * const lineage = await prisma.lineage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LineageUpdateArgs>(args: SelectSubset<T, LineageUpdateArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lineages.
     * @param {LineageDeleteManyArgs} args - Arguments to filter Lineages to delete.
     * @example
     * // Delete a few Lineages
     * const { count } = await prisma.lineage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LineageDeleteManyArgs>(args?: SelectSubset<T, LineageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lineages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lineages
     * const lineage = await prisma.lineage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LineageUpdateManyArgs>(args: SelectSubset<T, LineageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lineages and returns the data updated in the database.
     * @param {LineageUpdateManyAndReturnArgs} args - Arguments to update many Lineages.
     * @example
     * // Update many Lineages
     * const lineage = await prisma.lineage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lineages and only return the `id`
     * const lineageWithIdOnly = await prisma.lineage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LineageUpdateManyAndReturnArgs>(args: SelectSubset<T, LineageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lineage.
     * @param {LineageUpsertArgs} args - Arguments to update or create a Lineage.
     * @example
     * // Update or create a Lineage
     * const lineage = await prisma.lineage.upsert({
     *   create: {
     *     // ... data to create a Lineage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lineage we want to update
     *   }
     * })
     */
    upsert<T extends LineageUpsertArgs>(args: SelectSubset<T, LineageUpsertArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lineages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageCountArgs} args - Arguments to filter Lineages to count.
     * @example
     * // Count the number of Lineages
     * const count = await prisma.lineage.count({
     *   where: {
     *     // ... the filter for the Lineages we want to count
     *   }
     * })
    **/
    count<T extends LineageCountArgs>(
      args?: Subset<T, LineageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LineageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lineage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LineageAggregateArgs>(args: Subset<T, LineageAggregateArgs>): Prisma.PrismaPromise<GetLineageAggregateType<T>>

    /**
     * Group by Lineage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LineageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineageGroupByArgs['orderBy'] }
        : { orderBy?: LineageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LineageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLineageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lineage model
   */
  readonly fields: LineageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lineage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Lineage$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Lineage$createdByArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    memberships<T extends Lineage$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Lineage$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    posts<T extends Lineage$postsArgs<ExtArgs> = {}>(args?: Subset<T, Lineage$postsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Lineage$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Lineage$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lineage model
   */
  interface LineageFieldRefs {
    readonly id: FieldRef<"Lineage", 'String'>
    readonly name: FieldRef<"Lineage", 'String'>
    readonly type: FieldRef<"Lineage", 'LineageType'>
    readonly primarySurname: FieldRef<"Lineage", 'String'>
    readonly rootVillage: FieldRef<"Lineage", 'String'>
    readonly rootRegion: FieldRef<"Lineage", 'String'>
    readonly description: FieldRef<"Lineage", 'String'>
    readonly createdById: FieldRef<"Lineage", 'String'>
    readonly createdAt: FieldRef<"Lineage", 'DateTime'>
    readonly updatedAt: FieldRef<"Lineage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lineage findUnique
   */
  export type LineageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineage to fetch.
     */
    where: LineageWhereUniqueInput
  }

  /**
   * Lineage findUniqueOrThrow
   */
  export type LineageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineage to fetch.
     */
    where: LineageWhereUniqueInput
  }

  /**
   * Lineage findFirst
   */
  export type LineageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineage to fetch.
     */
    where?: LineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineages to fetch.
     */
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lineages.
     */
    cursor?: LineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lineages.
     */
    distinct?: LineageScalarFieldEnum | LineageScalarFieldEnum[]
  }

  /**
   * Lineage findFirstOrThrow
   */
  export type LineageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineage to fetch.
     */
    where?: LineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineages to fetch.
     */
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lineages.
     */
    cursor?: LineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lineages.
     */
    distinct?: LineageScalarFieldEnum | LineageScalarFieldEnum[]
  }

  /**
   * Lineage findMany
   */
  export type LineageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter, which Lineages to fetch.
     */
    where?: LineageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lineages to fetch.
     */
    orderBy?: LineageOrderByWithRelationInput | LineageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lineages.
     */
    cursor?: LineageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lineages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lineages.
     */
    skip?: number
    distinct?: LineageScalarFieldEnum | LineageScalarFieldEnum[]
  }

  /**
   * Lineage create
   */
  export type LineageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * The data needed to create a Lineage.
     */
    data: XOR<LineageCreateInput, LineageUncheckedCreateInput>
  }

  /**
   * Lineage createMany
   */
  export type LineageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lineages.
     */
    data: LineageCreateManyInput | LineageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lineage createManyAndReturn
   */
  export type LineageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * The data used to create many Lineages.
     */
    data: LineageCreateManyInput | LineageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lineage update
   */
  export type LineageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * The data needed to update a Lineage.
     */
    data: XOR<LineageUpdateInput, LineageUncheckedUpdateInput>
    /**
     * Choose, which Lineage to update.
     */
    where: LineageWhereUniqueInput
  }

  /**
   * Lineage updateMany
   */
  export type LineageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lineages.
     */
    data: XOR<LineageUpdateManyMutationInput, LineageUncheckedUpdateManyInput>
    /**
     * Filter which Lineages to update
     */
    where?: LineageWhereInput
    /**
     * Limit how many Lineages to update.
     */
    limit?: number
  }

  /**
   * Lineage updateManyAndReturn
   */
  export type LineageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * The data used to update Lineages.
     */
    data: XOR<LineageUpdateManyMutationInput, LineageUncheckedUpdateManyInput>
    /**
     * Filter which Lineages to update
     */
    where?: LineageWhereInput
    /**
     * Limit how many Lineages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lineage upsert
   */
  export type LineageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * The filter to search for the Lineage to update in case it exists.
     */
    where: LineageWhereUniqueInput
    /**
     * In case the Lineage found by the `where` argument doesn't exist, create a new Lineage with this data.
     */
    create: XOR<LineageCreateInput, LineageUncheckedCreateInput>
    /**
     * In case the Lineage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineageUpdateInput, LineageUncheckedUpdateInput>
  }

  /**
   * Lineage delete
   */
  export type LineageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    /**
     * Filter which Lineage to delete.
     */
    where: LineageWhereUniqueInput
  }

  /**
   * Lineage deleteMany
   */
  export type LineageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lineages to delete
     */
    where?: LineageWhereInput
    /**
     * Limit how many Lineages to delete.
     */
    limit?: number
  }

  /**
   * Lineage.createdBy
   */
  export type Lineage$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Lineage.memberships
   */
  export type Lineage$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    where?: LineageMembershipWhereInput
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    cursor?: LineageMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * Lineage.posts
   */
  export type Lineage$postsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    cursor?: PostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Lineage.notifications
   */
  export type Lineage$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Lineage without action
   */
  export type LineageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
  }


  /**
   * Model LineageMembership
   */

  export type AggregateLineageMembership = {
    _count: LineageMembershipCountAggregateOutputType | null
    _avg: LineageMembershipAvgAggregateOutputType | null
    _sum: LineageMembershipSumAggregateOutputType | null
    _min: LineageMembershipMinAggregateOutputType | null
    _max: LineageMembershipMaxAggregateOutputType | null
  }

  export type LineageMembershipAvgAggregateOutputType = {
    generation: number | null
  }

  export type LineageMembershipSumAggregateOutputType = {
    generation: number | null
  }

  export type LineageMembershipMinAggregateOutputType = {
    id: string | null
    lineageId: string | null
    profileId: string | null
    role: $Enums.LineageRole | null
    generation: number | null
    isPrimaryLineage: boolean | null
    addedById: string | null
    createdAt: Date | null
  }

  export type LineageMembershipMaxAggregateOutputType = {
    id: string | null
    lineageId: string | null
    profileId: string | null
    role: $Enums.LineageRole | null
    generation: number | null
    isPrimaryLineage: boolean | null
    addedById: string | null
    createdAt: Date | null
  }

  export type LineageMembershipCountAggregateOutputType = {
    id: number
    lineageId: number
    profileId: number
    role: number
    generation: number
    isPrimaryLineage: number
    addedById: number
    createdAt: number
    _all: number
  }


  export type LineageMembershipAvgAggregateInputType = {
    generation?: true
  }

  export type LineageMembershipSumAggregateInputType = {
    generation?: true
  }

  export type LineageMembershipMinAggregateInputType = {
    id?: true
    lineageId?: true
    profileId?: true
    role?: true
    generation?: true
    isPrimaryLineage?: true
    addedById?: true
    createdAt?: true
  }

  export type LineageMembershipMaxAggregateInputType = {
    id?: true
    lineageId?: true
    profileId?: true
    role?: true
    generation?: true
    isPrimaryLineage?: true
    addedById?: true
    createdAt?: true
  }

  export type LineageMembershipCountAggregateInputType = {
    id?: true
    lineageId?: true
    profileId?: true
    role?: true
    generation?: true
    isPrimaryLineage?: true
    addedById?: true
    createdAt?: true
    _all?: true
  }

  export type LineageMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineageMembership to aggregate.
     */
    where?: LineageMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineageMemberships to fetch.
     */
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LineageMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineageMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineageMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LineageMemberships
    **/
    _count?: true | LineageMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LineageMembershipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LineageMembershipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LineageMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LineageMembershipMaxAggregateInputType
  }

  export type GetLineageMembershipAggregateType<T extends LineageMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateLineageMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLineageMembership[P]>
      : GetScalarType<T[P], AggregateLineageMembership[P]>
  }




  export type LineageMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LineageMembershipWhereInput
    orderBy?: LineageMembershipOrderByWithAggregationInput | LineageMembershipOrderByWithAggregationInput[]
    by: LineageMembershipScalarFieldEnum[] | LineageMembershipScalarFieldEnum
    having?: LineageMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LineageMembershipCountAggregateInputType | true
    _avg?: LineageMembershipAvgAggregateInputType
    _sum?: LineageMembershipSumAggregateInputType
    _min?: LineageMembershipMinAggregateInputType
    _max?: LineageMembershipMaxAggregateInputType
  }

  export type LineageMembershipGroupByOutputType = {
    id: string
    lineageId: string
    profileId: string
    role: $Enums.LineageRole
    generation: number | null
    isPrimaryLineage: boolean
    addedById: string | null
    createdAt: Date
    _count: LineageMembershipCountAggregateOutputType | null
    _avg: LineageMembershipAvgAggregateOutputType | null
    _sum: LineageMembershipSumAggregateOutputType | null
    _min: LineageMembershipMinAggregateOutputType | null
    _max: LineageMembershipMaxAggregateOutputType | null
  }

  type GetLineageMembershipGroupByPayload<T extends LineageMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LineageMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LineageMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LineageMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], LineageMembershipGroupByOutputType[P]>
        }
      >
    >


  export type LineageMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineageId?: boolean
    profileId?: boolean
    role?: boolean
    generation?: boolean
    isPrimaryLineage?: boolean
    addedById?: boolean
    createdAt?: boolean
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["lineageMembership"]>

  export type LineageMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineageId?: boolean
    profileId?: boolean
    role?: boolean
    generation?: boolean
    isPrimaryLineage?: boolean
    addedById?: boolean
    createdAt?: boolean
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["lineageMembership"]>

  export type LineageMembershipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lineageId?: boolean
    profileId?: boolean
    role?: boolean
    generation?: boolean
    isPrimaryLineage?: boolean
    addedById?: boolean
    createdAt?: boolean
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
  }, ExtArgs["result"]["lineageMembership"]>

  export type LineageMembershipSelectScalar = {
    id?: boolean
    lineageId?: boolean
    profileId?: boolean
    role?: boolean
    generation?: boolean
    isPrimaryLineage?: boolean
    addedById?: boolean
    createdAt?: boolean
  }

  export type LineageMembershipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lineageId" | "profileId" | "role" | "generation" | "isPrimaryLineage" | "addedById" | "createdAt", ExtArgs["result"]["lineageMembership"]>
  export type LineageMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
  }
  export type LineageMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
  }
  export type LineageMembershipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lineage?: boolean | LineageDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    addedBy?: boolean | LineageMembership$addedByArgs<ExtArgs>
  }

  export type $LineageMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LineageMembership"
    objects: {
      lineage: Prisma.$LineagePayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
      addedBy: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lineageId: string
      profileId: string
      role: $Enums.LineageRole
      generation: number | null
      isPrimaryLineage: boolean
      addedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["lineageMembership"]>
    composites: {}
  }

  type LineageMembershipGetPayload<S extends boolean | null | undefined | LineageMembershipDefaultArgs> = $Result.GetResult<Prisma.$LineageMembershipPayload, S>

  type LineageMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LineageMembershipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LineageMembershipCountAggregateInputType | true
    }

  export interface LineageMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LineageMembership'], meta: { name: 'LineageMembership' } }
    /**
     * Find zero or one LineageMembership that matches the filter.
     * @param {LineageMembershipFindUniqueArgs} args - Arguments to find a LineageMembership
     * @example
     * // Get one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LineageMembershipFindUniqueArgs>(args: SelectSubset<T, LineageMembershipFindUniqueArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LineageMembership that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LineageMembershipFindUniqueOrThrowArgs} args - Arguments to find a LineageMembership
     * @example
     * // Get one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LineageMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, LineageMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LineageMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipFindFirstArgs} args - Arguments to find a LineageMembership
     * @example
     * // Get one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LineageMembershipFindFirstArgs>(args?: SelectSubset<T, LineageMembershipFindFirstArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LineageMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipFindFirstOrThrowArgs} args - Arguments to find a LineageMembership
     * @example
     * // Get one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LineageMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, LineageMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LineageMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LineageMemberships
     * const lineageMemberships = await prisma.lineageMembership.findMany()
     * 
     * // Get first 10 LineageMemberships
     * const lineageMemberships = await prisma.lineageMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lineageMembershipWithIdOnly = await prisma.lineageMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LineageMembershipFindManyArgs>(args?: SelectSubset<T, LineageMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LineageMembership.
     * @param {LineageMembershipCreateArgs} args - Arguments to create a LineageMembership.
     * @example
     * // Create one LineageMembership
     * const LineageMembership = await prisma.lineageMembership.create({
     *   data: {
     *     // ... data to create a LineageMembership
     *   }
     * })
     * 
     */
    create<T extends LineageMembershipCreateArgs>(args: SelectSubset<T, LineageMembershipCreateArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LineageMemberships.
     * @param {LineageMembershipCreateManyArgs} args - Arguments to create many LineageMemberships.
     * @example
     * // Create many LineageMemberships
     * const lineageMembership = await prisma.lineageMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LineageMembershipCreateManyArgs>(args?: SelectSubset<T, LineageMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LineageMemberships and returns the data saved in the database.
     * @param {LineageMembershipCreateManyAndReturnArgs} args - Arguments to create many LineageMemberships.
     * @example
     * // Create many LineageMemberships
     * const lineageMembership = await prisma.lineageMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LineageMemberships and only return the `id`
     * const lineageMembershipWithIdOnly = await prisma.lineageMembership.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LineageMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, LineageMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LineageMembership.
     * @param {LineageMembershipDeleteArgs} args - Arguments to delete one LineageMembership.
     * @example
     * // Delete one LineageMembership
     * const LineageMembership = await prisma.lineageMembership.delete({
     *   where: {
     *     // ... filter to delete one LineageMembership
     *   }
     * })
     * 
     */
    delete<T extends LineageMembershipDeleteArgs>(args: SelectSubset<T, LineageMembershipDeleteArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LineageMembership.
     * @param {LineageMembershipUpdateArgs} args - Arguments to update one LineageMembership.
     * @example
     * // Update one LineageMembership
     * const lineageMembership = await prisma.lineageMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LineageMembershipUpdateArgs>(args: SelectSubset<T, LineageMembershipUpdateArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LineageMemberships.
     * @param {LineageMembershipDeleteManyArgs} args - Arguments to filter LineageMemberships to delete.
     * @example
     * // Delete a few LineageMemberships
     * const { count } = await prisma.lineageMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LineageMembershipDeleteManyArgs>(args?: SelectSubset<T, LineageMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LineageMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LineageMemberships
     * const lineageMembership = await prisma.lineageMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LineageMembershipUpdateManyArgs>(args: SelectSubset<T, LineageMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LineageMemberships and returns the data updated in the database.
     * @param {LineageMembershipUpdateManyAndReturnArgs} args - Arguments to update many LineageMemberships.
     * @example
     * // Update many LineageMemberships
     * const lineageMembership = await prisma.lineageMembership.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LineageMemberships and only return the `id`
     * const lineageMembershipWithIdOnly = await prisma.lineageMembership.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LineageMembershipUpdateManyAndReturnArgs>(args: SelectSubset<T, LineageMembershipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LineageMembership.
     * @param {LineageMembershipUpsertArgs} args - Arguments to update or create a LineageMembership.
     * @example
     * // Update or create a LineageMembership
     * const lineageMembership = await prisma.lineageMembership.upsert({
     *   create: {
     *     // ... data to create a LineageMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LineageMembership we want to update
     *   }
     * })
     */
    upsert<T extends LineageMembershipUpsertArgs>(args: SelectSubset<T, LineageMembershipUpsertArgs<ExtArgs>>): Prisma__LineageMembershipClient<$Result.GetResult<Prisma.$LineageMembershipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LineageMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipCountArgs} args - Arguments to filter LineageMemberships to count.
     * @example
     * // Count the number of LineageMemberships
     * const count = await prisma.lineageMembership.count({
     *   where: {
     *     // ... the filter for the LineageMemberships we want to count
     *   }
     * })
    **/
    count<T extends LineageMembershipCountArgs>(
      args?: Subset<T, LineageMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LineageMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LineageMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LineageMembershipAggregateArgs>(args: Subset<T, LineageMembershipAggregateArgs>): Prisma.PrismaPromise<GetLineageMembershipAggregateType<T>>

    /**
     * Group by LineageMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LineageMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LineageMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LineageMembershipGroupByArgs['orderBy'] }
        : { orderBy?: LineageMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LineageMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLineageMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LineageMembership model
   */
  readonly fields: LineageMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LineageMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LineageMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lineage<T extends LineageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LineageDefaultArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addedBy<T extends LineageMembership$addedByArgs<ExtArgs> = {}>(args?: Subset<T, LineageMembership$addedByArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LineageMembership model
   */
  interface LineageMembershipFieldRefs {
    readonly id: FieldRef<"LineageMembership", 'String'>
    readonly lineageId: FieldRef<"LineageMembership", 'String'>
    readonly profileId: FieldRef<"LineageMembership", 'String'>
    readonly role: FieldRef<"LineageMembership", 'LineageRole'>
    readonly generation: FieldRef<"LineageMembership", 'Int'>
    readonly isPrimaryLineage: FieldRef<"LineageMembership", 'Boolean'>
    readonly addedById: FieldRef<"LineageMembership", 'String'>
    readonly createdAt: FieldRef<"LineageMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LineageMembership findUnique
   */
  export type LineageMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMembership to fetch.
     */
    where: LineageMembershipWhereUniqueInput
  }

  /**
   * LineageMembership findUniqueOrThrow
   */
  export type LineageMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMembership to fetch.
     */
    where: LineageMembershipWhereUniqueInput
  }

  /**
   * LineageMembership findFirst
   */
  export type LineageMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMembership to fetch.
     */
    where?: LineageMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineageMemberships to fetch.
     */
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineageMemberships.
     */
    cursor?: LineageMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineageMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineageMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineageMemberships.
     */
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * LineageMembership findFirstOrThrow
   */
  export type LineageMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMembership to fetch.
     */
    where?: LineageMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineageMemberships to fetch.
     */
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LineageMemberships.
     */
    cursor?: LineageMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineageMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineageMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LineageMemberships.
     */
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * LineageMembership findMany
   */
  export type LineageMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter, which LineageMemberships to fetch.
     */
    where?: LineageMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LineageMemberships to fetch.
     */
    orderBy?: LineageMembershipOrderByWithRelationInput | LineageMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LineageMemberships.
     */
    cursor?: LineageMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LineageMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LineageMemberships.
     */
    skip?: number
    distinct?: LineageMembershipScalarFieldEnum | LineageMembershipScalarFieldEnum[]
  }

  /**
   * LineageMembership create
   */
  export type LineageMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a LineageMembership.
     */
    data: XOR<LineageMembershipCreateInput, LineageMembershipUncheckedCreateInput>
  }

  /**
   * LineageMembership createMany
   */
  export type LineageMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LineageMemberships.
     */
    data: LineageMembershipCreateManyInput | LineageMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LineageMembership createManyAndReturn
   */
  export type LineageMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * The data used to create many LineageMemberships.
     */
    data: LineageMembershipCreateManyInput | LineageMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LineageMembership update
   */
  export type LineageMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a LineageMembership.
     */
    data: XOR<LineageMembershipUpdateInput, LineageMembershipUncheckedUpdateInput>
    /**
     * Choose, which LineageMembership to update.
     */
    where: LineageMembershipWhereUniqueInput
  }

  /**
   * LineageMembership updateMany
   */
  export type LineageMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LineageMemberships.
     */
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyInput>
    /**
     * Filter which LineageMemberships to update
     */
    where?: LineageMembershipWhereInput
    /**
     * Limit how many LineageMemberships to update.
     */
    limit?: number
  }

  /**
   * LineageMembership updateManyAndReturn
   */
  export type LineageMembershipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * The data used to update LineageMemberships.
     */
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyInput>
    /**
     * Filter which LineageMemberships to update
     */
    where?: LineageMembershipWhereInput
    /**
     * Limit how many LineageMemberships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LineageMembership upsert
   */
  export type LineageMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the LineageMembership to update in case it exists.
     */
    where: LineageMembershipWhereUniqueInput
    /**
     * In case the LineageMembership found by the `where` argument doesn't exist, create a new LineageMembership with this data.
     */
    create: XOR<LineageMembershipCreateInput, LineageMembershipUncheckedCreateInput>
    /**
     * In case the LineageMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LineageMembershipUpdateInput, LineageMembershipUncheckedUpdateInput>
  }

  /**
   * LineageMembership delete
   */
  export type LineageMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
    /**
     * Filter which LineageMembership to delete.
     */
    where: LineageMembershipWhereUniqueInput
  }

  /**
   * LineageMembership deleteMany
   */
  export type LineageMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LineageMemberships to delete
     */
    where?: LineageMembershipWhereInput
    /**
     * Limit how many LineageMemberships to delete.
     */
    limit?: number
  }

  /**
   * LineageMembership.addedBy
   */
  export type LineageMembership$addedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * LineageMembership without action
   */
  export type LineageMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LineageMembership
     */
    select?: LineageMembershipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LineageMembership
     */
    omit?: LineageMembershipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageMembershipInclude<ExtArgs> | null
  }


  /**
   * Model Kinship
   */

  export type AggregateKinship = {
    _count: KinshipCountAggregateOutputType | null
    _min: KinshipMinAggregateOutputType | null
    _max: KinshipMaxAggregateOutputType | null
  }

  export type KinshipMinAggregateOutputType = {
    id: string | null
    profileIdA: string | null
    profileIdB: string | null
    relationAtoB: $Enums.KinshipType | null
    verified: boolean | null
    verifiedById: string | null
    createdAt: Date | null
  }

  export type KinshipMaxAggregateOutputType = {
    id: string | null
    profileIdA: string | null
    profileIdB: string | null
    relationAtoB: $Enums.KinshipType | null
    verified: boolean | null
    verifiedById: string | null
    createdAt: Date | null
  }

  export type KinshipCountAggregateOutputType = {
    id: number
    profileIdA: number
    profileIdB: number
    relationAtoB: number
    verified: number
    verifiedById: number
    createdAt: number
    _all: number
  }


  export type KinshipMinAggregateInputType = {
    id?: true
    profileIdA?: true
    profileIdB?: true
    relationAtoB?: true
    verified?: true
    verifiedById?: true
    createdAt?: true
  }

  export type KinshipMaxAggregateInputType = {
    id?: true
    profileIdA?: true
    profileIdB?: true
    relationAtoB?: true
    verified?: true
    verifiedById?: true
    createdAt?: true
  }

  export type KinshipCountAggregateInputType = {
    id?: true
    profileIdA?: true
    profileIdB?: true
    relationAtoB?: true
    verified?: true
    verifiedById?: true
    createdAt?: true
    _all?: true
  }

  export type KinshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kinship to aggregate.
     */
    where?: KinshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kinships to fetch.
     */
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KinshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kinships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kinships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kinships
    **/
    _count?: true | KinshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KinshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KinshipMaxAggregateInputType
  }

  export type GetKinshipAggregateType<T extends KinshipAggregateArgs> = {
        [P in keyof T & keyof AggregateKinship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKinship[P]>
      : GetScalarType<T[P], AggregateKinship[P]>
  }




  export type KinshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KinshipWhereInput
    orderBy?: KinshipOrderByWithAggregationInput | KinshipOrderByWithAggregationInput[]
    by: KinshipScalarFieldEnum[] | KinshipScalarFieldEnum
    having?: KinshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KinshipCountAggregateInputType | true
    _min?: KinshipMinAggregateInputType
    _max?: KinshipMaxAggregateInputType
  }

  export type KinshipGroupByOutputType = {
    id: string
    profileIdA: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified: boolean
    verifiedById: string | null
    createdAt: Date
    _count: KinshipCountAggregateOutputType | null
    _min: KinshipMinAggregateOutputType | null
    _max: KinshipMaxAggregateOutputType | null
  }

  type GetKinshipGroupByPayload<T extends KinshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KinshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KinshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KinshipGroupByOutputType[P]>
            : GetScalarType<T[P], KinshipGroupByOutputType[P]>
        }
      >
    >


  export type KinshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileIdA?: boolean
    profileIdB?: boolean
    relationAtoB?: boolean
    verified?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kinship"]>

  export type KinshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileIdA?: boolean
    profileIdB?: boolean
    relationAtoB?: boolean
    verified?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kinship"]>

  export type KinshipSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileIdA?: boolean
    profileIdB?: boolean
    relationAtoB?: boolean
    verified?: boolean
    verifiedById?: boolean
    createdAt?: boolean
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kinship"]>

  export type KinshipSelectScalar = {
    id?: boolean
    profileIdA?: boolean
    profileIdB?: boolean
    relationAtoB?: boolean
    verified?: boolean
    verifiedById?: boolean
    createdAt?: boolean
  }

  export type KinshipOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileIdA" | "profileIdB" | "relationAtoB" | "verified" | "verifiedById" | "createdAt", ExtArgs["result"]["kinship"]>
  export type KinshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type KinshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type KinshipIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profileA?: boolean | ProfileDefaultArgs<ExtArgs>
    profileB?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $KinshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kinship"
    objects: {
      profileA: Prisma.$ProfilePayload<ExtArgs>
      profileB: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileIdA: string
      profileIdB: string
      relationAtoB: $Enums.KinshipType
      verified: boolean
      verifiedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["kinship"]>
    composites: {}
  }

  type KinshipGetPayload<S extends boolean | null | undefined | KinshipDefaultArgs> = $Result.GetResult<Prisma.$KinshipPayload, S>

  type KinshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KinshipFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KinshipCountAggregateInputType | true
    }

  export interface KinshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kinship'], meta: { name: 'Kinship' } }
    /**
     * Find zero or one Kinship that matches the filter.
     * @param {KinshipFindUniqueArgs} args - Arguments to find a Kinship
     * @example
     * // Get one Kinship
     * const kinship = await prisma.kinship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KinshipFindUniqueArgs>(args: SelectSubset<T, KinshipFindUniqueArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kinship that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KinshipFindUniqueOrThrowArgs} args - Arguments to find a Kinship
     * @example
     * // Get one Kinship
     * const kinship = await prisma.kinship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KinshipFindUniqueOrThrowArgs>(args: SelectSubset<T, KinshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kinship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipFindFirstArgs} args - Arguments to find a Kinship
     * @example
     * // Get one Kinship
     * const kinship = await prisma.kinship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KinshipFindFirstArgs>(args?: SelectSubset<T, KinshipFindFirstArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kinship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipFindFirstOrThrowArgs} args - Arguments to find a Kinship
     * @example
     * // Get one Kinship
     * const kinship = await prisma.kinship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KinshipFindFirstOrThrowArgs>(args?: SelectSubset<T, KinshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kinships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kinships
     * const kinships = await prisma.kinship.findMany()
     * 
     * // Get first 10 Kinships
     * const kinships = await prisma.kinship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kinshipWithIdOnly = await prisma.kinship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KinshipFindManyArgs>(args?: SelectSubset<T, KinshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kinship.
     * @param {KinshipCreateArgs} args - Arguments to create a Kinship.
     * @example
     * // Create one Kinship
     * const Kinship = await prisma.kinship.create({
     *   data: {
     *     // ... data to create a Kinship
     *   }
     * })
     * 
     */
    create<T extends KinshipCreateArgs>(args: SelectSubset<T, KinshipCreateArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kinships.
     * @param {KinshipCreateManyArgs} args - Arguments to create many Kinships.
     * @example
     * // Create many Kinships
     * const kinship = await prisma.kinship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KinshipCreateManyArgs>(args?: SelectSubset<T, KinshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kinships and returns the data saved in the database.
     * @param {KinshipCreateManyAndReturnArgs} args - Arguments to create many Kinships.
     * @example
     * // Create many Kinships
     * const kinship = await prisma.kinship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kinships and only return the `id`
     * const kinshipWithIdOnly = await prisma.kinship.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KinshipCreateManyAndReturnArgs>(args?: SelectSubset<T, KinshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kinship.
     * @param {KinshipDeleteArgs} args - Arguments to delete one Kinship.
     * @example
     * // Delete one Kinship
     * const Kinship = await prisma.kinship.delete({
     *   where: {
     *     // ... filter to delete one Kinship
     *   }
     * })
     * 
     */
    delete<T extends KinshipDeleteArgs>(args: SelectSubset<T, KinshipDeleteArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kinship.
     * @param {KinshipUpdateArgs} args - Arguments to update one Kinship.
     * @example
     * // Update one Kinship
     * const kinship = await prisma.kinship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KinshipUpdateArgs>(args: SelectSubset<T, KinshipUpdateArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kinships.
     * @param {KinshipDeleteManyArgs} args - Arguments to filter Kinships to delete.
     * @example
     * // Delete a few Kinships
     * const { count } = await prisma.kinship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KinshipDeleteManyArgs>(args?: SelectSubset<T, KinshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kinships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kinships
     * const kinship = await prisma.kinship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KinshipUpdateManyArgs>(args: SelectSubset<T, KinshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kinships and returns the data updated in the database.
     * @param {KinshipUpdateManyAndReturnArgs} args - Arguments to update many Kinships.
     * @example
     * // Update many Kinships
     * const kinship = await prisma.kinship.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kinships and only return the `id`
     * const kinshipWithIdOnly = await prisma.kinship.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KinshipUpdateManyAndReturnArgs>(args: SelectSubset<T, KinshipUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kinship.
     * @param {KinshipUpsertArgs} args - Arguments to update or create a Kinship.
     * @example
     * // Update or create a Kinship
     * const kinship = await prisma.kinship.upsert({
     *   create: {
     *     // ... data to create a Kinship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kinship we want to update
     *   }
     * })
     */
    upsert<T extends KinshipUpsertArgs>(args: SelectSubset<T, KinshipUpsertArgs<ExtArgs>>): Prisma__KinshipClient<$Result.GetResult<Prisma.$KinshipPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kinships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipCountArgs} args - Arguments to filter Kinships to count.
     * @example
     * // Count the number of Kinships
     * const count = await prisma.kinship.count({
     *   where: {
     *     // ... the filter for the Kinships we want to count
     *   }
     * })
    **/
    count<T extends KinshipCountArgs>(
      args?: Subset<T, KinshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KinshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kinship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KinshipAggregateArgs>(args: Subset<T, KinshipAggregateArgs>): Prisma.PrismaPromise<GetKinshipAggregateType<T>>

    /**
     * Group by Kinship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KinshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KinshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KinshipGroupByArgs['orderBy'] }
        : { orderBy?: KinshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KinshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKinshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kinship model
   */
  readonly fields: KinshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kinship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KinshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profileA<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profileB<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kinship model
   */
  interface KinshipFieldRefs {
    readonly id: FieldRef<"Kinship", 'String'>
    readonly profileIdA: FieldRef<"Kinship", 'String'>
    readonly profileIdB: FieldRef<"Kinship", 'String'>
    readonly relationAtoB: FieldRef<"Kinship", 'KinshipType'>
    readonly verified: FieldRef<"Kinship", 'Boolean'>
    readonly verifiedById: FieldRef<"Kinship", 'String'>
    readonly createdAt: FieldRef<"Kinship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kinship findUnique
   */
  export type KinshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinship to fetch.
     */
    where: KinshipWhereUniqueInput
  }

  /**
   * Kinship findUniqueOrThrow
   */
  export type KinshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinship to fetch.
     */
    where: KinshipWhereUniqueInput
  }

  /**
   * Kinship findFirst
   */
  export type KinshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinship to fetch.
     */
    where?: KinshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kinships to fetch.
     */
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kinships.
     */
    cursor?: KinshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kinships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kinships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kinships.
     */
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Kinship findFirstOrThrow
   */
  export type KinshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinship to fetch.
     */
    where?: KinshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kinships to fetch.
     */
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kinships.
     */
    cursor?: KinshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kinships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kinships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kinships.
     */
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Kinship findMany
   */
  export type KinshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter, which Kinships to fetch.
     */
    where?: KinshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kinships to fetch.
     */
    orderBy?: KinshipOrderByWithRelationInput | KinshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kinships.
     */
    cursor?: KinshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kinships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kinships.
     */
    skip?: number
    distinct?: KinshipScalarFieldEnum | KinshipScalarFieldEnum[]
  }

  /**
   * Kinship create
   */
  export type KinshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Kinship.
     */
    data: XOR<KinshipCreateInput, KinshipUncheckedCreateInput>
  }

  /**
   * Kinship createMany
   */
  export type KinshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kinships.
     */
    data: KinshipCreateManyInput | KinshipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kinship createManyAndReturn
   */
  export type KinshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * The data used to create many Kinships.
     */
    data: KinshipCreateManyInput | KinshipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kinship update
   */
  export type KinshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Kinship.
     */
    data: XOR<KinshipUpdateInput, KinshipUncheckedUpdateInput>
    /**
     * Choose, which Kinship to update.
     */
    where: KinshipWhereUniqueInput
  }

  /**
   * Kinship updateMany
   */
  export type KinshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kinships.
     */
    data: XOR<KinshipUpdateManyMutationInput, KinshipUncheckedUpdateManyInput>
    /**
     * Filter which Kinships to update
     */
    where?: KinshipWhereInput
    /**
     * Limit how many Kinships to update.
     */
    limit?: number
  }

  /**
   * Kinship updateManyAndReturn
   */
  export type KinshipUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * The data used to update Kinships.
     */
    data: XOR<KinshipUpdateManyMutationInput, KinshipUncheckedUpdateManyInput>
    /**
     * Filter which Kinships to update
     */
    where?: KinshipWhereInput
    /**
     * Limit how many Kinships to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kinship upsert
   */
  export type KinshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Kinship to update in case it exists.
     */
    where: KinshipWhereUniqueInput
    /**
     * In case the Kinship found by the `where` argument doesn't exist, create a new Kinship with this data.
     */
    create: XOR<KinshipCreateInput, KinshipUncheckedCreateInput>
    /**
     * In case the Kinship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KinshipUpdateInput, KinshipUncheckedUpdateInput>
  }

  /**
   * Kinship delete
   */
  export type KinshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
    /**
     * Filter which Kinship to delete.
     */
    where: KinshipWhereUniqueInput
  }

  /**
   * Kinship deleteMany
   */
  export type KinshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kinships to delete
     */
    where?: KinshipWhereInput
    /**
     * Limit how many Kinships to delete.
     */
    limit?: number
  }

  /**
   * Kinship without action
   */
  export type KinshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kinship
     */
    select?: KinshipSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kinship
     */
    omit?: KinshipOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KinshipInclude<ExtArgs> | null
  }


  /**
   * Model Follow
   */

  export type AggregateFollow = {
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  export type FollowMinAggregateOutputType = {
    id: string | null
    followerId: string | null
    followeeId: string | null
    createdAt: Date | null
  }

  export type FollowMaxAggregateOutputType = {
    id: string | null
    followerId: string | null
    followeeId: string | null
    createdAt: Date | null
  }

  export type FollowCountAggregateOutputType = {
    id: number
    followerId: number
    followeeId: number
    createdAt: number
    _all: number
  }


  export type FollowMinAggregateInputType = {
    id?: true
    followerId?: true
    followeeId?: true
    createdAt?: true
  }

  export type FollowMaxAggregateInputType = {
    id?: true
    followerId?: true
    followeeId?: true
    createdAt?: true
  }

  export type FollowCountAggregateInputType = {
    id?: true
    followerId?: true
    followeeId?: true
    createdAt?: true
    _all?: true
  }

  export type FollowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follow to aggregate.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Follows
    **/
    _count?: true | FollowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowMaxAggregateInputType
  }

  export type GetFollowAggregateType<T extends FollowAggregateArgs> = {
        [P in keyof T & keyof AggregateFollow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollow[P]>
      : GetScalarType<T[P], AggregateFollow[P]>
  }




  export type FollowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FollowWhereInput
    orderBy?: FollowOrderByWithAggregationInput | FollowOrderByWithAggregationInput[]
    by: FollowScalarFieldEnum[] | FollowScalarFieldEnum
    having?: FollowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowCountAggregateInputType | true
    _min?: FollowMinAggregateInputType
    _max?: FollowMaxAggregateInputType
  }

  export type FollowGroupByOutputType = {
    id: string
    followerId: string
    followeeId: string
    createdAt: Date
    _count: FollowCountAggregateOutputType | null
    _min: FollowMinAggregateOutputType | null
    _max: FollowMaxAggregateOutputType | null
  }

  type GetFollowGroupByPayload<T extends FollowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowGroupByOutputType[P]>
            : GetScalarType<T[P], FollowGroupByOutputType[P]>
        }
      >
    >


  export type FollowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followeeId?: boolean
    createdAt?: boolean
    follower?: boolean | ProfileDefaultArgs<ExtArgs>
    followee?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followeeId?: boolean
    createdAt?: boolean
    follower?: boolean | ProfileDefaultArgs<ExtArgs>
    followee?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    followerId?: boolean
    followeeId?: boolean
    createdAt?: boolean
    follower?: boolean | ProfileDefaultArgs<ExtArgs>
    followee?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["follow"]>

  export type FollowSelectScalar = {
    id?: boolean
    followerId?: boolean
    followeeId?: boolean
    createdAt?: boolean
  }

  export type FollowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "followerId" | "followeeId" | "createdAt", ExtArgs["result"]["follow"]>
  export type FollowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | ProfileDefaultArgs<ExtArgs>
    followee?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type FollowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | ProfileDefaultArgs<ExtArgs>
    followee?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type FollowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    follower?: boolean | ProfileDefaultArgs<ExtArgs>
    followee?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $FollowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Follow"
    objects: {
      follower: Prisma.$ProfilePayload<ExtArgs>
      followee: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      followerId: string
      followeeId: string
      createdAt: Date
    }, ExtArgs["result"]["follow"]>
    composites: {}
  }

  type FollowGetPayload<S extends boolean | null | undefined | FollowDefaultArgs> = $Result.GetResult<Prisma.$FollowPayload, S>

  type FollowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FollowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowCountAggregateInputType | true
    }

  export interface FollowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Follow'], meta: { name: 'Follow' } }
    /**
     * Find zero or one Follow that matches the filter.
     * @param {FollowFindUniqueArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FollowFindUniqueArgs>(args: SelectSubset<T, FollowFindUniqueArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Follow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FollowFindUniqueOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FollowFindUniqueOrThrowArgs>(args: SelectSubset<T, FollowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FollowFindFirstArgs>(args?: SelectSubset<T, FollowFindFirstArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Follow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindFirstOrThrowArgs} args - Arguments to find a Follow
     * @example
     * // Get one Follow
     * const follow = await prisma.follow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FollowFindFirstOrThrowArgs>(args?: SelectSubset<T, FollowFindFirstOrThrowArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Follows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Follows
     * const follows = await prisma.follow.findMany()
     * 
     * // Get first 10 Follows
     * const follows = await prisma.follow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const followWithIdOnly = await prisma.follow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FollowFindManyArgs>(args?: SelectSubset<T, FollowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Follow.
     * @param {FollowCreateArgs} args - Arguments to create a Follow.
     * @example
     * // Create one Follow
     * const Follow = await prisma.follow.create({
     *   data: {
     *     // ... data to create a Follow
     *   }
     * })
     * 
     */
    create<T extends FollowCreateArgs>(args: SelectSubset<T, FollowCreateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Follows.
     * @param {FollowCreateManyArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FollowCreateManyArgs>(args?: SelectSubset<T, FollowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Follows and returns the data saved in the database.
     * @param {FollowCreateManyAndReturnArgs} args - Arguments to create many Follows.
     * @example
     * // Create many Follows
     * const follow = await prisma.follow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FollowCreateManyAndReturnArgs>(args?: SelectSubset<T, FollowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Follow.
     * @param {FollowDeleteArgs} args - Arguments to delete one Follow.
     * @example
     * // Delete one Follow
     * const Follow = await prisma.follow.delete({
     *   where: {
     *     // ... filter to delete one Follow
     *   }
     * })
     * 
     */
    delete<T extends FollowDeleteArgs>(args: SelectSubset<T, FollowDeleteArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Follow.
     * @param {FollowUpdateArgs} args - Arguments to update one Follow.
     * @example
     * // Update one Follow
     * const follow = await prisma.follow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FollowUpdateArgs>(args: SelectSubset<T, FollowUpdateArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Follows.
     * @param {FollowDeleteManyArgs} args - Arguments to filter Follows to delete.
     * @example
     * // Delete a few Follows
     * const { count } = await prisma.follow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FollowDeleteManyArgs>(args?: SelectSubset<T, FollowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FollowUpdateManyArgs>(args: SelectSubset<T, FollowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Follows and returns the data updated in the database.
     * @param {FollowUpdateManyAndReturnArgs} args - Arguments to update many Follows.
     * @example
     * // Update many Follows
     * const follow = await prisma.follow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Follows and only return the `id`
     * const followWithIdOnly = await prisma.follow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FollowUpdateManyAndReturnArgs>(args: SelectSubset<T, FollowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Follow.
     * @param {FollowUpsertArgs} args - Arguments to update or create a Follow.
     * @example
     * // Update or create a Follow
     * const follow = await prisma.follow.upsert({
     *   create: {
     *     // ... data to create a Follow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Follow we want to update
     *   }
     * })
     */
    upsert<T extends FollowUpsertArgs>(args: SelectSubset<T, FollowUpsertArgs<ExtArgs>>): Prisma__FollowClient<$Result.GetResult<Prisma.$FollowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Follows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowCountArgs} args - Arguments to filter Follows to count.
     * @example
     * // Count the number of Follows
     * const count = await prisma.follow.count({
     *   where: {
     *     // ... the filter for the Follows we want to count
     *   }
     * })
    **/
    count<T extends FollowCountArgs>(
      args?: Subset<T, FollowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowAggregateArgs>(args: Subset<T, FollowAggregateArgs>): Prisma.PrismaPromise<GetFollowAggregateType<T>>

    /**
     * Group by Follow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FollowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FollowGroupByArgs['orderBy'] }
        : { orderBy?: FollowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FollowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Follow model
   */
  readonly fields: FollowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Follow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FollowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    follower<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    followee<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Follow model
   */
  interface FollowFieldRefs {
    readonly id: FieldRef<"Follow", 'String'>
    readonly followerId: FieldRef<"Follow", 'String'>
    readonly followeeId: FieldRef<"Follow", 'String'>
    readonly createdAt: FieldRef<"Follow", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Follow findUnique
   */
  export type FollowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findUniqueOrThrow
   */
  export type FollowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow findFirst
   */
  export type FollowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findFirstOrThrow
   */
  export type FollowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follow to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Follows.
     */
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow findMany
   */
  export type FollowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter, which Follows to fetch.
     */
    where?: FollowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Follows to fetch.
     */
    orderBy?: FollowOrderByWithRelationInput | FollowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Follows.
     */
    cursor?: FollowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Follows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Follows.
     */
    skip?: number
    distinct?: FollowScalarFieldEnum | FollowScalarFieldEnum[]
  }

  /**
   * Follow create
   */
  export type FollowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to create a Follow.
     */
    data: XOR<FollowCreateInput, FollowUncheckedCreateInput>
  }

  /**
   * Follow createMany
   */
  export type FollowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Follow createManyAndReturn
   */
  export type FollowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to create many Follows.
     */
    data: FollowCreateManyInput | FollowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow update
   */
  export type FollowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The data needed to update a Follow.
     */
    data: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
    /**
     * Choose, which Follow to update.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow updateMany
   */
  export type FollowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
  }

  /**
   * Follow updateManyAndReturn
   */
  export type FollowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * The data used to update Follows.
     */
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyInput>
    /**
     * Filter which Follows to update
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Follow upsert
   */
  export type FollowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * The filter to search for the Follow to update in case it exists.
     */
    where: FollowWhereUniqueInput
    /**
     * In case the Follow found by the `where` argument doesn't exist, create a new Follow with this data.
     */
    create: XOR<FollowCreateInput, FollowUncheckedCreateInput>
    /**
     * In case the Follow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FollowUpdateInput, FollowUncheckedUpdateInput>
  }

  /**
   * Follow delete
   */
  export type FollowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
    /**
     * Filter which Follow to delete.
     */
    where: FollowWhereUniqueInput
  }

  /**
   * Follow deleteMany
   */
  export type FollowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Follows to delete
     */
    where?: FollowWhereInput
    /**
     * Limit how many Follows to delete.
     */
    limit?: number
  }

  /**
   * Follow without action
   */
  export type FollowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Follow
     */
    select?: FollowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Follow
     */
    omit?: FollowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FollowInclude<ExtArgs> | null
  }


  /**
   * Model Block
   */

  export type AggregateBlock = {
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  export type BlockMinAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedId: string | null
    createdAt: Date | null
  }

  export type BlockMaxAggregateOutputType = {
    id: string | null
    blockerId: string | null
    blockedId: string | null
    createdAt: Date | null
  }

  export type BlockCountAggregateOutputType = {
    id: number
    blockerId: number
    blockedId: number
    createdAt: number
    _all: number
  }


  export type BlockMinAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
  }

  export type BlockMaxAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
  }

  export type BlockCountAggregateInputType = {
    id?: true
    blockerId?: true
    blockedId?: true
    createdAt?: true
    _all?: true
  }

  export type BlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Block to aggregate.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Blocks
    **/
    _count?: true | BlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockMaxAggregateInputType
  }

  export type GetBlockAggregateType<T extends BlockAggregateArgs> = {
        [P in keyof T & keyof AggregateBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlock[P]>
      : GetScalarType<T[P], AggregateBlock[P]>
  }




  export type BlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockWhereInput
    orderBy?: BlockOrderByWithAggregationInput | BlockOrderByWithAggregationInput[]
    by: BlockScalarFieldEnum[] | BlockScalarFieldEnum
    having?: BlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockCountAggregateInputType | true
    _min?: BlockMinAggregateInputType
    _max?: BlockMaxAggregateInputType
  }

  export type BlockGroupByOutputType = {
    id: string
    blockerId: string
    blockedId: string
    createdAt: Date
    _count: BlockCountAggregateOutputType | null
    _min: BlockMinAggregateOutputType | null
    _max: BlockMaxAggregateOutputType | null
  }

  type GetBlockGroupByPayload<T extends BlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockGroupByOutputType[P]>
            : GetScalarType<T[P], BlockGroupByOutputType[P]>
        }
      >
    >


  export type BlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["block"]>

  export type BlockSelectScalar = {
    id?: boolean
    blockerId?: boolean
    blockedId?: boolean
    createdAt?: boolean
  }

  export type BlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "blockerId" | "blockedId" | "createdAt", ExtArgs["result"]["block"]>
  export type BlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type BlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type BlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blocker?: boolean | ProfileDefaultArgs<ExtArgs>
    blocked?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $BlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Block"
    objects: {
      blocker: Prisma.$ProfilePayload<ExtArgs>
      blocked: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      blockerId: string
      blockedId: string
      createdAt: Date
    }, ExtArgs["result"]["block"]>
    composites: {}
  }

  type BlockGetPayload<S extends boolean | null | undefined | BlockDefaultArgs> = $Result.GetResult<Prisma.$BlockPayload, S>

  type BlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockCountAggregateInputType | true
    }

  export interface BlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Block'], meta: { name: 'Block' } }
    /**
     * Find zero or one Block that matches the filter.
     * @param {BlockFindUniqueArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockFindUniqueArgs>(args: SelectSubset<T, BlockFindUniqueArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Block that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockFindUniqueOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockFindFirstArgs>(args?: SelectSubset<T, BlockFindFirstArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Block that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindFirstOrThrowArgs} args - Arguments to find a Block
     * @example
     * // Get one Block
     * const block = await prisma.block.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blocks
     * const blocks = await prisma.block.findMany()
     * 
     * // Get first 10 Blocks
     * const blocks = await prisma.block.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blockWithIdOnly = await prisma.block.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlockFindManyArgs>(args?: SelectSubset<T, BlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Block.
     * @param {BlockCreateArgs} args - Arguments to create a Block.
     * @example
     * // Create one Block
     * const Block = await prisma.block.create({
     *   data: {
     *     // ... data to create a Block
     *   }
     * })
     * 
     */
    create<T extends BlockCreateArgs>(args: SelectSubset<T, BlockCreateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blocks.
     * @param {BlockCreateManyArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockCreateManyArgs>(args?: SelectSubset<T, BlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blocks and returns the data saved in the database.
     * @param {BlockCreateManyAndReturnArgs} args - Arguments to create many Blocks.
     * @example
     * // Create many Blocks
     * const block = await prisma.block.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Block.
     * @param {BlockDeleteArgs} args - Arguments to delete one Block.
     * @example
     * // Delete one Block
     * const Block = await prisma.block.delete({
     *   where: {
     *     // ... filter to delete one Block
     *   }
     * })
     * 
     */
    delete<T extends BlockDeleteArgs>(args: SelectSubset<T, BlockDeleteArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Block.
     * @param {BlockUpdateArgs} args - Arguments to update one Block.
     * @example
     * // Update one Block
     * const block = await prisma.block.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockUpdateArgs>(args: SelectSubset<T, BlockUpdateArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blocks.
     * @param {BlockDeleteManyArgs} args - Arguments to filter Blocks to delete.
     * @example
     * // Delete a few Blocks
     * const { count } = await prisma.block.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockDeleteManyArgs>(args?: SelectSubset<T, BlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockUpdateManyArgs>(args: SelectSubset<T, BlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blocks and returns the data updated in the database.
     * @param {BlockUpdateManyAndReturnArgs} args - Arguments to update many Blocks.
     * @example
     * // Update many Blocks
     * const block = await prisma.block.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blocks and only return the `id`
     * const blockWithIdOnly = await prisma.block.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Block.
     * @param {BlockUpsertArgs} args - Arguments to update or create a Block.
     * @example
     * // Update or create a Block
     * const block = await prisma.block.upsert({
     *   create: {
     *     // ... data to create a Block
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Block we want to update
     *   }
     * })
     */
    upsert<T extends BlockUpsertArgs>(args: SelectSubset<T, BlockUpsertArgs<ExtArgs>>): Prisma__BlockClient<$Result.GetResult<Prisma.$BlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockCountArgs} args - Arguments to filter Blocks to count.
     * @example
     * // Count the number of Blocks
     * const count = await prisma.block.count({
     *   where: {
     *     // ... the filter for the Blocks we want to count
     *   }
     * })
    **/
    count<T extends BlockCountArgs>(
      args?: Subset<T, BlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockAggregateArgs>(args: Subset<T, BlockAggregateArgs>): Prisma.PrismaPromise<GetBlockAggregateType<T>>

    /**
     * Group by Block.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockGroupByArgs['orderBy'] }
        : { orderBy?: BlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Block model
   */
  readonly fields: BlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Block.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blocker<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blocked<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Block model
   */
  interface BlockFieldRefs {
    readonly id: FieldRef<"Block", 'String'>
    readonly blockerId: FieldRef<"Block", 'String'>
    readonly blockedId: FieldRef<"Block", 'String'>
    readonly createdAt: FieldRef<"Block", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Block findUnique
   */
  export type BlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findUniqueOrThrow
   */
  export type BlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block findFirst
   */
  export type BlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findFirstOrThrow
   */
  export type BlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Block to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Blocks.
     */
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block findMany
   */
  export type BlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter, which Blocks to fetch.
     */
    where?: BlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Blocks to fetch.
     */
    orderBy?: BlockOrderByWithRelationInput | BlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Blocks.
     */
    cursor?: BlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Blocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Blocks.
     */
    skip?: number
    distinct?: BlockScalarFieldEnum | BlockScalarFieldEnum[]
  }

  /**
   * Block create
   */
  export type BlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to create a Block.
     */
    data: XOR<BlockCreateInput, BlockUncheckedCreateInput>
  }

  /**
   * Block createMany
   */
  export type BlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Block createManyAndReturn
   */
  export type BlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to create many Blocks.
     */
    data: BlockCreateManyInput | BlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block update
   */
  export type BlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The data needed to update a Block.
     */
    data: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
    /**
     * Choose, which Block to update.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block updateMany
   */
  export type BlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
  }

  /**
   * Block updateManyAndReturn
   */
  export type BlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * The data used to update Blocks.
     */
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyInput>
    /**
     * Filter which Blocks to update
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Block upsert
   */
  export type BlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * The filter to search for the Block to update in case it exists.
     */
    where: BlockWhereUniqueInput
    /**
     * In case the Block found by the `where` argument doesn't exist, create a new Block with this data.
     */
    create: XOR<BlockCreateInput, BlockUncheckedCreateInput>
    /**
     * In case the Block was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockUpdateInput, BlockUncheckedUpdateInput>
  }

  /**
   * Block delete
   */
  export type BlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
    /**
     * Filter which Block to delete.
     */
    where: BlockWhereUniqueInput
  }

  /**
   * Block deleteMany
   */
  export type BlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Blocks to delete
     */
    where?: BlockWhereInput
    /**
     * Limit how many Blocks to delete.
     */
    limit?: number
  }

  /**
   * Block without action
   */
  export type BlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Block
     */
    select?: BlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Block
     */
    omit?: BlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockInclude<ExtArgs> | null
  }


  /**
   * Model Mute
   */

  export type AggregateMute = {
    _count: MuteCountAggregateOutputType | null
    _min: MuteMinAggregateOutputType | null
    _max: MuteMaxAggregateOutputType | null
  }

  export type MuteMinAggregateOutputType = {
    id: string | null
    muterId: string | null
    mutedId: string | null
    createdAt: Date | null
  }

  export type MuteMaxAggregateOutputType = {
    id: string | null
    muterId: string | null
    mutedId: string | null
    createdAt: Date | null
  }

  export type MuteCountAggregateOutputType = {
    id: number
    muterId: number
    mutedId: number
    createdAt: number
    _all: number
  }


  export type MuteMinAggregateInputType = {
    id?: true
    muterId?: true
    mutedId?: true
    createdAt?: true
  }

  export type MuteMaxAggregateInputType = {
    id?: true
    muterId?: true
    mutedId?: true
    createdAt?: true
  }

  export type MuteCountAggregateInputType = {
    id?: true
    muterId?: true
    mutedId?: true
    createdAt?: true
    _all?: true
  }

  export type MuteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mute to aggregate.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mutes
    **/
    _count?: true | MuteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MuteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MuteMaxAggregateInputType
  }

  export type GetMuteAggregateType<T extends MuteAggregateArgs> = {
        [P in keyof T & keyof AggregateMute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMute[P]>
      : GetScalarType<T[P], AggregateMute[P]>
  }




  export type MuteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MuteWhereInput
    orderBy?: MuteOrderByWithAggregationInput | MuteOrderByWithAggregationInput[]
    by: MuteScalarFieldEnum[] | MuteScalarFieldEnum
    having?: MuteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MuteCountAggregateInputType | true
    _min?: MuteMinAggregateInputType
    _max?: MuteMaxAggregateInputType
  }

  export type MuteGroupByOutputType = {
    id: string
    muterId: string
    mutedId: string
    createdAt: Date
    _count: MuteCountAggregateOutputType | null
    _min: MuteMinAggregateOutputType | null
    _max: MuteMaxAggregateOutputType | null
  }

  type GetMuteGroupByPayload<T extends MuteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MuteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MuteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MuteGroupByOutputType[P]>
            : GetScalarType<T[P], MuteGroupByOutputType[P]>
        }
      >
    >


  export type MuteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    muterId?: boolean
    mutedId?: boolean
    createdAt?: boolean
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mute"]>

  export type MuteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    muterId?: boolean
    mutedId?: boolean
    createdAt?: boolean
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mute"]>

  export type MuteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    muterId?: boolean
    mutedId?: boolean
    createdAt?: boolean
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mute"]>

  export type MuteSelectScalar = {
    id?: boolean
    muterId?: boolean
    mutedId?: boolean
    createdAt?: boolean
  }

  export type MuteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "muterId" | "mutedId" | "createdAt", ExtArgs["result"]["mute"]>
  export type MuteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MuteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MuteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    muter?: boolean | ProfileDefaultArgs<ExtArgs>
    muted?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $MutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mute"
    objects: {
      muter: Prisma.$ProfilePayload<ExtArgs>
      muted: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      muterId: string
      mutedId: string
      createdAt: Date
    }, ExtArgs["result"]["mute"]>
    composites: {}
  }

  type MuteGetPayload<S extends boolean | null | undefined | MuteDefaultArgs> = $Result.GetResult<Prisma.$MutePayload, S>

  type MuteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MuteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MuteCountAggregateInputType | true
    }

  export interface MuteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mute'], meta: { name: 'Mute' } }
    /**
     * Find zero or one Mute that matches the filter.
     * @param {MuteFindUniqueArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MuteFindUniqueArgs>(args: SelectSubset<T, MuteFindUniqueArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Mute that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MuteFindUniqueOrThrowArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MuteFindUniqueOrThrowArgs>(args: SelectSubset<T, MuteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteFindFirstArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MuteFindFirstArgs>(args?: SelectSubset<T, MuteFindFirstArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Mute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteFindFirstOrThrowArgs} args - Arguments to find a Mute
     * @example
     * // Get one Mute
     * const mute = await prisma.mute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MuteFindFirstOrThrowArgs>(args?: SelectSubset<T, MuteFindFirstOrThrowArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Mutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mutes
     * const mutes = await prisma.mute.findMany()
     * 
     * // Get first 10 Mutes
     * const mutes = await prisma.mute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const muteWithIdOnly = await prisma.mute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MuteFindManyArgs>(args?: SelectSubset<T, MuteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Mute.
     * @param {MuteCreateArgs} args - Arguments to create a Mute.
     * @example
     * // Create one Mute
     * const Mute = await prisma.mute.create({
     *   data: {
     *     // ... data to create a Mute
     *   }
     * })
     * 
     */
    create<T extends MuteCreateArgs>(args: SelectSubset<T, MuteCreateArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Mutes.
     * @param {MuteCreateManyArgs} args - Arguments to create many Mutes.
     * @example
     * // Create many Mutes
     * const mute = await prisma.mute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MuteCreateManyArgs>(args?: SelectSubset<T, MuteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mutes and returns the data saved in the database.
     * @param {MuteCreateManyAndReturnArgs} args - Arguments to create many Mutes.
     * @example
     * // Create many Mutes
     * const mute = await prisma.mute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mutes and only return the `id`
     * const muteWithIdOnly = await prisma.mute.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MuteCreateManyAndReturnArgs>(args?: SelectSubset<T, MuteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Mute.
     * @param {MuteDeleteArgs} args - Arguments to delete one Mute.
     * @example
     * // Delete one Mute
     * const Mute = await prisma.mute.delete({
     *   where: {
     *     // ... filter to delete one Mute
     *   }
     * })
     * 
     */
    delete<T extends MuteDeleteArgs>(args: SelectSubset<T, MuteDeleteArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Mute.
     * @param {MuteUpdateArgs} args - Arguments to update one Mute.
     * @example
     * // Update one Mute
     * const mute = await prisma.mute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MuteUpdateArgs>(args: SelectSubset<T, MuteUpdateArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Mutes.
     * @param {MuteDeleteManyArgs} args - Arguments to filter Mutes to delete.
     * @example
     * // Delete a few Mutes
     * const { count } = await prisma.mute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MuteDeleteManyArgs>(args?: SelectSubset<T, MuteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mutes
     * const mute = await prisma.mute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MuteUpdateManyArgs>(args: SelectSubset<T, MuteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mutes and returns the data updated in the database.
     * @param {MuteUpdateManyAndReturnArgs} args - Arguments to update many Mutes.
     * @example
     * // Update many Mutes
     * const mute = await prisma.mute.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Mutes and only return the `id`
     * const muteWithIdOnly = await prisma.mute.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MuteUpdateManyAndReturnArgs>(args: SelectSubset<T, MuteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Mute.
     * @param {MuteUpsertArgs} args - Arguments to update or create a Mute.
     * @example
     * // Update or create a Mute
     * const mute = await prisma.mute.upsert({
     *   create: {
     *     // ... data to create a Mute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mute we want to update
     *   }
     * })
     */
    upsert<T extends MuteUpsertArgs>(args: SelectSubset<T, MuteUpsertArgs<ExtArgs>>): Prisma__MuteClient<$Result.GetResult<Prisma.$MutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Mutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteCountArgs} args - Arguments to filter Mutes to count.
     * @example
     * // Count the number of Mutes
     * const count = await prisma.mute.count({
     *   where: {
     *     // ... the filter for the Mutes we want to count
     *   }
     * })
    **/
    count<T extends MuteCountArgs>(
      args?: Subset<T, MuteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MuteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MuteAggregateArgs>(args: Subset<T, MuteAggregateArgs>): Prisma.PrismaPromise<GetMuteAggregateType<T>>

    /**
     * Group by Mute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MuteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MuteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MuteGroupByArgs['orderBy'] }
        : { orderBy?: MuteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MuteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMuteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mute model
   */
  readonly fields: MuteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MuteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    muter<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    muted<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mute model
   */
  interface MuteFieldRefs {
    readonly id: FieldRef<"Mute", 'String'>
    readonly muterId: FieldRef<"Mute", 'String'>
    readonly mutedId: FieldRef<"Mute", 'String'>
    readonly createdAt: FieldRef<"Mute", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mute findUnique
   */
  export type MuteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute findUniqueOrThrow
   */
  export type MuteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute findFirst
   */
  export type MuteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mutes.
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mutes.
     */
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Mute findFirstOrThrow
   */
  export type MuteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mute to fetch.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mutes.
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mutes.
     */
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Mute findMany
   */
  export type MuteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter, which Mutes to fetch.
     */
    where?: MuteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutes to fetch.
     */
    orderBy?: MuteOrderByWithRelationInput | MuteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mutes.
     */
    cursor?: MuteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutes.
     */
    skip?: number
    distinct?: MuteScalarFieldEnum | MuteScalarFieldEnum[]
  }

  /**
   * Mute create
   */
  export type MuteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * The data needed to create a Mute.
     */
    data: XOR<MuteCreateInput, MuteUncheckedCreateInput>
  }

  /**
   * Mute createMany
   */
  export type MuteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mutes.
     */
    data: MuteCreateManyInput | MuteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Mute createManyAndReturn
   */
  export type MuteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * The data used to create many Mutes.
     */
    data: MuteCreateManyInput | MuteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mute update
   */
  export type MuteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * The data needed to update a Mute.
     */
    data: XOR<MuteUpdateInput, MuteUncheckedUpdateInput>
    /**
     * Choose, which Mute to update.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute updateMany
   */
  export type MuteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mutes.
     */
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyInput>
    /**
     * Filter which Mutes to update
     */
    where?: MuteWhereInput
    /**
     * Limit how many Mutes to update.
     */
    limit?: number
  }

  /**
   * Mute updateManyAndReturn
   */
  export type MuteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * The data used to update Mutes.
     */
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyInput>
    /**
     * Filter which Mutes to update
     */
    where?: MuteWhereInput
    /**
     * Limit how many Mutes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mute upsert
   */
  export type MuteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * The filter to search for the Mute to update in case it exists.
     */
    where: MuteWhereUniqueInput
    /**
     * In case the Mute found by the `where` argument doesn't exist, create a new Mute with this data.
     */
    create: XOR<MuteCreateInput, MuteUncheckedCreateInput>
    /**
     * In case the Mute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MuteUpdateInput, MuteUncheckedUpdateInput>
  }

  /**
   * Mute delete
   */
  export type MuteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
    /**
     * Filter which Mute to delete.
     */
    where: MuteWhereUniqueInput
  }

  /**
   * Mute deleteMany
   */
  export type MuteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mutes to delete
     */
    where?: MuteWhereInput
    /**
     * Limit how many Mutes to delete.
     */
    limit?: number
  }

  /**
   * Mute without action
   */
  export type MuteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mute
     */
    select?: MuteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Mute
     */
    omit?: MuteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MuteInclude<ExtArgs> | null
  }


  /**
   * Model Post
   */

  export type AggregatePost = {
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  export type PostAvgAggregateOutputType = {
    commentCount: number | null
    likeCount: number | null
    shareCount: number | null
  }

  export type PostSumAggregateOutputType = {
    commentCount: number | null
    likeCount: number | null
    shareCount: number | null
  }

  export type PostMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    content: string | null
    visibility: $Enums.PostVisibility | null
    locationText: string | null
    lineageId: string | null
    commentCount: number | null
    likeCount: number | null
    shareCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    content: string | null
    visibility: $Enums.PostVisibility | null
    locationText: string | null
    lineageId: string | null
    commentCount: number | null
    likeCount: number | null
    shareCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PostCountAggregateOutputType = {
    id: number
    profileId: number
    content: number
    visibility: number
    locationText: number
    lineageId: number
    commentCount: number
    likeCount: number
    shareCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PostAvgAggregateInputType = {
    commentCount?: true
    likeCount?: true
    shareCount?: true
  }

  export type PostSumAggregateInputType = {
    commentCount?: true
    likeCount?: true
    shareCount?: true
  }

  export type PostMinAggregateInputType = {
    id?: true
    profileId?: true
    content?: true
    visibility?: true
    locationText?: true
    lineageId?: true
    commentCount?: true
    likeCount?: true
    shareCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostMaxAggregateInputType = {
    id?: true
    profileId?: true
    content?: true
    visibility?: true
    locationText?: true
    lineageId?: true
    commentCount?: true
    likeCount?: true
    shareCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PostCountAggregateInputType = {
    id?: true
    profileId?: true
    content?: true
    visibility?: true
    locationText?: true
    lineageId?: true
    commentCount?: true
    likeCount?: true
    shareCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Post to aggregate.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Posts
    **/
    _count?: true | PostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostMaxAggregateInputType
  }

  export type GetPostAggregateType<T extends PostAggregateArgs> = {
        [P in keyof T & keyof AggregatePost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePost[P]>
      : GetScalarType<T[P], AggregatePost[P]>
  }




  export type PostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostWhereInput
    orderBy?: PostOrderByWithAggregationInput | PostOrderByWithAggregationInput[]
    by: PostScalarFieldEnum[] | PostScalarFieldEnum
    having?: PostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostCountAggregateInputType | true
    _avg?: PostAvgAggregateInputType
    _sum?: PostSumAggregateInputType
    _min?: PostMinAggregateInputType
    _max?: PostMaxAggregateInputType
  }

  export type PostGroupByOutputType = {
    id: string
    profileId: string
    content: string | null
    visibility: $Enums.PostVisibility
    locationText: string | null
    lineageId: string | null
    commentCount: number
    likeCount: number
    shareCount: number
    createdAt: Date
    updatedAt: Date
    _count: PostCountAggregateOutputType | null
    _avg: PostAvgAggregateOutputType | null
    _sum: PostSumAggregateOutputType | null
    _min: PostMinAggregateOutputType | null
    _max: PostMaxAggregateOutputType | null
  }

  type GetPostGroupByPayload<T extends PostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostGroupByOutputType[P]>
            : GetScalarType<T[P], PostGroupByOutputType[P]>
        }
      >
    >


  export type PostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    content?: boolean
    visibility?: boolean
    locationText?: boolean
    lineageId?: boolean
    commentCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    lineage?: boolean | Post$lineageArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    mediaFiles?: boolean | Post$mediaFilesArgs<ExtArgs>
    notifications?: boolean | Post$notificationsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    content?: boolean
    visibility?: boolean
    locationText?: boolean
    lineageId?: boolean
    commentCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    lineage?: boolean | Post$lineageArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    content?: boolean
    visibility?: boolean
    locationText?: boolean
    lineageId?: boolean
    commentCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    lineage?: boolean | Post$lineageArgs<ExtArgs>
  }, ExtArgs["result"]["post"]>

  export type PostSelectScalar = {
    id?: boolean
    profileId?: boolean
    content?: boolean
    visibility?: boolean
    locationText?: boolean
    lineageId?: boolean
    commentCount?: boolean
    likeCount?: boolean
    shareCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "content" | "visibility" | "locationText" | "lineageId" | "commentCount" | "likeCount" | "shareCount" | "createdAt" | "updatedAt", ExtArgs["result"]["post"]>
  export type PostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    lineage?: boolean | Post$lineageArgs<ExtArgs>
    comments?: boolean | Post$commentsArgs<ExtArgs>
    reactions?: boolean | Post$reactionsArgs<ExtArgs>
    mediaFiles?: boolean | Post$mediaFilesArgs<ExtArgs>
    notifications?: boolean | Post$notificationsArgs<ExtArgs>
    _count?: boolean | PostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    lineage?: boolean | Post$lineageArgs<ExtArgs>
  }
  export type PostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    lineage?: boolean | Post$lineageArgs<ExtArgs>
  }

  export type $PostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Post"
    objects: {
      author: Prisma.$ProfilePayload<ExtArgs>
      lineage: Prisma.$LineagePayload<ExtArgs> | null
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reactions: Prisma.$PostReactionPayload<ExtArgs>[]
      mediaFiles: Prisma.$MediaFilePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string
      content: string | null
      visibility: $Enums.PostVisibility
      locationText: string | null
      lineageId: string | null
      commentCount: number
      likeCount: number
      shareCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["post"]>
    composites: {}
  }

  type PostGetPayload<S extends boolean | null | undefined | PostDefaultArgs> = $Result.GetResult<Prisma.$PostPayload, S>

  type PostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostCountAggregateInputType | true
    }

  export interface PostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Post'], meta: { name: 'Post' } }
    /**
     * Find zero or one Post that matches the filter.
     * @param {PostFindUniqueArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostFindUniqueArgs>(args: SelectSubset<T, PostFindUniqueArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Post that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostFindUniqueOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostFindUniqueOrThrowArgs>(args: SelectSubset<T, PostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostFindFirstArgs>(args?: SelectSubset<T, PostFindFirstArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Post that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindFirstOrThrowArgs} args - Arguments to find a Post
     * @example
     * // Get one Post
     * const post = await prisma.post.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostFindFirstOrThrowArgs>(args?: SelectSubset<T, PostFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Posts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Posts
     * const posts = await prisma.post.findMany()
     * 
     * // Get first 10 Posts
     * const posts = await prisma.post.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postWithIdOnly = await prisma.post.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostFindManyArgs>(args?: SelectSubset<T, PostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Post.
     * @param {PostCreateArgs} args - Arguments to create a Post.
     * @example
     * // Create one Post
     * const Post = await prisma.post.create({
     *   data: {
     *     // ... data to create a Post
     *   }
     * })
     * 
     */
    create<T extends PostCreateArgs>(args: SelectSubset<T, PostCreateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Posts.
     * @param {PostCreateManyArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostCreateManyArgs>(args?: SelectSubset<T, PostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Posts and returns the data saved in the database.
     * @param {PostCreateManyAndReturnArgs} args - Arguments to create many Posts.
     * @example
     * // Create many Posts
     * const post = await prisma.post.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostCreateManyAndReturnArgs>(args?: SelectSubset<T, PostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Post.
     * @param {PostDeleteArgs} args - Arguments to delete one Post.
     * @example
     * // Delete one Post
     * const Post = await prisma.post.delete({
     *   where: {
     *     // ... filter to delete one Post
     *   }
     * })
     * 
     */
    delete<T extends PostDeleteArgs>(args: SelectSubset<T, PostDeleteArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Post.
     * @param {PostUpdateArgs} args - Arguments to update one Post.
     * @example
     * // Update one Post
     * const post = await prisma.post.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpdateArgs>(args: SelectSubset<T, PostUpdateArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Posts.
     * @param {PostDeleteManyArgs} args - Arguments to filter Posts to delete.
     * @example
     * // Delete a few Posts
     * const { count } = await prisma.post.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostDeleteManyArgs>(args?: SelectSubset<T, PostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpdateManyArgs>(args: SelectSubset<T, PostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Posts and returns the data updated in the database.
     * @param {PostUpdateManyAndReturnArgs} args - Arguments to update many Posts.
     * @example
     * // Update many Posts
     * const post = await prisma.post.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Posts and only return the `id`
     * const postWithIdOnly = await prisma.post.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostUpdateManyAndReturnArgs>(args: SelectSubset<T, PostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Post.
     * @param {PostUpsertArgs} args - Arguments to update or create a Post.
     * @example
     * // Update or create a Post
     * const post = await prisma.post.upsert({
     *   create: {
     *     // ... data to create a Post
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Post we want to update
     *   }
     * })
     */
    upsert<T extends PostUpsertArgs>(args: SelectSubset<T, PostUpsertArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Posts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostCountArgs} args - Arguments to filter Posts to count.
     * @example
     * // Count the number of Posts
     * const count = await prisma.post.count({
     *   where: {
     *     // ... the filter for the Posts we want to count
     *   }
     * })
    **/
    count<T extends PostCountArgs>(
      args?: Subset<T, PostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostAggregateArgs>(args: Subset<T, PostAggregateArgs>): Prisma.PrismaPromise<GetPostAggregateType<T>>

    /**
     * Group by Post.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostGroupByArgs['orderBy'] }
        : { orderBy?: PostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Post model
   */
  readonly fields: PostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Post.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lineage<T extends Post$lineageArgs<ExtArgs> = {}>(args?: Subset<T, Post$lineageArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends Post$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Post$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reactions<T extends Post$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Post$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mediaFiles<T extends Post$mediaFilesArgs<ExtArgs> = {}>(args?: Subset<T, Post$mediaFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Post$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Post$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Post model
   */
  interface PostFieldRefs {
    readonly id: FieldRef<"Post", 'String'>
    readonly profileId: FieldRef<"Post", 'String'>
    readonly content: FieldRef<"Post", 'String'>
    readonly visibility: FieldRef<"Post", 'PostVisibility'>
    readonly locationText: FieldRef<"Post", 'String'>
    readonly lineageId: FieldRef<"Post", 'String'>
    readonly commentCount: FieldRef<"Post", 'Int'>
    readonly likeCount: FieldRef<"Post", 'Int'>
    readonly shareCount: FieldRef<"Post", 'Int'>
    readonly createdAt: FieldRef<"Post", 'DateTime'>
    readonly updatedAt: FieldRef<"Post", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Post findUnique
   */
  export type PostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findUniqueOrThrow
   */
  export type PostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post findFirst
   */
  export type PostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findFirstOrThrow
   */
  export type PostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Post to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Posts.
     */
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post findMany
   */
  export type PostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter, which Posts to fetch.
     */
    where?: PostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Posts to fetch.
     */
    orderBy?: PostOrderByWithRelationInput | PostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Posts.
     */
    cursor?: PostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Posts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Posts.
     */
    skip?: number
    distinct?: PostScalarFieldEnum | PostScalarFieldEnum[]
  }

  /**
   * Post create
   */
  export type PostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to create a Post.
     */
    data: XOR<PostCreateInput, PostUncheckedCreateInput>
  }

  /**
   * Post createMany
   */
  export type PostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Post createManyAndReturn
   */
  export type PostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to create many Posts.
     */
    data: PostCreateManyInput | PostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post update
   */
  export type PostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The data needed to update a Post.
     */
    data: XOR<PostUpdateInput, PostUncheckedUpdateInput>
    /**
     * Choose, which Post to update.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post updateMany
   */
  export type PostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
  }

  /**
   * Post updateManyAndReturn
   */
  export type PostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * The data used to update Posts.
     */
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyInput>
    /**
     * Filter which Posts to update
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Post upsert
   */
  export type PostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * The filter to search for the Post to update in case it exists.
     */
    where: PostWhereUniqueInput
    /**
     * In case the Post found by the `where` argument doesn't exist, create a new Post with this data.
     */
    create: XOR<PostCreateInput, PostUncheckedCreateInput>
    /**
     * In case the Post was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpdateInput, PostUncheckedUpdateInput>
  }

  /**
   * Post delete
   */
  export type PostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    /**
     * Filter which Post to delete.
     */
    where: PostWhereUniqueInput
  }

  /**
   * Post deleteMany
   */
  export type PostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Posts to delete
     */
    where?: PostWhereInput
    /**
     * Limit how many Posts to delete.
     */
    limit?: number
  }

  /**
   * Post.lineage
   */
  export type Post$lineageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    where?: LineageWhereInput
  }

  /**
   * Post.comments
   */
  export type Post$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Post.reactions
   */
  export type Post$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    where?: PostReactionWhereInput
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    cursor?: PostReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * Post.mediaFiles
   */
  export type Post$mediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    where?: MediaFileWhereInput
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    cursor?: MediaFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * Post.notifications
   */
  export type Post$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Post without action
   */
  export type PostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
  }


  /**
   * Model MediaFile
   */

  export type AggregateMediaFile = {
    _count: MediaFileCountAggregateOutputType | null
    _avg: MediaFileAvgAggregateOutputType | null
    _sum: MediaFileSumAggregateOutputType | null
    _min: MediaFileMinAggregateOutputType | null
    _max: MediaFileMaxAggregateOutputType | null
  }

  export type MediaFileAvgAggregateOutputType = {
    width: number | null
    height: number | null
    sizeBytes: number | null
  }

  export type MediaFileSumAggregateOutputType = {
    width: number | null
    height: number | null
    sizeBytes: bigint | null
  }

  export type MediaFileMinAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.MediaType | null
    url: string | null
    mimeType: string | null
    width: number | null
    height: number | null
    sizeBytes: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaFileMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    type: $Enums.MediaType | null
    url: string | null
    mimeType: string | null
    width: number | null
    height: number | null
    sizeBytes: bigint | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaFileCountAggregateOutputType = {
    id: number
    postId: number
    type: number
    url: number
    mimeType: number
    width: number
    height: number
    sizeBytes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaFileAvgAggregateInputType = {
    width?: true
    height?: true
    sizeBytes?: true
  }

  export type MediaFileSumAggregateInputType = {
    width?: true
    height?: true
    sizeBytes?: true
  }

  export type MediaFileMinAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    url?: true
    mimeType?: true
    width?: true
    height?: true
    sizeBytes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaFileMaxAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    url?: true
    mimeType?: true
    width?: true
    height?: true
    sizeBytes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaFileCountAggregateInputType = {
    id?: true
    postId?: true
    type?: true
    url?: true
    mimeType?: true
    width?: true
    height?: true
    sizeBytes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFile to aggregate.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaFiles
    **/
    _count?: true | MediaFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaFileMaxAggregateInputType
  }

  export type GetMediaFileAggregateType<T extends MediaFileAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaFile[P]>
      : GetScalarType<T[P], AggregateMediaFile[P]>
  }




  export type MediaFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFileWhereInput
    orderBy?: MediaFileOrderByWithAggregationInput | MediaFileOrderByWithAggregationInput[]
    by: MediaFileScalarFieldEnum[] | MediaFileScalarFieldEnum
    having?: MediaFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaFileCountAggregateInputType | true
    _avg?: MediaFileAvgAggregateInputType
    _sum?: MediaFileSumAggregateInputType
    _min?: MediaFileMinAggregateInputType
    _max?: MediaFileMaxAggregateInputType
  }

  export type MediaFileGroupByOutputType = {
    id: string
    postId: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width: number | null
    height: number | null
    sizeBytes: bigint
    createdAt: Date
    updatedAt: Date
    _count: MediaFileCountAggregateOutputType | null
    _avg: MediaFileAvgAggregateOutputType | null
    _sum: MediaFileSumAggregateOutputType | null
    _min: MediaFileMinAggregateOutputType | null
    _max: MediaFileMaxAggregateOutputType | null
  }

  type GetMediaFileGroupByPayload<T extends MediaFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaFileGroupByOutputType[P]>
            : GetScalarType<T[P], MediaFileGroupByOutputType[P]>
        }
      >
    >


  export type MediaFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectScalar = {
    id?: boolean
    postId?: boolean
    type?: boolean
    url?: boolean
    mimeType?: boolean
    width?: boolean
    height?: boolean
    sizeBytes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "type" | "url" | "mimeType" | "width" | "height" | "sizeBytes" | "createdAt" | "updatedAt", ExtArgs["result"]["mediaFile"]>
  export type MediaFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type MediaFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }
  export type MediaFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
  }

  export type $MediaFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaFile"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      type: $Enums.MediaType
      url: string
      mimeType: string
      width: number | null
      height: number | null
      sizeBytes: bigint
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["mediaFile"]>
    composites: {}
  }

  type MediaFileGetPayload<S extends boolean | null | undefined | MediaFileDefaultArgs> = $Result.GetResult<Prisma.$MediaFilePayload, S>

  type MediaFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaFileCountAggregateInputType | true
    }

  export interface MediaFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaFile'], meta: { name: 'MediaFile' } }
    /**
     * Find zero or one MediaFile that matches the filter.
     * @param {MediaFileFindUniqueArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFileFindUniqueArgs>(args: SelectSubset<T, MediaFileFindUniqueArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFileFindUniqueOrThrowArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFileFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindFirstArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFileFindFirstArgs>(args?: SelectSubset<T, MediaFileFindFirstArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindFirstOrThrowArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFileFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaFiles
     * const mediaFiles = await prisma.mediaFile.findMany()
     * 
     * // Get first 10 MediaFiles
     * const mediaFiles = await prisma.mediaFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFileFindManyArgs>(args?: SelectSubset<T, MediaFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaFile.
     * @param {MediaFileCreateArgs} args - Arguments to create a MediaFile.
     * @example
     * // Create one MediaFile
     * const MediaFile = await prisma.mediaFile.create({
     *   data: {
     *     // ... data to create a MediaFile
     *   }
     * })
     * 
     */
    create<T extends MediaFileCreateArgs>(args: SelectSubset<T, MediaFileCreateArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaFiles.
     * @param {MediaFileCreateManyArgs} args - Arguments to create many MediaFiles.
     * @example
     * // Create many MediaFiles
     * const mediaFile = await prisma.mediaFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaFileCreateManyArgs>(args?: SelectSubset<T, MediaFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaFiles and returns the data saved in the database.
     * @param {MediaFileCreateManyAndReturnArgs} args - Arguments to create many MediaFiles.
     * @example
     * // Create many MediaFiles
     * const mediaFile = await prisma.mediaFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaFiles and only return the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaFileCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaFile.
     * @param {MediaFileDeleteArgs} args - Arguments to delete one MediaFile.
     * @example
     * // Delete one MediaFile
     * const MediaFile = await prisma.mediaFile.delete({
     *   where: {
     *     // ... filter to delete one MediaFile
     *   }
     * })
     * 
     */
    delete<T extends MediaFileDeleteArgs>(args: SelectSubset<T, MediaFileDeleteArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaFile.
     * @param {MediaFileUpdateArgs} args - Arguments to update one MediaFile.
     * @example
     * // Update one MediaFile
     * const mediaFile = await prisma.mediaFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaFileUpdateArgs>(args: SelectSubset<T, MediaFileUpdateArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaFiles.
     * @param {MediaFileDeleteManyArgs} args - Arguments to filter MediaFiles to delete.
     * @example
     * // Delete a few MediaFiles
     * const { count } = await prisma.mediaFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaFileDeleteManyArgs>(args?: SelectSubset<T, MediaFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaFiles
     * const mediaFile = await prisma.mediaFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaFileUpdateManyArgs>(args: SelectSubset<T, MediaFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaFiles and returns the data updated in the database.
     * @param {MediaFileUpdateManyAndReturnArgs} args - Arguments to update many MediaFiles.
     * @example
     * // Update many MediaFiles
     * const mediaFile = await prisma.mediaFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaFiles and only return the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaFileUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaFile.
     * @param {MediaFileUpsertArgs} args - Arguments to update or create a MediaFile.
     * @example
     * // Update or create a MediaFile
     * const mediaFile = await prisma.mediaFile.upsert({
     *   create: {
     *     // ... data to create a MediaFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaFile we want to update
     *   }
     * })
     */
    upsert<T extends MediaFileUpsertArgs>(args: SelectSubset<T, MediaFileUpsertArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileCountArgs} args - Arguments to filter MediaFiles to count.
     * @example
     * // Count the number of MediaFiles
     * const count = await prisma.mediaFile.count({
     *   where: {
     *     // ... the filter for the MediaFiles we want to count
     *   }
     * })
    **/
    count<T extends MediaFileCountArgs>(
      args?: Subset<T, MediaFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaFileAggregateArgs>(args: Subset<T, MediaFileAggregateArgs>): Prisma.PrismaPromise<GetMediaFileAggregateType<T>>

    /**
     * Group by MediaFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaFileGroupByArgs['orderBy'] }
        : { orderBy?: MediaFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaFile model
   */
  readonly fields: MediaFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaFile model
   */
  interface MediaFileFieldRefs {
    readonly id: FieldRef<"MediaFile", 'String'>
    readonly postId: FieldRef<"MediaFile", 'String'>
    readonly type: FieldRef<"MediaFile", 'MediaType'>
    readonly url: FieldRef<"MediaFile", 'String'>
    readonly mimeType: FieldRef<"MediaFile", 'String'>
    readonly width: FieldRef<"MediaFile", 'Int'>
    readonly height: FieldRef<"MediaFile", 'Int'>
    readonly sizeBytes: FieldRef<"MediaFile", 'BigInt'>
    readonly createdAt: FieldRef<"MediaFile", 'DateTime'>
    readonly updatedAt: FieldRef<"MediaFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaFile findUnique
   */
  export type MediaFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile findUniqueOrThrow
   */
  export type MediaFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile findFirst
   */
  export type MediaFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFiles.
     */
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile findFirstOrThrow
   */
  export type MediaFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFiles.
     */
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile findMany
   */
  export type MediaFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFiles to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile create
   */
  export type MediaFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaFile.
     */
    data: XOR<MediaFileCreateInput, MediaFileUncheckedCreateInput>
  }

  /**
   * MediaFile createMany
   */
  export type MediaFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaFiles.
     */
    data: MediaFileCreateManyInput | MediaFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaFile createManyAndReturn
   */
  export type MediaFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * The data used to create many MediaFiles.
     */
    data: MediaFileCreateManyInput | MediaFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaFile update
   */
  export type MediaFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaFile.
     */
    data: XOR<MediaFileUpdateInput, MediaFileUncheckedUpdateInput>
    /**
     * Choose, which MediaFile to update.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile updateMany
   */
  export type MediaFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaFiles.
     */
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyInput>
    /**
     * Filter which MediaFiles to update
     */
    where?: MediaFileWhereInput
    /**
     * Limit how many MediaFiles to update.
     */
    limit?: number
  }

  /**
   * MediaFile updateManyAndReturn
   */
  export type MediaFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * The data used to update MediaFiles.
     */
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyInput>
    /**
     * Filter which MediaFiles to update
     */
    where?: MediaFileWhereInput
    /**
     * Limit how many MediaFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaFile upsert
   */
  export type MediaFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaFile to update in case it exists.
     */
    where: MediaFileWhereUniqueInput
    /**
     * In case the MediaFile found by the `where` argument doesn't exist, create a new MediaFile with this data.
     */
    create: XOR<MediaFileCreateInput, MediaFileUncheckedCreateInput>
    /**
     * In case the MediaFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaFileUpdateInput, MediaFileUncheckedUpdateInput>
  }

  /**
   * MediaFile delete
   */
  export type MediaFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter which MediaFile to delete.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile deleteMany
   */
  export type MediaFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFiles to delete
     */
    where?: MediaFileWhereInput
    /**
     * Limit how many MediaFiles to delete.
     */
    limit?: number
  }

  /**
   * MediaFile without action
   */
  export type MediaFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentAvgAggregateOutputType = {
    likeCount: number | null
  }

  export type CommentSumAggregateOutputType = {
    likeCount: number | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    profileId: string | null
    parentCommentId: string | null
    content: string | null
    likeCount: number | null
    createdAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    profileId: string | null
    parentCommentId: string | null
    content: string | null
    likeCount: number | null
    createdAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    profileId: number
    parentCommentId: number
    content: number
    likeCount: number
    createdAt: number
    _all: number
  }


  export type CommentAvgAggregateInputType = {
    likeCount?: true
  }

  export type CommentSumAggregateInputType = {
    likeCount?: true
  }

  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    parentCommentId?: true
    content?: true
    likeCount?: true
    createdAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    parentCommentId?: true
    content?: true
    likeCount?: true
    createdAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    parentCommentId?: true
    content?: true
    likeCount?: true
    createdAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _avg?: CommentAvgAggregateInputType
    _sum?: CommentSumAggregateInputType
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    profileId: string
    parentCommentId: string | null
    content: string
    likeCount: number
    createdAt: Date
    _count: CommentCountAggregateOutputType | null
    _avg: CommentAvgAggregateOutputType | null
    _sum: CommentSumAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    parentCommentId?: boolean
    content?: boolean
    likeCount?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    reactions?: boolean | Comment$reactionsArgs<ExtArgs>
    notifications?: boolean | Comment$notificationsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    parentCommentId?: boolean
    content?: boolean
    likeCount?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    parentCommentId?: boolean
    content?: boolean
    likeCount?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    profileId?: boolean
    parentCommentId?: boolean
    content?: boolean
    likeCount?: boolean
    createdAt?: boolean
  }

  export type CommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "profileId" | "parentCommentId" | "content" | "likeCount" | "createdAt", ExtArgs["result"]["comment"]>
  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
    replies?: boolean | Comment$repliesArgs<ExtArgs>
    reactions?: boolean | Comment$reactionsArgs<ExtArgs>
    notifications?: boolean | Comment$notificationsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }
  export type CommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    author?: boolean | ProfileDefaultArgs<ExtArgs>
    parentComment?: boolean | Comment$parentCommentArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      author: Prisma.$ProfilePayload<ExtArgs>
      parentComment: Prisma.$CommentPayload<ExtArgs> | null
      replies: Prisma.$CommentPayload<ExtArgs>[]
      reactions: Prisma.$CommentReactionPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      profileId: string
      parentCommentId: string | null
      content: string
      likeCount: number
      createdAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments and returns the data updated in the database.
     * @param {CommentUpdateManyAndReturnArgs} args - Arguments to update many Comments.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parentComment<T extends Comment$parentCommentArgs<ExtArgs> = {}>(args?: Subset<T, Comment$parentCommentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    replies<T extends Comment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Comment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reactions<T extends Comment$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Comment$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly profileId: FieldRef<"Comment", 'String'>
    readonly parentCommentId: FieldRef<"Comment", 'String'>
    readonly content: FieldRef<"Comment", 'String'>
    readonly likeCount: FieldRef<"Comment", 'Int'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
  }

  /**
   * Comment updateManyAndReturn
   */
  export type CommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
    /**
     * Limit how many Comments to delete.
     */
    limit?: number
  }

  /**
   * Comment.parentComment
   */
  export type Comment$parentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Comment.replies
   */
  export type Comment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment.reactions
   */
  export type Comment$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    where?: CommentReactionWhereInput
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    cursor?: CommentReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * Comment.notifications
   */
  export type Comment$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model PostReaction
   */

  export type AggregatePostReaction = {
    _count: PostReactionCountAggregateOutputType | null
    _min: PostReactionMinAggregateOutputType | null
    _max: PostReactionMaxAggregateOutputType | null
  }

  export type PostReactionMinAggregateOutputType = {
    id: string | null
    postId: string | null
    profileId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type PostReactionMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    profileId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type PostReactionCountAggregateOutputType = {
    id: number
    postId: number
    profileId: number
    type: number
    createdAt: number
    _all: number
  }


  export type PostReactionMinAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type PostReactionMaxAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type PostReactionCountAggregateInputType = {
    id?: true
    postId?: true
    profileId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type PostReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostReaction to aggregate.
     */
    where?: PostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReactions to fetch.
     */
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostReactions
    **/
    _count?: true | PostReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostReactionMaxAggregateInputType
  }

  export type GetPostReactionAggregateType<T extends PostReactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePostReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostReaction[P]>
      : GetScalarType<T[P], AggregatePostReaction[P]>
  }




  export type PostReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostReactionWhereInput
    orderBy?: PostReactionOrderByWithAggregationInput | PostReactionOrderByWithAggregationInput[]
    by: PostReactionScalarFieldEnum[] | PostReactionScalarFieldEnum
    having?: PostReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostReactionCountAggregateInputType | true
    _min?: PostReactionMinAggregateInputType
    _max?: PostReactionMaxAggregateInputType
  }

  export type PostReactionGroupByOutputType = {
    id: string
    postId: string
    profileId: string
    type: $Enums.ReactionType
    createdAt: Date
    _count: PostReactionCountAggregateOutputType | null
    _min: PostReactionMinAggregateOutputType | null
    _max: PostReactionMaxAggregateOutputType | null
  }

  type GetPostReactionGroupByPayload<T extends PostReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostReactionGroupByOutputType[P]>
            : GetScalarType<T[P], PostReactionGroupByOutputType[P]>
        }
      >
    >


  export type PostReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postReaction"]>

  export type PostReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postReaction"]>

  export type PostReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postReaction"]>

  export type PostReactionSelectScalar = {
    id?: boolean
    postId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type PostReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "postId" | "profileId" | "type" | "createdAt", ExtArgs["result"]["postReaction"]>
  export type PostReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type PostReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type PostReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | PostDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $PostReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostReaction"
    objects: {
      post: Prisma.$PostPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      profileId: string
      type: $Enums.ReactionType
      createdAt: Date
    }, ExtArgs["result"]["postReaction"]>
    composites: {}
  }

  type PostReactionGetPayload<S extends boolean | null | undefined | PostReactionDefaultArgs> = $Result.GetResult<Prisma.$PostReactionPayload, S>

  type PostReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PostReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PostReactionCountAggregateInputType | true
    }

  export interface PostReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostReaction'], meta: { name: 'PostReaction' } }
    /**
     * Find zero or one PostReaction that matches the filter.
     * @param {PostReactionFindUniqueArgs} args - Arguments to find a PostReaction
     * @example
     * // Get one PostReaction
     * const postReaction = await prisma.postReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostReactionFindUniqueArgs>(args: SelectSubset<T, PostReactionFindUniqueArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PostReaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PostReactionFindUniqueOrThrowArgs} args - Arguments to find a PostReaction
     * @example
     * // Get one PostReaction
     * const postReaction = await prisma.postReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PostReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionFindFirstArgs} args - Arguments to find a PostReaction
     * @example
     * // Get one PostReaction
     * const postReaction = await prisma.postReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostReactionFindFirstArgs>(args?: SelectSubset<T, PostReactionFindFirstArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PostReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionFindFirstOrThrowArgs} args - Arguments to find a PostReaction
     * @example
     * // Get one PostReaction
     * const postReaction = await prisma.postReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PostReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PostReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostReactions
     * const postReactions = await prisma.postReaction.findMany()
     * 
     * // Get first 10 PostReactions
     * const postReactions = await prisma.postReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postReactionWithIdOnly = await prisma.postReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostReactionFindManyArgs>(args?: SelectSubset<T, PostReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PostReaction.
     * @param {PostReactionCreateArgs} args - Arguments to create a PostReaction.
     * @example
     * // Create one PostReaction
     * const PostReaction = await prisma.postReaction.create({
     *   data: {
     *     // ... data to create a PostReaction
     *   }
     * })
     * 
     */
    create<T extends PostReactionCreateArgs>(args: SelectSubset<T, PostReactionCreateArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PostReactions.
     * @param {PostReactionCreateManyArgs} args - Arguments to create many PostReactions.
     * @example
     * // Create many PostReactions
     * const postReaction = await prisma.postReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostReactionCreateManyArgs>(args?: SelectSubset<T, PostReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostReactions and returns the data saved in the database.
     * @param {PostReactionCreateManyAndReturnArgs} args - Arguments to create many PostReactions.
     * @example
     * // Create many PostReactions
     * const postReaction = await prisma.postReaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostReactions and only return the `id`
     * const postReactionWithIdOnly = await prisma.postReaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PostReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PostReaction.
     * @param {PostReactionDeleteArgs} args - Arguments to delete one PostReaction.
     * @example
     * // Delete one PostReaction
     * const PostReaction = await prisma.postReaction.delete({
     *   where: {
     *     // ... filter to delete one PostReaction
     *   }
     * })
     * 
     */
    delete<T extends PostReactionDeleteArgs>(args: SelectSubset<T, PostReactionDeleteArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PostReaction.
     * @param {PostReactionUpdateArgs} args - Arguments to update one PostReaction.
     * @example
     * // Update one PostReaction
     * const postReaction = await prisma.postReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostReactionUpdateArgs>(args: SelectSubset<T, PostReactionUpdateArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PostReactions.
     * @param {PostReactionDeleteManyArgs} args - Arguments to filter PostReactions to delete.
     * @example
     * // Delete a few PostReactions
     * const { count } = await prisma.postReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostReactionDeleteManyArgs>(args?: SelectSubset<T, PostReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostReactions
     * const postReaction = await prisma.postReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostReactionUpdateManyArgs>(args: SelectSubset<T, PostReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostReactions and returns the data updated in the database.
     * @param {PostReactionUpdateManyAndReturnArgs} args - Arguments to update many PostReactions.
     * @example
     * // Update many PostReactions
     * const postReaction = await prisma.postReaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PostReactions and only return the `id`
     * const postReactionWithIdOnly = await prisma.postReaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PostReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, PostReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PostReaction.
     * @param {PostReactionUpsertArgs} args - Arguments to update or create a PostReaction.
     * @example
     * // Update or create a PostReaction
     * const postReaction = await prisma.postReaction.upsert({
     *   create: {
     *     // ... data to create a PostReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostReaction we want to update
     *   }
     * })
     */
    upsert<T extends PostReactionUpsertArgs>(args: SelectSubset<T, PostReactionUpsertArgs<ExtArgs>>): Prisma__PostReactionClient<$Result.GetResult<Prisma.$PostReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PostReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionCountArgs} args - Arguments to filter PostReactions to count.
     * @example
     * // Count the number of PostReactions
     * const count = await prisma.postReaction.count({
     *   where: {
     *     // ... the filter for the PostReactions we want to count
     *   }
     * })
    **/
    count<T extends PostReactionCountArgs>(
      args?: Subset<T, PostReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostReactionAggregateArgs>(args: Subset<T, PostReactionAggregateArgs>): Prisma.PrismaPromise<GetPostReactionAggregateType<T>>

    /**
     * Group by PostReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostReactionGroupByArgs['orderBy'] }
        : { orderBy?: PostReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostReaction model
   */
  readonly fields: PostReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends PostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PostDefaultArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostReaction model
   */
  interface PostReactionFieldRefs {
    readonly id: FieldRef<"PostReaction", 'String'>
    readonly postId: FieldRef<"PostReaction", 'String'>
    readonly profileId: FieldRef<"PostReaction", 'String'>
    readonly type: FieldRef<"PostReaction", 'ReactionType'>
    readonly createdAt: FieldRef<"PostReaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PostReaction findUnique
   */
  export type PostReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReaction to fetch.
     */
    where: PostReactionWhereUniqueInput
  }

  /**
   * PostReaction findUniqueOrThrow
   */
  export type PostReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReaction to fetch.
     */
    where: PostReactionWhereUniqueInput
  }

  /**
   * PostReaction findFirst
   */
  export type PostReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReaction to fetch.
     */
    where?: PostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReactions to fetch.
     */
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostReactions.
     */
    cursor?: PostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostReactions.
     */
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * PostReaction findFirstOrThrow
   */
  export type PostReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReaction to fetch.
     */
    where?: PostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReactions to fetch.
     */
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostReactions.
     */
    cursor?: PostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostReactions.
     */
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * PostReaction findMany
   */
  export type PostReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter, which PostReactions to fetch.
     */
    where?: PostReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostReactions to fetch.
     */
    orderBy?: PostReactionOrderByWithRelationInput | PostReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostReactions.
     */
    cursor?: PostReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostReactions.
     */
    skip?: number
    distinct?: PostReactionScalarFieldEnum | PostReactionScalarFieldEnum[]
  }

  /**
   * PostReaction create
   */
  export type PostReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PostReaction.
     */
    data: XOR<PostReactionCreateInput, PostReactionUncheckedCreateInput>
  }

  /**
   * PostReaction createMany
   */
  export type PostReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostReactions.
     */
    data: PostReactionCreateManyInput | PostReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PostReaction createManyAndReturn
   */
  export type PostReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * The data used to create many PostReactions.
     */
    data: PostReactionCreateManyInput | PostReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostReaction update
   */
  export type PostReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PostReaction.
     */
    data: XOR<PostReactionUpdateInput, PostReactionUncheckedUpdateInput>
    /**
     * Choose, which PostReaction to update.
     */
    where: PostReactionWhereUniqueInput
  }

  /**
   * PostReaction updateMany
   */
  export type PostReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostReactions.
     */
    data: XOR<PostReactionUpdateManyMutationInput, PostReactionUncheckedUpdateManyInput>
    /**
     * Filter which PostReactions to update
     */
    where?: PostReactionWhereInput
    /**
     * Limit how many PostReactions to update.
     */
    limit?: number
  }

  /**
   * PostReaction updateManyAndReturn
   */
  export type PostReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * The data used to update PostReactions.
     */
    data: XOR<PostReactionUpdateManyMutationInput, PostReactionUncheckedUpdateManyInput>
    /**
     * Filter which PostReactions to update
     */
    where?: PostReactionWhereInput
    /**
     * Limit how many PostReactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostReaction upsert
   */
  export type PostReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PostReaction to update in case it exists.
     */
    where: PostReactionWhereUniqueInput
    /**
     * In case the PostReaction found by the `where` argument doesn't exist, create a new PostReaction with this data.
     */
    create: XOR<PostReactionCreateInput, PostReactionUncheckedCreateInput>
    /**
     * In case the PostReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostReactionUpdateInput, PostReactionUncheckedUpdateInput>
  }

  /**
   * PostReaction delete
   */
  export type PostReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
    /**
     * Filter which PostReaction to delete.
     */
    where: PostReactionWhereUniqueInput
  }

  /**
   * PostReaction deleteMany
   */
  export type PostReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostReactions to delete
     */
    where?: PostReactionWhereInput
    /**
     * Limit how many PostReactions to delete.
     */
    limit?: number
  }

  /**
   * PostReaction without action
   */
  export type PostReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostReaction
     */
    select?: PostReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PostReaction
     */
    omit?: PostReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostReactionInclude<ExtArgs> | null
  }


  /**
   * Model CommentReaction
   */

  export type AggregateCommentReaction = {
    _count: CommentReactionCountAggregateOutputType | null
    _min: CommentReactionMinAggregateOutputType | null
    _max: CommentReactionMaxAggregateOutputType | null
  }

  export type CommentReactionMinAggregateOutputType = {
    id: string | null
    commentId: string | null
    profileId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type CommentReactionMaxAggregateOutputType = {
    id: string | null
    commentId: string | null
    profileId: string | null
    type: $Enums.ReactionType | null
    createdAt: Date | null
  }

  export type CommentReactionCountAggregateOutputType = {
    id: number
    commentId: number
    profileId: number
    type: number
    createdAt: number
    _all: number
  }


  export type CommentReactionMinAggregateInputType = {
    id?: true
    commentId?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type CommentReactionMaxAggregateInputType = {
    id?: true
    commentId?: true
    profileId?: true
    type?: true
    createdAt?: true
  }

  export type CommentReactionCountAggregateInputType = {
    id?: true
    commentId?: true
    profileId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type CommentReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReaction to aggregate.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentReactions
    **/
    _count?: true | CommentReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentReactionMaxAggregateInputType
  }

  export type GetCommentReactionAggregateType<T extends CommentReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentReaction[P]>
      : GetScalarType<T[P], AggregateCommentReaction[P]>
  }




  export type CommentReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentReactionWhereInput
    orderBy?: CommentReactionOrderByWithAggregationInput | CommentReactionOrderByWithAggregationInput[]
    by: CommentReactionScalarFieldEnum[] | CommentReactionScalarFieldEnum
    having?: CommentReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentReactionCountAggregateInputType | true
    _min?: CommentReactionMinAggregateInputType
    _max?: CommentReactionMaxAggregateInputType
  }

  export type CommentReactionGroupByOutputType = {
    id: string
    commentId: string
    profileId: string
    type: $Enums.ReactionType
    createdAt: Date
    _count: CommentReactionCountAggregateOutputType | null
    _min: CommentReactionMinAggregateOutputType | null
    _max: CommentReactionMaxAggregateOutputType | null
  }

  type GetCommentReactionGroupByPayload<T extends CommentReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentReactionGroupByOutputType[P]>
            : GetScalarType<T[P], CommentReactionGroupByOutputType[P]>
        }
      >
    >


  export type CommentReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReaction"]>

  export type CommentReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReaction"]>

  export type CommentReactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentReaction"]>

  export type CommentReactionSelectScalar = {
    id?: boolean
    commentId?: boolean
    profileId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type CommentReactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "commentId" | "profileId" | "type" | "createdAt", ExtArgs["result"]["commentReaction"]>
  export type CommentReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type CommentReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type CommentReactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | CommentDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $CommentReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentReaction"
    objects: {
      comment: Prisma.$CommentPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      commentId: string
      profileId: string
      type: $Enums.ReactionType
      createdAt: Date
    }, ExtArgs["result"]["commentReaction"]>
    composites: {}
  }

  type CommentReactionGetPayload<S extends boolean | null | undefined | CommentReactionDefaultArgs> = $Result.GetResult<Prisma.$CommentReactionPayload, S>

  type CommentReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CommentReactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CommentReactionCountAggregateInputType | true
    }

  export interface CommentReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentReaction'], meta: { name: 'CommentReaction' } }
    /**
     * Find zero or one CommentReaction that matches the filter.
     * @param {CommentReactionFindUniqueArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentReactionFindUniqueArgs>(args: SelectSubset<T, CommentReactionFindUniqueArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CommentReaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommentReactionFindUniqueOrThrowArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentReaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionFindFirstArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentReactionFindFirstArgs>(args?: SelectSubset<T, CommentReactionFindFirstArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CommentReaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionFindFirstOrThrowArgs} args - Arguments to find a CommentReaction
     * @example
     * // Get one CommentReaction
     * const commentReaction = await prisma.commentReaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CommentReactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentReactions
     * const commentReactions = await prisma.commentReaction.findMany()
     * 
     * // Get first 10 CommentReactions
     * const commentReactions = await prisma.commentReaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentReactionWithIdOnly = await prisma.commentReaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentReactionFindManyArgs>(args?: SelectSubset<T, CommentReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CommentReaction.
     * @param {CommentReactionCreateArgs} args - Arguments to create a CommentReaction.
     * @example
     * // Create one CommentReaction
     * const CommentReaction = await prisma.commentReaction.create({
     *   data: {
     *     // ... data to create a CommentReaction
     *   }
     * })
     * 
     */
    create<T extends CommentReactionCreateArgs>(args: SelectSubset<T, CommentReactionCreateArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CommentReactions.
     * @param {CommentReactionCreateManyArgs} args - Arguments to create many CommentReactions.
     * @example
     * // Create many CommentReactions
     * const commentReaction = await prisma.commentReaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentReactionCreateManyArgs>(args?: SelectSubset<T, CommentReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentReactions and returns the data saved in the database.
     * @param {CommentReactionCreateManyAndReturnArgs} args - Arguments to create many CommentReactions.
     * @example
     * // Create many CommentReactions
     * const commentReaction = await prisma.commentReaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentReactions and only return the `id`
     * const commentReactionWithIdOnly = await prisma.commentReaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CommentReaction.
     * @param {CommentReactionDeleteArgs} args - Arguments to delete one CommentReaction.
     * @example
     * // Delete one CommentReaction
     * const CommentReaction = await prisma.commentReaction.delete({
     *   where: {
     *     // ... filter to delete one CommentReaction
     *   }
     * })
     * 
     */
    delete<T extends CommentReactionDeleteArgs>(args: SelectSubset<T, CommentReactionDeleteArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CommentReaction.
     * @param {CommentReactionUpdateArgs} args - Arguments to update one CommentReaction.
     * @example
     * // Update one CommentReaction
     * const commentReaction = await prisma.commentReaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentReactionUpdateArgs>(args: SelectSubset<T, CommentReactionUpdateArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CommentReactions.
     * @param {CommentReactionDeleteManyArgs} args - Arguments to filter CommentReactions to delete.
     * @example
     * // Delete a few CommentReactions
     * const { count } = await prisma.commentReaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentReactionDeleteManyArgs>(args?: SelectSubset<T, CommentReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentReactions
     * const commentReaction = await prisma.commentReaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentReactionUpdateManyArgs>(args: SelectSubset<T, CommentReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentReactions and returns the data updated in the database.
     * @param {CommentReactionUpdateManyAndReturnArgs} args - Arguments to update many CommentReactions.
     * @example
     * // Update many CommentReactions
     * const commentReaction = await prisma.commentReaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CommentReactions and only return the `id`
     * const commentReactionWithIdOnly = await prisma.commentReaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CommentReactionUpdateManyAndReturnArgs>(args: SelectSubset<T, CommentReactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CommentReaction.
     * @param {CommentReactionUpsertArgs} args - Arguments to update or create a CommentReaction.
     * @example
     * // Update or create a CommentReaction
     * const commentReaction = await prisma.commentReaction.upsert({
     *   create: {
     *     // ... data to create a CommentReaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentReaction we want to update
     *   }
     * })
     */
    upsert<T extends CommentReactionUpsertArgs>(args: SelectSubset<T, CommentReactionUpsertArgs<ExtArgs>>): Prisma__CommentReactionClient<$Result.GetResult<Prisma.$CommentReactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CommentReactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionCountArgs} args - Arguments to filter CommentReactions to count.
     * @example
     * // Count the number of CommentReactions
     * const count = await prisma.commentReaction.count({
     *   where: {
     *     // ... the filter for the CommentReactions we want to count
     *   }
     * })
    **/
    count<T extends CommentReactionCountArgs>(
      args?: Subset<T, CommentReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentReactionAggregateArgs>(args: Subset<T, CommentReactionAggregateArgs>): Prisma.PrismaPromise<GetCommentReactionAggregateType<T>>

    /**
     * Group by CommentReaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentReactionGroupByArgs['orderBy'] }
        : { orderBy?: CommentReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentReaction model
   */
  readonly fields: CommentReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentReaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends CommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CommentDefaultArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentReaction model
   */
  interface CommentReactionFieldRefs {
    readonly id: FieldRef<"CommentReaction", 'String'>
    readonly commentId: FieldRef<"CommentReaction", 'String'>
    readonly profileId: FieldRef<"CommentReaction", 'String'>
    readonly type: FieldRef<"CommentReaction", 'ReactionType'>
    readonly createdAt: FieldRef<"CommentReaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CommentReaction findUnique
   */
  export type CommentReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction findUniqueOrThrow
   */
  export type CommentReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction findFirst
   */
  export type CommentReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReactions.
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReactions.
     */
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * CommentReaction findFirstOrThrow
   */
  export type CommentReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReaction to fetch.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentReactions.
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentReactions.
     */
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * CommentReaction findMany
   */
  export type CommentReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter, which CommentReactions to fetch.
     */
    where?: CommentReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentReactions to fetch.
     */
    orderBy?: CommentReactionOrderByWithRelationInput | CommentReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentReactions.
     */
    cursor?: CommentReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentReactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentReactions.
     */
    skip?: number
    distinct?: CommentReactionScalarFieldEnum | CommentReactionScalarFieldEnum[]
  }

  /**
   * CommentReaction create
   */
  export type CommentReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentReaction.
     */
    data: XOR<CommentReactionCreateInput, CommentReactionUncheckedCreateInput>
  }

  /**
   * CommentReaction createMany
   */
  export type CommentReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentReactions.
     */
    data: CommentReactionCreateManyInput | CommentReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CommentReaction createManyAndReturn
   */
  export type CommentReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * The data used to create many CommentReactions.
     */
    data: CommentReactionCreateManyInput | CommentReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentReaction update
   */
  export type CommentReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentReaction.
     */
    data: XOR<CommentReactionUpdateInput, CommentReactionUncheckedUpdateInput>
    /**
     * Choose, which CommentReaction to update.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction updateMany
   */
  export type CommentReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentReactions.
     */
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyInput>
    /**
     * Filter which CommentReactions to update
     */
    where?: CommentReactionWhereInput
    /**
     * Limit how many CommentReactions to update.
     */
    limit?: number
  }

  /**
   * CommentReaction updateManyAndReturn
   */
  export type CommentReactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * The data used to update CommentReactions.
     */
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyInput>
    /**
     * Filter which CommentReactions to update
     */
    where?: CommentReactionWhereInput
    /**
     * Limit how many CommentReactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentReaction upsert
   */
  export type CommentReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentReaction to update in case it exists.
     */
    where: CommentReactionWhereUniqueInput
    /**
     * In case the CommentReaction found by the `where` argument doesn't exist, create a new CommentReaction with this data.
     */
    create: XOR<CommentReactionCreateInput, CommentReactionUncheckedCreateInput>
    /**
     * In case the CommentReaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentReactionUpdateInput, CommentReactionUncheckedUpdateInput>
  }

  /**
   * CommentReaction delete
   */
  export type CommentReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
    /**
     * Filter which CommentReaction to delete.
     */
    where: CommentReactionWhereUniqueInput
  }

  /**
   * CommentReaction deleteMany
   */
  export type CommentReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentReactions to delete
     */
    where?: CommentReactionWhereInput
    /**
     * Limit how many CommentReactions to delete.
     */
    limit?: number
  }

  /**
   * CommentReaction without action
   */
  export type CommentReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentReaction
     */
    select?: CommentReactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CommentReaction
     */
    omit?: CommentReactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentReactionInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    isGroup: boolean | null
    title: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    isGroup: boolean | null
    title: string | null
    createdById: string | null
    createdAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    isGroup: number
    title: number
    createdById: number
    createdAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    isGroup?: true
    title?: true
    createdById?: true
    createdAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    isGroup?: true
    title?: true
    createdById?: true
    createdAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    isGroup?: true
    title?: true
    createdById?: true
    createdAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    isGroup: boolean
    title: string | null
    createdById: string | null
    createdAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    createdAt?: boolean
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    createdAt?: boolean
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    createdAt?: boolean
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    isGroup?: boolean
    title?: boolean
    createdById?: boolean
    createdAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isGroup" | "title" | "createdById" | "createdAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
    participants?: boolean | Conversation$participantsArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | Conversation$createdByArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      createdBy: Prisma.$ProfilePayload<ExtArgs> | null
      participants: Prisma.$ConversationParticipantPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isGroup: boolean
      title: string | null
      createdById: string | null
      createdAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends Conversation$createdByArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$createdByArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participants<T extends Conversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly isGroup: FieldRef<"Conversation", 'Boolean'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly createdById: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data?: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.createdBy
   */
  export type Conversation$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Conversation.participants
   */
  export type Conversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    cursor?: ConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model ConversationParticipant
   */

  export type AggregateConversationParticipant = {
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  export type ConversationParticipantMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    profileId: string | null
    role: string | null
    lastReadAt: Date | null
    joinedAt: Date | null
  }

  export type ConversationParticipantMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    profileId: string | null
    role: string | null
    lastReadAt: Date | null
    joinedAt: Date | null
  }

  export type ConversationParticipantCountAggregateOutputType = {
    id: number
    conversationId: number
    profileId: number
    role: number
    lastReadAt: number
    joinedAt: number
    _all: number
  }


  export type ConversationParticipantMinAggregateInputType = {
    id?: true
    conversationId?: true
    profileId?: true
    role?: true
    lastReadAt?: true
    joinedAt?: true
  }

  export type ConversationParticipantMaxAggregateInputType = {
    id?: true
    conversationId?: true
    profileId?: true
    role?: true
    lastReadAt?: true
    joinedAt?: true
  }

  export type ConversationParticipantCountAggregateInputType = {
    id?: true
    conversationId?: true
    profileId?: true
    role?: true
    lastReadAt?: true
    joinedAt?: true
    _all?: true
  }

  export type ConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipant to aggregate.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConversationParticipants
    **/
    _count?: true | ConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type GetConversationParticipantAggregateType<T extends ConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversationParticipant[P]>
      : GetScalarType<T[P], AggregateConversationParticipant[P]>
  }




  export type ConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationParticipantWhereInput
    orderBy?: ConversationParticipantOrderByWithAggregationInput | ConversationParticipantOrderByWithAggregationInput[]
    by: ConversationParticipantScalarFieldEnum[] | ConversationParticipantScalarFieldEnum
    having?: ConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationParticipantCountAggregateInputType | true
    _min?: ConversationParticipantMinAggregateInputType
    _max?: ConversationParticipantMaxAggregateInputType
  }

  export type ConversationParticipantGroupByOutputType = {
    id: string
    conversationId: string
    profileId: string
    role: string
    lastReadAt: Date | null
    joinedAt: Date
    _count: ConversationParticipantCountAggregateOutputType | null
    _min: ConversationParticipantMinAggregateOutputType | null
    _max: ConversationParticipantMaxAggregateOutputType | null
  }

  type GetConversationParticipantGroupByPayload<T extends ConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    profileId?: boolean
    role?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    profileId?: boolean
    role?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    profileId?: boolean
    role?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversationParticipant"]>

  export type ConversationParticipantSelectScalar = {
    id?: boolean
    conversationId?: boolean
    profileId?: boolean
    role?: boolean
    lastReadAt?: boolean
    joinedAt?: boolean
  }

  export type ConversationParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "profileId" | "role" | "lastReadAt" | "joinedAt", ExtArgs["result"]["conversationParticipant"]>
  export type ConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ConversationParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConversationParticipant"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      profileId: string
      role: string
      lastReadAt: Date | null
      joinedAt: Date
    }, ExtArgs["result"]["conversationParticipant"]>
    composites: {}
  }

  type ConversationParticipantGetPayload<S extends boolean | null | undefined | ConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$ConversationParticipantPayload, S>

  type ConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationParticipantCountAggregateInputType | true
    }

  export interface ConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConversationParticipant'], meta: { name: 'ConversationParticipant' } }
    /**
     * Find zero or one ConversationParticipant that matches the filter.
     * @param {ConversationParticipantFindUniqueArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationParticipantFindUniqueArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConversationParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationParticipantFindFirstArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a ConversationParticipant
     * @example
     * // Get one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany()
     * 
     * // Get first 10 ConversationParticipants
     * const conversationParticipants = await prisma.conversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationParticipantFindManyArgs>(args?: SelectSubset<T, ConversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConversationParticipant.
     * @param {ConversationParticipantCreateArgs} args - Arguments to create a ConversationParticipant.
     * @example
     * // Create one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.create({
     *   data: {
     *     // ... data to create a ConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends ConversationParticipantCreateArgs>(args: SelectSubset<T, ConversationParticipantCreateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConversationParticipants.
     * @param {ConversationParticipantCreateManyArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationParticipantCreateManyArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConversationParticipants and returns the data saved in the database.
     * @param {ConversationParticipantCreateManyAndReturnArgs} args - Arguments to create many ConversationParticipants.
     * @example
     * // Create many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConversationParticipant.
     * @param {ConversationParticipantDeleteArgs} args - Arguments to delete one ConversationParticipant.
     * @example
     * // Delete one ConversationParticipant
     * const ConversationParticipant = await prisma.conversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one ConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends ConversationParticipantDeleteArgs>(args: SelectSubset<T, ConversationParticipantDeleteArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConversationParticipant.
     * @param {ConversationParticipantUpdateArgs} args - Arguments to update one ConversationParticipant.
     * @example
     * // Update one ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationParticipantUpdateArgs>(args: SelectSubset<T, ConversationParticipantUpdateArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConversationParticipants.
     * @param {ConversationParticipantDeleteManyArgs} args - Arguments to filter ConversationParticipants to delete.
     * @example
     * // Delete a few ConversationParticipants
     * const { count } = await prisma.conversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationParticipantDeleteManyArgs>(args?: SelectSubset<T, ConversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationParticipantUpdateManyArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConversationParticipants and returns the data updated in the database.
     * @param {ConversationParticipantUpdateManyAndReturnArgs} args - Arguments to update many ConversationParticipants.
     * @example
     * // Update many ConversationParticipants
     * const conversationParticipant = await prisma.conversationParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConversationParticipants and only return the `id`
     * const conversationParticipantWithIdOnly = await prisma.conversationParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConversationParticipant.
     * @param {ConversationParticipantUpsertArgs} args - Arguments to update or create a ConversationParticipant.
     * @example
     * // Update or create a ConversationParticipant
     * const conversationParticipant = await prisma.conversationParticipant.upsert({
     *   create: {
     *     // ... data to create a ConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ConversationParticipantUpsertArgs>(args: SelectSubset<T, ConversationParticipantUpsertArgs<ExtArgs>>): Prisma__ConversationParticipantClient<$Result.GetResult<Prisma.$ConversationParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantCountArgs} args - Arguments to filter ConversationParticipants to count.
     * @example
     * // Count the number of ConversationParticipants
     * const count = await prisma.conversationParticipant.count({
     *   where: {
     *     // ... the filter for the ConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends ConversationParticipantCountArgs>(
      args?: Subset<T, ConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationParticipantAggregateArgs>(args: Subset<T, ConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetConversationParticipantAggregateType<T>>

    /**
     * Group by ConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConversationParticipant model
   */
  readonly fields: ConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConversationParticipant model
   */
  interface ConversationParticipantFieldRefs {
    readonly id: FieldRef<"ConversationParticipant", 'String'>
    readonly conversationId: FieldRef<"ConversationParticipant", 'String'>
    readonly profileId: FieldRef<"ConversationParticipant", 'String'>
    readonly role: FieldRef<"ConversationParticipant", 'String'>
    readonly lastReadAt: FieldRef<"ConversationParticipant", 'DateTime'>
    readonly joinedAt: FieldRef<"ConversationParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ConversationParticipant findUnique
   */
  export type ConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findUniqueOrThrow
   */
  export type ConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant findFirst
   */
  export type ConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findFirstOrThrow
   */
  export type ConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipant to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConversationParticipants.
     */
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant findMany
   */
  export type ConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ConversationParticipants to fetch.
     */
    where?: ConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConversationParticipants to fetch.
     */
    orderBy?: ConversationParticipantOrderByWithRelationInput | ConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConversationParticipants.
     */
    cursor?: ConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConversationParticipants.
     */
    skip?: number
    distinct?: ConversationParticipantScalarFieldEnum | ConversationParticipantScalarFieldEnum[]
  }

  /**
   * ConversationParticipant create
   */
  export type ConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ConversationParticipant.
     */
    data: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
  }

  /**
   * ConversationParticipant createMany
   */
  export type ConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConversationParticipant createManyAndReturn
   */
  export type ConversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ConversationParticipants.
     */
    data: ConversationParticipantCreateManyInput | ConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant update
   */
  export type ConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ConversationParticipant.
     */
    data: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which ConversationParticipant to update.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant updateMany
   */
  export type ConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to update.
     */
    limit?: number
  }

  /**
   * ConversationParticipant updateManyAndReturn
   */
  export type ConversationParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ConversationParticipants.
     */
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ConversationParticipants to update
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConversationParticipant upsert
   */
  export type ConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ConversationParticipant to update in case it exists.
     */
    where: ConversationParticipantWhereUniqueInput
    /**
     * In case the ConversationParticipant found by the `where` argument doesn't exist, create a new ConversationParticipant with this data.
     */
    create: XOR<ConversationParticipantCreateInput, ConversationParticipantUncheckedCreateInput>
    /**
     * In case the ConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationParticipantUpdateInput, ConversationParticipantUncheckedUpdateInput>
  }

  /**
   * ConversationParticipant delete
   */
  export type ConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which ConversationParticipant to delete.
     */
    where: ConversationParticipantWhereUniqueInput
  }

  /**
   * ConversationParticipant deleteMany
   */
  export type ConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConversationParticipants to delete
     */
    where?: ConversationParticipantWhereInput
    /**
     * Limit how many ConversationParticipants to delete.
     */
    limit?: number
  }

  /**
   * ConversationParticipant without action
   */
  export type ConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationParticipant
     */
    select?: ConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConversationParticipant
     */
    omit?: ConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    mediaUrl: string | null
    createdAt: Date | null
    deletedAt: Date | null
    timestamp: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    mediaUrl: string | null
    createdAt: Date | null
    deletedAt: Date | null
    timestamp: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    mediaUrl: number
    createdAt: number
    deletedAt: number
    timestamp: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    mediaUrl?: true
    createdAt?: true
    deletedAt?: true
    timestamp?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    mediaUrl?: true
    createdAt?: true
    deletedAt?: true
    timestamp?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    mediaUrl?: true
    createdAt?: true
    deletedAt?: true
    timestamp?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    content: string | null
    mediaUrl: string | null
    createdAt: Date
    deletedAt: Date | null
    timestamp: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    timestamp?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
    reads?: boolean | Message$readsArgs<ExtArgs>
    notifications?: boolean | Message$notificationsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    timestamp?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    timestamp?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    mediaUrl?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    timestamp?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "content" | "mediaUrl" | "createdAt" | "deletedAt" | "timestamp", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
    reads?: boolean | Message$readsArgs<ExtArgs>
    notifications?: boolean | Message$notificationsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
    sender?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
      sender: Prisma.$ProfilePayload<ExtArgs>
      reads: Prisma.$MessageReadPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      content: string | null
      mediaUrl: string | null
      createdAt: Date
      deletedAt: Date | null
      timestamp: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reads<T extends Message$readsArgs<ExtArgs> = {}>(args?: Subset<T, Message$readsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends Message$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Message$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly mediaUrl: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly deletedAt: FieldRef<"Message", 'DateTime'>
    readonly timestamp: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.reads
   */
  export type Message$readsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    cursor?: MessageReadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * Message.notifications
   */
  export type Message$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    recipientId: string | null
    actorId: string | null
    type: $Enums.NotificationType | null
    postId: string | null
    commentId: string | null
    lineageId: string | null
    messageId: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    recipientId: string | null
    actorId: string | null
    type: $Enums.NotificationType | null
    postId: string | null
    commentId: string | null
    lineageId: string | null
    messageId: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    recipientId: number
    actorId: number
    type: number
    postId: number
    commentId: number
    lineageId: number
    messageId: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    recipientId?: true
    actorId?: true
    type?: true
    postId?: true
    commentId?: true
    lineageId?: true
    messageId?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    recipientId?: true
    actorId?: true
    type?: true
    postId?: true
    commentId?: true
    lineageId?: true
    messageId?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    recipientId?: true
    actorId?: true
    type?: true
    postId?: true
    commentId?: true
    lineageId?: true
    messageId?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    recipientId: string
    actorId: string | null
    type: $Enums.NotificationType
    postId: string | null
    commentId: string | null
    lineageId: string | null
    messageId: string | null
    isRead: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    actorId?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    lineageId?: boolean
    messageId?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
    actor?: boolean | Notification$actorArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    actorId?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    lineageId?: boolean
    messageId?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
    actor?: boolean | Notification$actorArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    recipientId?: boolean
    actorId?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    lineageId?: boolean
    messageId?: boolean
    isRead?: boolean
    createdAt?: boolean
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
    actor?: boolean | Notification$actorArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    recipientId?: boolean
    actorId?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    lineageId?: boolean
    messageId?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "recipientId" | "actorId" | "type" | "postId" | "commentId" | "lineageId" | "messageId" | "isRead" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
    actor?: boolean | Notification$actorArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
    actor?: boolean | Notification$actorArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | ProfileDefaultArgs<ExtArgs>
    actor?: boolean | Notification$actorArgs<ExtArgs>
    post?: boolean | Notification$postArgs<ExtArgs>
    comment?: boolean | Notification$commentArgs<ExtArgs>
    lineage?: boolean | Notification$lineageArgs<ExtArgs>
    message?: boolean | Notification$messageArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$ProfilePayload<ExtArgs>
      actor: Prisma.$ProfilePayload<ExtArgs> | null
      post: Prisma.$PostPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
      lineage: Prisma.$LineagePayload<ExtArgs> | null
      message: Prisma.$MessagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      recipientId: string
      actorId: string | null
      type: $Enums.NotificationType
      postId: string | null
      commentId: string | null
      lineageId: string | null
      messageId: string | null
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    actor<T extends Notification$actorArgs<ExtArgs> = {}>(args?: Subset<T, Notification$actorArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    post<T extends Notification$postArgs<ExtArgs> = {}>(args?: Subset<T, Notification$postArgs<ExtArgs>>): Prisma__PostClient<$Result.GetResult<Prisma.$PostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comment<T extends Notification$commentArgs<ExtArgs> = {}>(args?: Subset<T, Notification$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lineage<T extends Notification$lineageArgs<ExtArgs> = {}>(args?: Subset<T, Notification$lineageArgs<ExtArgs>>): Prisma__LineageClient<$Result.GetResult<Prisma.$LineagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    message<T extends Notification$messageArgs<ExtArgs> = {}>(args?: Subset<T, Notification$messageArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly actorId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly postId: FieldRef<"Notification", 'String'>
    readonly commentId: FieldRef<"Notification", 'String'>
    readonly lineageId: FieldRef<"Notification", 'String'>
    readonly messageId: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.actor
   */
  export type Notification$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Notification.post
   */
  export type Notification$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Post
     */
    select?: PostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Post
     */
    omit?: PostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostInclude<ExtArgs> | null
    where?: PostWhereInput
  }

  /**
   * Notification.comment
   */
  export type Notification$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Comment
     */
    omit?: CommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Notification.lineage
   */
  export type Notification$lineageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lineage
     */
    select?: LineageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lineage
     */
    omit?: LineageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LineageInclude<ExtArgs> | null
    where?: LineageWhereInput
  }

  /**
   * Notification.message
   */
  export type Notification$messageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Interest
   */

  export type AggregateInterest = {
    _count: InterestCountAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  export type InterestMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type InterestMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type InterestCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type InterestMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type InterestMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type InterestCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type InterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interest to aggregate.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interests
    **/
    _count?: true | InterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InterestMaxAggregateInputType
  }

  export type GetInterestAggregateType<T extends InterestAggregateArgs> = {
        [P in keyof T & keyof AggregateInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterest[P]>
      : GetScalarType<T[P], AggregateInterest[P]>
  }




  export type InterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InterestWhereInput
    orderBy?: InterestOrderByWithAggregationInput | InterestOrderByWithAggregationInput[]
    by: InterestScalarFieldEnum[] | InterestScalarFieldEnum
    having?: InterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InterestCountAggregateInputType | true
    _min?: InterestMinAggregateInputType
    _max?: InterestMaxAggregateInputType
  }

  export type InterestGroupByOutputType = {
    id: string
    name: string
    _count: InterestCountAggregateOutputType | null
    _min: InterestMinAggregateOutputType | null
    _max: InterestMaxAggregateOutputType | null
  }

  type GetInterestGroupByPayload<T extends InterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InterestGroupByOutputType[P]>
            : GetScalarType<T[P], InterestGroupByOutputType[P]>
        }
      >
    >


  export type InterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    users?: boolean | Interest$usersArgs<ExtArgs>
    _count?: boolean | InterestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["interest"]>

  export type InterestSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type InterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["interest"]>
  export type InterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Interest$usersArgs<ExtArgs>
    _count?: boolean | InterestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interest"
    objects: {
      users: Prisma.$ProfileInterestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["interest"]>
    composites: {}
  }

  type InterestGetPayload<S extends boolean | null | undefined | InterestDefaultArgs> = $Result.GetResult<Prisma.$InterestPayload, S>

  type InterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InterestCountAggregateInputType | true
    }

  export interface InterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interest'], meta: { name: 'Interest' } }
    /**
     * Find zero or one Interest that matches the filter.
     * @param {InterestFindUniqueArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InterestFindUniqueArgs>(args: SelectSubset<T, InterestFindUniqueArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InterestFindUniqueOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InterestFindUniqueOrThrowArgs>(args: SelectSubset<T, InterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InterestFindFirstArgs>(args?: SelectSubset<T, InterestFindFirstArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindFirstOrThrowArgs} args - Arguments to find a Interest
     * @example
     * // Get one Interest
     * const interest = await prisma.interest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InterestFindFirstOrThrowArgs>(args?: SelectSubset<T, InterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interests
     * const interests = await prisma.interest.findMany()
     * 
     * // Get first 10 Interests
     * const interests = await prisma.interest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interestWithIdOnly = await prisma.interest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InterestFindManyArgs>(args?: SelectSubset<T, InterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interest.
     * @param {InterestCreateArgs} args - Arguments to create a Interest.
     * @example
     * // Create one Interest
     * const Interest = await prisma.interest.create({
     *   data: {
     *     // ... data to create a Interest
     *   }
     * })
     * 
     */
    create<T extends InterestCreateArgs>(args: SelectSubset<T, InterestCreateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interests.
     * @param {InterestCreateManyArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InterestCreateManyArgs>(args?: SelectSubset<T, InterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interests and returns the data saved in the database.
     * @param {InterestCreateManyAndReturnArgs} args - Arguments to create many Interests.
     * @example
     * // Create many Interests
     * const interest = await prisma.interest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interests and only return the `id`
     * const interestWithIdOnly = await prisma.interest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InterestCreateManyAndReturnArgs>(args?: SelectSubset<T, InterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Interest.
     * @param {InterestDeleteArgs} args - Arguments to delete one Interest.
     * @example
     * // Delete one Interest
     * const Interest = await prisma.interest.delete({
     *   where: {
     *     // ... filter to delete one Interest
     *   }
     * })
     * 
     */
    delete<T extends InterestDeleteArgs>(args: SelectSubset<T, InterestDeleteArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interest.
     * @param {InterestUpdateArgs} args - Arguments to update one Interest.
     * @example
     * // Update one Interest
     * const interest = await prisma.interest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InterestUpdateArgs>(args: SelectSubset<T, InterestUpdateArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interests.
     * @param {InterestDeleteManyArgs} args - Arguments to filter Interests to delete.
     * @example
     * // Delete a few Interests
     * const { count } = await prisma.interest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InterestDeleteManyArgs>(args?: SelectSubset<T, InterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interests
     * const interest = await prisma.interest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InterestUpdateManyArgs>(args: SelectSubset<T, InterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interests and returns the data updated in the database.
     * @param {InterestUpdateManyAndReturnArgs} args - Arguments to update many Interests.
     * @example
     * // Update many Interests
     * const interest = await prisma.interest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interests and only return the `id`
     * const interestWithIdOnly = await prisma.interest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InterestUpdateManyAndReturnArgs>(args: SelectSubset<T, InterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Interest.
     * @param {InterestUpsertArgs} args - Arguments to update or create a Interest.
     * @example
     * // Update or create a Interest
     * const interest = await prisma.interest.upsert({
     *   create: {
     *     // ... data to create a Interest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interest we want to update
     *   }
     * })
     */
    upsert<T extends InterestUpsertArgs>(args: SelectSubset<T, InterestUpsertArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestCountArgs} args - Arguments to filter Interests to count.
     * @example
     * // Count the number of Interests
     * const count = await prisma.interest.count({
     *   where: {
     *     // ... the filter for the Interests we want to count
     *   }
     * })
    **/
    count<T extends InterestCountArgs>(
      args?: Subset<T, InterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InterestAggregateArgs>(args: Subset<T, InterestAggregateArgs>): Prisma.PrismaPromise<GetInterestAggregateType<T>>

    /**
     * Group by Interest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InterestGroupByArgs['orderBy'] }
        : { orderBy?: InterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interest model
   */
  readonly fields: InterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Interest$usersArgs<ExtArgs> = {}>(args?: Subset<T, Interest$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interest model
   */
  interface InterestFieldRefs {
    readonly id: FieldRef<"Interest", 'String'>
    readonly name: FieldRef<"Interest", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Interest findUnique
   */
  export type InterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findUniqueOrThrow
   */
  export type InterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest findFirst
   */
  export type InterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findFirstOrThrow
   */
  export type InterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interest to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interests.
     */
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest findMany
   */
  export type InterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter, which Interests to fetch.
     */
    where?: InterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interests to fetch.
     */
    orderBy?: InterestOrderByWithRelationInput | InterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interests.
     */
    cursor?: InterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interests.
     */
    skip?: number
    distinct?: InterestScalarFieldEnum | InterestScalarFieldEnum[]
  }

  /**
   * Interest create
   */
  export type InterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to create a Interest.
     */
    data: XOR<InterestCreateInput, InterestUncheckedCreateInput>
  }

  /**
   * Interest createMany
   */
  export type InterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest createManyAndReturn
   */
  export type InterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * The data used to create many Interests.
     */
    data: InterestCreateManyInput | InterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interest update
   */
  export type InterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The data needed to update a Interest.
     */
    data: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
    /**
     * Choose, which Interest to update.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest updateMany
   */
  export type InterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interests.
     */
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyInput>
    /**
     * Filter which Interests to update
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to update.
     */
    limit?: number
  }

  /**
   * Interest updateManyAndReturn
   */
  export type InterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * The data used to update Interests.
     */
    data: XOR<InterestUpdateManyMutationInput, InterestUncheckedUpdateManyInput>
    /**
     * Filter which Interests to update
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to update.
     */
    limit?: number
  }

  /**
   * Interest upsert
   */
  export type InterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * The filter to search for the Interest to update in case it exists.
     */
    where: InterestWhereUniqueInput
    /**
     * In case the Interest found by the `where` argument doesn't exist, create a new Interest with this data.
     */
    create: XOR<InterestCreateInput, InterestUncheckedCreateInput>
    /**
     * In case the Interest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InterestUpdateInput, InterestUncheckedUpdateInput>
  }

  /**
   * Interest delete
   */
  export type InterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
    /**
     * Filter which Interest to delete.
     */
    where: InterestWhereUniqueInput
  }

  /**
   * Interest deleteMany
   */
  export type InterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interests to delete
     */
    where?: InterestWhereInput
    /**
     * Limit how many Interests to delete.
     */
    limit?: number
  }

  /**
   * Interest.users
   */
  export type Interest$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    where?: ProfileInterestWhereInput
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    cursor?: ProfileInterestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * Interest without action
   */
  export type InterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interest
     */
    select?: InterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interest
     */
    omit?: InterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InterestInclude<ExtArgs> | null
  }


  /**
   * Model ProfileInterest
   */

  export type AggregateProfileInterest = {
    _count: ProfileInterestCountAggregateOutputType | null
    _min: ProfileInterestMinAggregateOutputType | null
    _max: ProfileInterestMaxAggregateOutputType | null
  }

  export type ProfileInterestMinAggregateOutputType = {
    userId: string | null
    interestId: string | null
    createdAt: Date | null
  }

  export type ProfileInterestMaxAggregateOutputType = {
    userId: string | null
    interestId: string | null
    createdAt: Date | null
  }

  export type ProfileInterestCountAggregateOutputType = {
    userId: number
    interestId: number
    createdAt: number
    _all: number
  }


  export type ProfileInterestMinAggregateInputType = {
    userId?: true
    interestId?: true
    createdAt?: true
  }

  export type ProfileInterestMaxAggregateInputType = {
    userId?: true
    interestId?: true
    createdAt?: true
  }

  export type ProfileInterestCountAggregateInputType = {
    userId?: true
    interestId?: true
    createdAt?: true
    _all?: true
  }

  export type ProfileInterestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileInterest to aggregate.
     */
    where?: ProfileInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileInterests to fetch.
     */
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProfileInterests
    **/
    _count?: true | ProfileInterestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileInterestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileInterestMaxAggregateInputType
  }

  export type GetProfileInterestAggregateType<T extends ProfileInterestAggregateArgs> = {
        [P in keyof T & keyof AggregateProfileInterest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfileInterest[P]>
      : GetScalarType<T[P], AggregateProfileInterest[P]>
  }




  export type ProfileInterestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileInterestWhereInput
    orderBy?: ProfileInterestOrderByWithAggregationInput | ProfileInterestOrderByWithAggregationInput[]
    by: ProfileInterestScalarFieldEnum[] | ProfileInterestScalarFieldEnum
    having?: ProfileInterestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileInterestCountAggregateInputType | true
    _min?: ProfileInterestMinAggregateInputType
    _max?: ProfileInterestMaxAggregateInputType
  }

  export type ProfileInterestGroupByOutputType = {
    userId: string
    interestId: string
    createdAt: Date
    _count: ProfileInterestCountAggregateOutputType | null
    _min: ProfileInterestMinAggregateOutputType | null
    _max: ProfileInterestMaxAggregateOutputType | null
  }

  type GetProfileInterestGroupByPayload<T extends ProfileInterestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileInterestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileInterestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileInterestGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileInterestGroupByOutputType[P]>
        }
      >
    >


  export type ProfileInterestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    interest?: boolean | InterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileInterest"]>

  export type ProfileInterestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    interest?: boolean | InterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileInterest"]>

  export type ProfileInterestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    interest?: boolean | InterestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profileInterest"]>

  export type ProfileInterestSelectScalar = {
    userId?: boolean
    interestId?: boolean
    createdAt?: boolean
  }

  export type ProfileInterestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"userId" | "interestId" | "createdAt", ExtArgs["result"]["profileInterest"]>
  export type ProfileInterestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    interest?: boolean | InterestDefaultArgs<ExtArgs>
  }
  export type ProfileInterestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    interest?: boolean | InterestDefaultArgs<ExtArgs>
  }
  export type ProfileInterestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | ProfileDefaultArgs<ExtArgs>
    interest?: boolean | InterestDefaultArgs<ExtArgs>
  }

  export type $ProfileInterestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProfileInterest"
    objects: {
      user: Prisma.$ProfilePayload<ExtArgs>
      interest: Prisma.$InterestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      interestId: string
      createdAt: Date
    }, ExtArgs["result"]["profileInterest"]>
    composites: {}
  }

  type ProfileInterestGetPayload<S extends boolean | null | undefined | ProfileInterestDefaultArgs> = $Result.GetResult<Prisma.$ProfileInterestPayload, S>

  type ProfileInterestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileInterestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileInterestCountAggregateInputType | true
    }

  export interface ProfileInterestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProfileInterest'], meta: { name: 'ProfileInterest' } }
    /**
     * Find zero or one ProfileInterest that matches the filter.
     * @param {ProfileInterestFindUniqueArgs} args - Arguments to find a ProfileInterest
     * @example
     * // Get one ProfileInterest
     * const profileInterest = await prisma.profileInterest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileInterestFindUniqueArgs>(args: SelectSubset<T, ProfileInterestFindUniqueArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProfileInterest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileInterestFindUniqueOrThrowArgs} args - Arguments to find a ProfileInterest
     * @example
     * // Get one ProfileInterest
     * const profileInterest = await prisma.profileInterest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileInterestFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileInterestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileInterest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestFindFirstArgs} args - Arguments to find a ProfileInterest
     * @example
     * // Get one ProfileInterest
     * const profileInterest = await prisma.profileInterest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileInterestFindFirstArgs>(args?: SelectSubset<T, ProfileInterestFindFirstArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProfileInterest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestFindFirstOrThrowArgs} args - Arguments to find a ProfileInterest
     * @example
     * // Get one ProfileInterest
     * const profileInterest = await prisma.profileInterest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileInterestFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileInterestFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProfileInterests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProfileInterests
     * const profileInterests = await prisma.profileInterest.findMany()
     * 
     * // Get first 10 ProfileInterests
     * const profileInterests = await prisma.profileInterest.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const profileInterestWithUserIdOnly = await prisma.profileInterest.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends ProfileInterestFindManyArgs>(args?: SelectSubset<T, ProfileInterestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProfileInterest.
     * @param {ProfileInterestCreateArgs} args - Arguments to create a ProfileInterest.
     * @example
     * // Create one ProfileInterest
     * const ProfileInterest = await prisma.profileInterest.create({
     *   data: {
     *     // ... data to create a ProfileInterest
     *   }
     * })
     * 
     */
    create<T extends ProfileInterestCreateArgs>(args: SelectSubset<T, ProfileInterestCreateArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProfileInterests.
     * @param {ProfileInterestCreateManyArgs} args - Arguments to create many ProfileInterests.
     * @example
     * // Create many ProfileInterests
     * const profileInterest = await prisma.profileInterest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileInterestCreateManyArgs>(args?: SelectSubset<T, ProfileInterestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProfileInterests and returns the data saved in the database.
     * @param {ProfileInterestCreateManyAndReturnArgs} args - Arguments to create many ProfileInterests.
     * @example
     * // Create many ProfileInterests
     * const profileInterest = await prisma.profileInterest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProfileInterests and only return the `userId`
     * const profileInterestWithUserIdOnly = await prisma.profileInterest.createManyAndReturn({
     *   select: { userId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileInterestCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileInterestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProfileInterest.
     * @param {ProfileInterestDeleteArgs} args - Arguments to delete one ProfileInterest.
     * @example
     * // Delete one ProfileInterest
     * const ProfileInterest = await prisma.profileInterest.delete({
     *   where: {
     *     // ... filter to delete one ProfileInterest
     *   }
     * })
     * 
     */
    delete<T extends ProfileInterestDeleteArgs>(args: SelectSubset<T, ProfileInterestDeleteArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProfileInterest.
     * @param {ProfileInterestUpdateArgs} args - Arguments to update one ProfileInterest.
     * @example
     * // Update one ProfileInterest
     * const profileInterest = await prisma.profileInterest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileInterestUpdateArgs>(args: SelectSubset<T, ProfileInterestUpdateArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProfileInterests.
     * @param {ProfileInterestDeleteManyArgs} args - Arguments to filter ProfileInterests to delete.
     * @example
     * // Delete a few ProfileInterests
     * const { count } = await prisma.profileInterest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileInterestDeleteManyArgs>(args?: SelectSubset<T, ProfileInterestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProfileInterests
     * const profileInterest = await prisma.profileInterest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileInterestUpdateManyArgs>(args: SelectSubset<T, ProfileInterestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProfileInterests and returns the data updated in the database.
     * @param {ProfileInterestUpdateManyAndReturnArgs} args - Arguments to update many ProfileInterests.
     * @example
     * // Update many ProfileInterests
     * const profileInterest = await prisma.profileInterest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProfileInterests and only return the `userId`
     * const profileInterestWithUserIdOnly = await prisma.profileInterest.updateManyAndReturn({
     *   select: { userId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileInterestUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileInterestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProfileInterest.
     * @param {ProfileInterestUpsertArgs} args - Arguments to update or create a ProfileInterest.
     * @example
     * // Update or create a ProfileInterest
     * const profileInterest = await prisma.profileInterest.upsert({
     *   create: {
     *     // ... data to create a ProfileInterest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProfileInterest we want to update
     *   }
     * })
     */
    upsert<T extends ProfileInterestUpsertArgs>(args: SelectSubset<T, ProfileInterestUpsertArgs<ExtArgs>>): Prisma__ProfileInterestClient<$Result.GetResult<Prisma.$ProfileInterestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProfileInterests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestCountArgs} args - Arguments to filter ProfileInterests to count.
     * @example
     * // Count the number of ProfileInterests
     * const count = await prisma.profileInterest.count({
     *   where: {
     *     // ... the filter for the ProfileInterests we want to count
     *   }
     * })
    **/
    count<T extends ProfileInterestCountArgs>(
      args?: Subset<T, ProfileInterestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileInterestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProfileInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileInterestAggregateArgs>(args: Subset<T, ProfileInterestAggregateArgs>): Prisma.PrismaPromise<GetProfileInterestAggregateType<T>>

    /**
     * Group by ProfileInterest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileInterestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileInterestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileInterestGroupByArgs['orderBy'] }
        : { orderBy?: ProfileInterestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileInterestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileInterestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProfileInterest model
   */
  readonly fields: ProfileInterestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProfileInterest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileInterestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    interest<T extends InterestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InterestDefaultArgs<ExtArgs>>): Prisma__InterestClient<$Result.GetResult<Prisma.$InterestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProfileInterest model
   */
  interface ProfileInterestFieldRefs {
    readonly userId: FieldRef<"ProfileInterest", 'String'>
    readonly interestId: FieldRef<"ProfileInterest", 'String'>
    readonly createdAt: FieldRef<"ProfileInterest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProfileInterest findUnique
   */
  export type ProfileInterestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterest to fetch.
     */
    where: ProfileInterestWhereUniqueInput
  }

  /**
   * ProfileInterest findUniqueOrThrow
   */
  export type ProfileInterestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterest to fetch.
     */
    where: ProfileInterestWhereUniqueInput
  }

  /**
   * ProfileInterest findFirst
   */
  export type ProfileInterestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterest to fetch.
     */
    where?: ProfileInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileInterests to fetch.
     */
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileInterests.
     */
    cursor?: ProfileInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileInterests.
     */
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * ProfileInterest findFirstOrThrow
   */
  export type ProfileInterestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterest to fetch.
     */
    where?: ProfileInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileInterests to fetch.
     */
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProfileInterests.
     */
    cursor?: ProfileInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileInterests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProfileInterests.
     */
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * ProfileInterest findMany
   */
  export type ProfileInterestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter, which ProfileInterests to fetch.
     */
    where?: ProfileInterestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProfileInterests to fetch.
     */
    orderBy?: ProfileInterestOrderByWithRelationInput | ProfileInterestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProfileInterests.
     */
    cursor?: ProfileInterestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProfileInterests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProfileInterests.
     */
    skip?: number
    distinct?: ProfileInterestScalarFieldEnum | ProfileInterestScalarFieldEnum[]
  }

  /**
   * ProfileInterest create
   */
  export type ProfileInterestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * The data needed to create a ProfileInterest.
     */
    data: XOR<ProfileInterestCreateInput, ProfileInterestUncheckedCreateInput>
  }

  /**
   * ProfileInterest createMany
   */
  export type ProfileInterestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProfileInterests.
     */
    data: ProfileInterestCreateManyInput | ProfileInterestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProfileInterest createManyAndReturn
   */
  export type ProfileInterestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * The data used to create many ProfileInterests.
     */
    data: ProfileInterestCreateManyInput | ProfileInterestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileInterest update
   */
  export type ProfileInterestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * The data needed to update a ProfileInterest.
     */
    data: XOR<ProfileInterestUpdateInput, ProfileInterestUncheckedUpdateInput>
    /**
     * Choose, which ProfileInterest to update.
     */
    where: ProfileInterestWhereUniqueInput
  }

  /**
   * ProfileInterest updateMany
   */
  export type ProfileInterestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProfileInterests.
     */
    data: XOR<ProfileInterestUpdateManyMutationInput, ProfileInterestUncheckedUpdateManyInput>
    /**
     * Filter which ProfileInterests to update
     */
    where?: ProfileInterestWhereInput
    /**
     * Limit how many ProfileInterests to update.
     */
    limit?: number
  }

  /**
   * ProfileInterest updateManyAndReturn
   */
  export type ProfileInterestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * The data used to update ProfileInterests.
     */
    data: XOR<ProfileInterestUpdateManyMutationInput, ProfileInterestUncheckedUpdateManyInput>
    /**
     * Filter which ProfileInterests to update
     */
    where?: ProfileInterestWhereInput
    /**
     * Limit how many ProfileInterests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProfileInterest upsert
   */
  export type ProfileInterestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * The filter to search for the ProfileInterest to update in case it exists.
     */
    where: ProfileInterestWhereUniqueInput
    /**
     * In case the ProfileInterest found by the `where` argument doesn't exist, create a new ProfileInterest with this data.
     */
    create: XOR<ProfileInterestCreateInput, ProfileInterestUncheckedCreateInput>
    /**
     * In case the ProfileInterest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileInterestUpdateInput, ProfileInterestUncheckedUpdateInput>
  }

  /**
   * ProfileInterest delete
   */
  export type ProfileInterestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
    /**
     * Filter which ProfileInterest to delete.
     */
    where: ProfileInterestWhereUniqueInput
  }

  /**
   * ProfileInterest deleteMany
   */
  export type ProfileInterestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProfileInterests to delete
     */
    where?: ProfileInterestWhereInput
    /**
     * Limit how many ProfileInterests to delete.
     */
    limit?: number
  }

  /**
   * ProfileInterest without action
   */
  export type ProfileInterestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileInterest
     */
    select?: ProfileInterestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProfileInterest
     */
    omit?: ProfileInterestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInterestInclude<ExtArgs> | null
  }


  /**
   * Model MessageRead
   */

  export type AggregateMessageRead = {
    _count: MessageReadCountAggregateOutputType | null
    _min: MessageReadMinAggregateOutputType | null
    _max: MessageReadMaxAggregateOutputType | null
  }

  export type MessageReadMinAggregateOutputType = {
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadMaxAggregateOutputType = {
    messageId: string | null
    userId: string | null
    readAt: Date | null
  }

  export type MessageReadCountAggregateOutputType = {
    messageId: number
    userId: number
    readAt: number
    _all: number
  }


  export type MessageReadMinAggregateInputType = {
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadMaxAggregateInputType = {
    messageId?: true
    userId?: true
    readAt?: true
  }

  export type MessageReadCountAggregateInputType = {
    messageId?: true
    userId?: true
    readAt?: true
    _all?: true
  }

  export type MessageReadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRead to aggregate.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageReads
    **/
    _count?: true | MessageReadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageReadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageReadMaxAggregateInputType
  }

  export type GetMessageReadAggregateType<T extends MessageReadAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageRead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageRead[P]>
      : GetScalarType<T[P], AggregateMessageRead[P]>
  }




  export type MessageReadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageReadWhereInput
    orderBy?: MessageReadOrderByWithAggregationInput | MessageReadOrderByWithAggregationInput[]
    by: MessageReadScalarFieldEnum[] | MessageReadScalarFieldEnum
    having?: MessageReadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageReadCountAggregateInputType | true
    _min?: MessageReadMinAggregateInputType
    _max?: MessageReadMaxAggregateInputType
  }

  export type MessageReadGroupByOutputType = {
    messageId: string
    userId: string
    readAt: Date
    _count: MessageReadCountAggregateOutputType | null
    _min: MessageReadMinAggregateOutputType | null
    _max: MessageReadMaxAggregateOutputType | null
  }

  type GetMessageReadGroupByPayload<T extends MessageReadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageReadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageReadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageReadGroupByOutputType[P]>
            : GetScalarType<T[P], MessageReadGroupByOutputType[P]>
        }
      >
    >


  export type MessageReadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRead"]>

  export type MessageReadSelectScalar = {
    messageId?: boolean
    userId?: boolean
    readAt?: boolean
  }

  export type MessageReadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"messageId" | "userId" | "readAt", ExtArgs["result"]["messageRead"]>
  export type MessageReadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MessageReadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type MessageReadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $MessageReadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageRead"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      messageId: string
      userId: string
      readAt: Date
    }, ExtArgs["result"]["messageRead"]>
    composites: {}
  }

  type MessageReadGetPayload<S extends boolean | null | undefined | MessageReadDefaultArgs> = $Result.GetResult<Prisma.$MessageReadPayload, S>

  type MessageReadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageReadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageReadCountAggregateInputType | true
    }

  export interface MessageReadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageRead'], meta: { name: 'MessageRead' } }
    /**
     * Find zero or one MessageRead that matches the filter.
     * @param {MessageReadFindUniqueArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageReadFindUniqueArgs>(args: SelectSubset<T, MessageReadFindUniqueArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageRead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageReadFindUniqueOrThrowArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageReadFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageReadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindFirstArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageReadFindFirstArgs>(args?: SelectSubset<T, MessageReadFindFirstArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindFirstOrThrowArgs} args - Arguments to find a MessageRead
     * @example
     * // Get one MessageRead
     * const messageRead = await prisma.messageRead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageReadFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageReadFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageReads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageReads
     * const messageReads = await prisma.messageRead.findMany()
     * 
     * // Get first 10 MessageReads
     * const messageReads = await prisma.messageRead.findMany({ take: 10 })
     * 
     * // Only select the `messageId`
     * const messageReadWithMessageIdOnly = await prisma.messageRead.findMany({ select: { messageId: true } })
     * 
     */
    findMany<T extends MessageReadFindManyArgs>(args?: SelectSubset<T, MessageReadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageRead.
     * @param {MessageReadCreateArgs} args - Arguments to create a MessageRead.
     * @example
     * // Create one MessageRead
     * const MessageRead = await prisma.messageRead.create({
     *   data: {
     *     // ... data to create a MessageRead
     *   }
     * })
     * 
     */
    create<T extends MessageReadCreateArgs>(args: SelectSubset<T, MessageReadCreateArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageReads.
     * @param {MessageReadCreateManyArgs} args - Arguments to create many MessageReads.
     * @example
     * // Create many MessageReads
     * const messageRead = await prisma.messageRead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageReadCreateManyArgs>(args?: SelectSubset<T, MessageReadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageReads and returns the data saved in the database.
     * @param {MessageReadCreateManyAndReturnArgs} args - Arguments to create many MessageReads.
     * @example
     * // Create many MessageReads
     * const messageRead = await prisma.messageRead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageReads and only return the `messageId`
     * const messageReadWithMessageIdOnly = await prisma.messageRead.createManyAndReturn({
     *   select: { messageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageReadCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageReadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageRead.
     * @param {MessageReadDeleteArgs} args - Arguments to delete one MessageRead.
     * @example
     * // Delete one MessageRead
     * const MessageRead = await prisma.messageRead.delete({
     *   where: {
     *     // ... filter to delete one MessageRead
     *   }
     * })
     * 
     */
    delete<T extends MessageReadDeleteArgs>(args: SelectSubset<T, MessageReadDeleteArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageRead.
     * @param {MessageReadUpdateArgs} args - Arguments to update one MessageRead.
     * @example
     * // Update one MessageRead
     * const messageRead = await prisma.messageRead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageReadUpdateArgs>(args: SelectSubset<T, MessageReadUpdateArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageReads.
     * @param {MessageReadDeleteManyArgs} args - Arguments to filter MessageReads to delete.
     * @example
     * // Delete a few MessageReads
     * const { count } = await prisma.messageRead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageReadDeleteManyArgs>(args?: SelectSubset<T, MessageReadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageReads
     * const messageRead = await prisma.messageRead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageReadUpdateManyArgs>(args: SelectSubset<T, MessageReadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageReads and returns the data updated in the database.
     * @param {MessageReadUpdateManyAndReturnArgs} args - Arguments to update many MessageReads.
     * @example
     * // Update many MessageReads
     * const messageRead = await prisma.messageRead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageReads and only return the `messageId`
     * const messageReadWithMessageIdOnly = await prisma.messageRead.updateManyAndReturn({
     *   select: { messageId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageReadUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageReadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageRead.
     * @param {MessageReadUpsertArgs} args - Arguments to update or create a MessageRead.
     * @example
     * // Update or create a MessageRead
     * const messageRead = await prisma.messageRead.upsert({
     *   create: {
     *     // ... data to create a MessageRead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageRead we want to update
     *   }
     * })
     */
    upsert<T extends MessageReadUpsertArgs>(args: SelectSubset<T, MessageReadUpsertArgs<ExtArgs>>): Prisma__MessageReadClient<$Result.GetResult<Prisma.$MessageReadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageReads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadCountArgs} args - Arguments to filter MessageReads to count.
     * @example
     * // Count the number of MessageReads
     * const count = await prisma.messageRead.count({
     *   where: {
     *     // ... the filter for the MessageReads we want to count
     *   }
     * })
    **/
    count<T extends MessageReadCountArgs>(
      args?: Subset<T, MessageReadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageReadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageReadAggregateArgs>(args: Subset<T, MessageReadAggregateArgs>): Prisma.PrismaPromise<GetMessageReadAggregateType<T>>

    /**
     * Group by MessageRead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageReadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageReadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageReadGroupByArgs['orderBy'] }
        : { orderBy?: MessageReadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageReadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageReadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageRead model
   */
  readonly fields: MessageReadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageRead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageReadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageRead model
   */
  interface MessageReadFieldRefs {
    readonly messageId: FieldRef<"MessageRead", 'String'>
    readonly userId: FieldRef<"MessageRead", 'String'>
    readonly readAt: FieldRef<"MessageRead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageRead findUnique
   */
  export type MessageReadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead findUniqueOrThrow
   */
  export type MessageReadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead findFirst
   */
  export type MessageReadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReads.
     */
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead findFirstOrThrow
   */
  export type MessageReadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageRead to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageReads.
     */
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead findMany
   */
  export type MessageReadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter, which MessageReads to fetch.
     */
    where?: MessageReadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageReads to fetch.
     */
    orderBy?: MessageReadOrderByWithRelationInput | MessageReadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageReads.
     */
    cursor?: MessageReadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageReads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageReads.
     */
    skip?: number
    distinct?: MessageReadScalarFieldEnum | MessageReadScalarFieldEnum[]
  }

  /**
   * MessageRead create
   */
  export type MessageReadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageRead.
     */
    data: XOR<MessageReadCreateInput, MessageReadUncheckedCreateInput>
  }

  /**
   * MessageRead createMany
   */
  export type MessageReadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageReads.
     */
    data: MessageReadCreateManyInput | MessageReadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageRead createManyAndReturn
   */
  export type MessageReadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * The data used to create many MessageReads.
     */
    data: MessageReadCreateManyInput | MessageReadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRead update
   */
  export type MessageReadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageRead.
     */
    data: XOR<MessageReadUpdateInput, MessageReadUncheckedUpdateInput>
    /**
     * Choose, which MessageRead to update.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead updateMany
   */
  export type MessageReadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageReads.
     */
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyInput>
    /**
     * Filter which MessageReads to update
     */
    where?: MessageReadWhereInput
    /**
     * Limit how many MessageReads to update.
     */
    limit?: number
  }

  /**
   * MessageRead updateManyAndReturn
   */
  export type MessageReadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * The data used to update MessageReads.
     */
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyInput>
    /**
     * Filter which MessageReads to update
     */
    where?: MessageReadWhereInput
    /**
     * Limit how many MessageReads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRead upsert
   */
  export type MessageReadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageRead to update in case it exists.
     */
    where: MessageReadWhereUniqueInput
    /**
     * In case the MessageRead found by the `where` argument doesn't exist, create a new MessageRead with this data.
     */
    create: XOR<MessageReadCreateInput, MessageReadUncheckedCreateInput>
    /**
     * In case the MessageRead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageReadUpdateInput, MessageReadUncheckedUpdateInput>
  }

  /**
   * MessageRead delete
   */
  export type MessageReadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
    /**
     * Filter which MessageRead to delete.
     */
    where: MessageReadWhereUniqueInput
  }

  /**
   * MessageRead deleteMany
   */
  export type MessageReadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageReads to delete
     */
    where?: MessageReadWhereInput
    /**
     * Limit how many MessageReads to delete.
     */
    limit?: number
  }

  /**
   * MessageRead without action
   */
  export type MessageReadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRead
     */
    select?: MessageReadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRead
     */
    omit?: MessageReadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageReadInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    gender: 'gender',
    dateOfBirth: 'dateOfBirth',
    country: 'country',
    city: 'city',
    district: 'district',
    location: 'location',
    bio: 'bio',
    countryCode: 'countryCode',
    avatarUrl: 'avatarUrl',
    coverUrl: 'coverUrl',
    lineageMainSurname: 'lineageMainSurname',
    lineageRootVillage: 'lineageRootVillage',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const ProfileSettingsScalarFieldEnum: {
    profileId: 'profileId',
    isPrivate: 'isPrivate',
    showLastSeen: 'showLastSeen',
    allowTagging: 'allowTagging',
    allowMessagesFrom: 'allowMessagesFrom',
    discoveryAllowLineage: 'discoveryAllowLineage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileSettingsScalarFieldEnum = (typeof ProfileSettingsScalarFieldEnum)[keyof typeof ProfileSettingsScalarFieldEnum]


  export const LineageScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    primarySurname: 'primarySurname',
    rootVillage: 'rootVillage',
    rootRegion: 'rootRegion',
    description: 'description',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LineageScalarFieldEnum = (typeof LineageScalarFieldEnum)[keyof typeof LineageScalarFieldEnum]


  export const LineageMembershipScalarFieldEnum: {
    id: 'id',
    lineageId: 'lineageId',
    profileId: 'profileId',
    role: 'role',
    generation: 'generation',
    isPrimaryLineage: 'isPrimaryLineage',
    addedById: 'addedById',
    createdAt: 'createdAt'
  };

  export type LineageMembershipScalarFieldEnum = (typeof LineageMembershipScalarFieldEnum)[keyof typeof LineageMembershipScalarFieldEnum]


  export const KinshipScalarFieldEnum: {
    id: 'id',
    profileIdA: 'profileIdA',
    profileIdB: 'profileIdB',
    relationAtoB: 'relationAtoB',
    verified: 'verified',
    verifiedById: 'verifiedById',
    createdAt: 'createdAt'
  };

  export type KinshipScalarFieldEnum = (typeof KinshipScalarFieldEnum)[keyof typeof KinshipScalarFieldEnum]


  export const FollowScalarFieldEnum: {
    id: 'id',
    followerId: 'followerId',
    followeeId: 'followeeId',
    createdAt: 'createdAt'
  };

  export type FollowScalarFieldEnum = (typeof FollowScalarFieldEnum)[keyof typeof FollowScalarFieldEnum]


  export const BlockScalarFieldEnum: {
    id: 'id',
    blockerId: 'blockerId',
    blockedId: 'blockedId',
    createdAt: 'createdAt'
  };

  export type BlockScalarFieldEnum = (typeof BlockScalarFieldEnum)[keyof typeof BlockScalarFieldEnum]


  export const MuteScalarFieldEnum: {
    id: 'id',
    muterId: 'muterId',
    mutedId: 'mutedId',
    createdAt: 'createdAt'
  };

  export type MuteScalarFieldEnum = (typeof MuteScalarFieldEnum)[keyof typeof MuteScalarFieldEnum]


  export const PostScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    content: 'content',
    visibility: 'visibility',
    locationText: 'locationText',
    lineageId: 'lineageId',
    commentCount: 'commentCount',
    likeCount: 'likeCount',
    shareCount: 'shareCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PostScalarFieldEnum = (typeof PostScalarFieldEnum)[keyof typeof PostScalarFieldEnum]


  export const MediaFileScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    type: 'type',
    url: 'url',
    mimeType: 'mimeType',
    width: 'width',
    height: 'height',
    sizeBytes: 'sizeBytes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaFileScalarFieldEnum = (typeof MediaFileScalarFieldEnum)[keyof typeof MediaFileScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    profileId: 'profileId',
    parentCommentId: 'parentCommentId',
    content: 'content',
    likeCount: 'likeCount',
    createdAt: 'createdAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const PostReactionScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    profileId: 'profileId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type PostReactionScalarFieldEnum = (typeof PostReactionScalarFieldEnum)[keyof typeof PostReactionScalarFieldEnum]


  export const CommentReactionScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    profileId: 'profileId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type CommentReactionScalarFieldEnum = (typeof CommentReactionScalarFieldEnum)[keyof typeof CommentReactionScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    isGroup: 'isGroup',
    title: 'title',
    createdById: 'createdById',
    createdAt: 'createdAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const ConversationParticipantScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    profileId: 'profileId',
    role: 'role',
    lastReadAt: 'lastReadAt',
    joinedAt: 'joinedAt'
  };

  export type ConversationParticipantScalarFieldEnum = (typeof ConversationParticipantScalarFieldEnum)[keyof typeof ConversationParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    mediaUrl: 'mediaUrl',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt',
    timestamp: 'timestamp'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    recipientId: 'recipientId',
    actorId: 'actorId',
    type: 'type',
    postId: 'postId',
    commentId: 'commentId',
    lineageId: 'lineageId',
    messageId: 'messageId',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const InterestScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type InterestScalarFieldEnum = (typeof InterestScalarFieldEnum)[keyof typeof InterestScalarFieldEnum]


  export const ProfileInterestScalarFieldEnum: {
    userId: 'userId',
    interestId: 'interestId',
    createdAt: 'createdAt'
  };

  export type ProfileInterestScalarFieldEnum = (typeof ProfileInterestScalarFieldEnum)[keyof typeof ProfileInterestScalarFieldEnum]


  export const MessageReadScalarFieldEnum: {
    messageId: 'messageId',
    userId: 'userId',
    readAt: 'readAt'
  };

  export type MessageReadScalarFieldEnum = (typeof MessageReadScalarFieldEnum)[keyof typeof MessageReadScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'LineageType'
   */
  export type EnumLineageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LineageType'>
    


  /**
   * Reference to a field of type 'LineageType[]'
   */
  export type ListEnumLineageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LineageType[]'>
    


  /**
   * Reference to a field of type 'LineageRole'
   */
  export type EnumLineageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LineageRole'>
    


  /**
   * Reference to a field of type 'LineageRole[]'
   */
  export type ListEnumLineageRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LineageRole[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'KinshipType'
   */
  export type EnumKinshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KinshipType'>
    


  /**
   * Reference to a field of type 'KinshipType[]'
   */
  export type ListEnumKinshipTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KinshipType[]'>
    


  /**
   * Reference to a field of type 'PostVisibility'
   */
  export type EnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility'>
    


  /**
   * Reference to a field of type 'PostVisibility[]'
   */
  export type ListEnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility[]'>
    


  /**
   * Reference to a field of type 'MediaType'
   */
  export type EnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType'>
    


  /**
   * Reference to a field of type 'MediaType[]'
   */
  export type ListEnumMediaTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'ReactionType'
   */
  export type EnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType'>
    


  /**
   * Reference to a field of type 'ReactionType[]'
   */
  export type ListEnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: UuidFilter<"Profile"> | string
    userId?: UuidFilter<"Profile"> | string
    firstName?: StringFilter<"Profile"> | string
    lastName?: StringFilter<"Profile"> | string
    username?: StringFilter<"Profile"> | string
    gender?: StringNullableFilter<"Profile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Profile"> | Date | string | null
    country?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    district?: StringNullableFilter<"Profile"> | string | null
    location?: StringFilter<"Profile"> | string
    bio?: StringFilter<"Profile"> | string
    countryCode?: StringNullableFilter<"Profile"> | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    coverUrl?: StringNullableFilter<"Profile"> | string | null
    lineageMainSurname?: StringNullableFilter<"Profile"> | string | null
    lineageRootVillage?: StringNullableFilter<"Profile"> | string | null
    isVerified?: BoolFilter<"Profile"> | boolean
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    interests?: ProfileInterestListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    messages?: MessageListRelationFilter
    messageReads?: MessageReadListRelationFilter
    postReactions?: PostReactionListRelationFilter
    settings?: XOR<ProfileSettingsNullableScalarRelationFilter, ProfileSettingsWhereInput> | null
    lineageMemberships?: LineageMembershipListRelationFilter
    kinshipsA?: KinshipListRelationFilter
    kinshipsB?: KinshipListRelationFilter
    commentReactions?: CommentReactionListRelationFilter
    followsAsFollower?: FollowListRelationFilter
    followsAsFollowee?: FollowListRelationFilter
    blocksAsBlocker?: BlockListRelationFilter
    blocksAsBlocked?: BlockListRelationFilter
    mutesAsMuter?: MuteListRelationFilter
    mutesAsMuted?: MuteListRelationFilter
    conversationsOwned?: ConversationListRelationFilter
    conversationMembers?: ConversationParticipantListRelationFilter
    notifications?: NotificationListRelationFilter
    notificationsAsActor?: NotificationListRelationFilter
    lineagesCreated?: LineageListRelationFilter
    lineageMembershipsAdded?: LineageMembershipListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    location?: SortOrder
    bio?: SortOrder
    countryCode?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    lineageMainSurname?: SortOrderInput | SortOrder
    lineageRootVillage?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    interests?: ProfileInterestOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    messageReads?: MessageReadOrderByRelationAggregateInput
    postReactions?: PostReactionOrderByRelationAggregateInput
    settings?: ProfileSettingsOrderByWithRelationInput
    lineageMemberships?: LineageMembershipOrderByRelationAggregateInput
    kinshipsA?: KinshipOrderByRelationAggregateInput
    kinshipsB?: KinshipOrderByRelationAggregateInput
    commentReactions?: CommentReactionOrderByRelationAggregateInput
    followsAsFollower?: FollowOrderByRelationAggregateInput
    followsAsFollowee?: FollowOrderByRelationAggregateInput
    blocksAsBlocker?: BlockOrderByRelationAggregateInput
    blocksAsBlocked?: BlockOrderByRelationAggregateInput
    mutesAsMuter?: MuteOrderByRelationAggregateInput
    mutesAsMuted?: MuteOrderByRelationAggregateInput
    conversationsOwned?: ConversationOrderByRelationAggregateInput
    conversationMembers?: ConversationParticipantOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    notificationsAsActor?: NotificationOrderByRelationAggregateInput
    lineagesCreated?: LineageOrderByRelationAggregateInput
    lineageMembershipsAdded?: LineageMembershipOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    username?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    firstName?: StringFilter<"Profile"> | string
    lastName?: StringFilter<"Profile"> | string
    gender?: StringNullableFilter<"Profile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"Profile"> | Date | string | null
    country?: StringNullableFilter<"Profile"> | string | null
    city?: StringNullableFilter<"Profile"> | string | null
    district?: StringNullableFilter<"Profile"> | string | null
    location?: StringFilter<"Profile"> | string
    bio?: StringFilter<"Profile"> | string
    countryCode?: StringNullableFilter<"Profile"> | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    coverUrl?: StringNullableFilter<"Profile"> | string | null
    lineageMainSurname?: StringNullableFilter<"Profile"> | string | null
    lineageRootVillage?: StringNullableFilter<"Profile"> | string | null
    isVerified?: BoolFilter<"Profile"> | boolean
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    interests?: ProfileInterestListRelationFilter
    posts?: PostListRelationFilter
    comments?: CommentListRelationFilter
    messages?: MessageListRelationFilter
    messageReads?: MessageReadListRelationFilter
    postReactions?: PostReactionListRelationFilter
    settings?: XOR<ProfileSettingsNullableScalarRelationFilter, ProfileSettingsWhereInput> | null
    lineageMemberships?: LineageMembershipListRelationFilter
    kinshipsA?: KinshipListRelationFilter
    kinshipsB?: KinshipListRelationFilter
    commentReactions?: CommentReactionListRelationFilter
    followsAsFollower?: FollowListRelationFilter
    followsAsFollowee?: FollowListRelationFilter
    blocksAsBlocker?: BlockListRelationFilter
    blocksAsBlocked?: BlockListRelationFilter
    mutesAsMuter?: MuteListRelationFilter
    mutesAsMuted?: MuteListRelationFilter
    conversationsOwned?: ConversationListRelationFilter
    conversationMembers?: ConversationParticipantListRelationFilter
    notifications?: NotificationListRelationFilter
    notificationsAsActor?: NotificationListRelationFilter
    lineagesCreated?: LineageListRelationFilter
    lineageMembershipsAdded?: LineageMembershipListRelationFilter
  }, "id" | "userId" | "username">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    gender?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    district?: SortOrderInput | SortOrder
    location?: SortOrder
    bio?: SortOrder
    countryCode?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    coverUrl?: SortOrderInput | SortOrder
    lineageMainSurname?: SortOrderInput | SortOrder
    lineageRootVillage?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Profile"> | string
    userId?: UuidWithAggregatesFilter<"Profile"> | string
    firstName?: StringWithAggregatesFilter<"Profile"> | string
    lastName?: StringWithAggregatesFilter<"Profile"> | string
    username?: StringWithAggregatesFilter<"Profile"> | string
    gender?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    country?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    city?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    district?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    location?: StringWithAggregatesFilter<"Profile"> | string
    bio?: StringWithAggregatesFilter<"Profile"> | string
    countryCode?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    coverUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lineageMainSurname?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    lineageRootVillage?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Profile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type ProfileSettingsWhereInput = {
    AND?: ProfileSettingsWhereInput | ProfileSettingsWhereInput[]
    OR?: ProfileSettingsWhereInput[]
    NOT?: ProfileSettingsWhereInput | ProfileSettingsWhereInput[]
    profileId?: UuidFilter<"ProfileSettings"> | string
    isPrivate?: BoolFilter<"ProfileSettings"> | boolean
    showLastSeen?: BoolFilter<"ProfileSettings"> | boolean
    allowTagging?: BoolFilter<"ProfileSettings"> | boolean
    allowMessagesFrom?: StringFilter<"ProfileSettings"> | string
    discoveryAllowLineage?: BoolFilter<"ProfileSettings"> | boolean
    createdAt?: DateTimeFilter<"ProfileSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileSettings"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ProfileSettingsOrderByWithRelationInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type ProfileSettingsWhereUniqueInput = Prisma.AtLeast<{
    profileId?: string
    AND?: ProfileSettingsWhereInput | ProfileSettingsWhereInput[]
    OR?: ProfileSettingsWhereInput[]
    NOT?: ProfileSettingsWhereInput | ProfileSettingsWhereInput[]
    isPrivate?: BoolFilter<"ProfileSettings"> | boolean
    showLastSeen?: BoolFilter<"ProfileSettings"> | boolean
    allowTagging?: BoolFilter<"ProfileSettings"> | boolean
    allowMessagesFrom?: StringFilter<"ProfileSettings"> | string
    discoveryAllowLineage?: BoolFilter<"ProfileSettings"> | boolean
    createdAt?: DateTimeFilter<"ProfileSettings"> | Date | string
    updatedAt?: DateTimeFilter<"ProfileSettings"> | Date | string
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "profileId">

  export type ProfileSettingsOrderByWithAggregationInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileSettingsCountOrderByAggregateInput
    _max?: ProfileSettingsMaxOrderByAggregateInput
    _min?: ProfileSettingsMinOrderByAggregateInput
  }

  export type ProfileSettingsScalarWhereWithAggregatesInput = {
    AND?: ProfileSettingsScalarWhereWithAggregatesInput | ProfileSettingsScalarWhereWithAggregatesInput[]
    OR?: ProfileSettingsScalarWhereWithAggregatesInput[]
    NOT?: ProfileSettingsScalarWhereWithAggregatesInput | ProfileSettingsScalarWhereWithAggregatesInput[]
    profileId?: UuidWithAggregatesFilter<"ProfileSettings"> | string
    isPrivate?: BoolWithAggregatesFilter<"ProfileSettings"> | boolean
    showLastSeen?: BoolWithAggregatesFilter<"ProfileSettings"> | boolean
    allowTagging?: BoolWithAggregatesFilter<"ProfileSettings"> | boolean
    allowMessagesFrom?: StringWithAggregatesFilter<"ProfileSettings"> | string
    discoveryAllowLineage?: BoolWithAggregatesFilter<"ProfileSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProfileSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProfileSettings"> | Date | string
  }

  export type LineageWhereInput = {
    AND?: LineageWhereInput | LineageWhereInput[]
    OR?: LineageWhereInput[]
    NOT?: LineageWhereInput | LineageWhereInput[]
    id?: UuidFilter<"Lineage"> | string
    name?: StringFilter<"Lineage"> | string
    type?: EnumLineageTypeFilter<"Lineage"> | $Enums.LineageType
    primarySurname?: StringNullableFilter<"Lineage"> | string | null
    rootVillage?: StringNullableFilter<"Lineage"> | string | null
    rootRegion?: StringNullableFilter<"Lineage"> | string | null
    description?: StringNullableFilter<"Lineage"> | string | null
    createdById?: UuidNullableFilter<"Lineage"> | string | null
    createdAt?: DateTimeFilter<"Lineage"> | Date | string
    updatedAt?: DateTimeFilter<"Lineage"> | Date | string
    createdBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    memberships?: LineageMembershipListRelationFilter
    posts?: PostListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type LineageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrderInput | SortOrder
    rootVillage?: SortOrderInput | SortOrder
    rootRegion?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: ProfileOrderByWithRelationInput
    memberships?: LineageMembershipOrderByRelationAggregateInput
    posts?: PostOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type LineageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LineageWhereInput | LineageWhereInput[]
    OR?: LineageWhereInput[]
    NOT?: LineageWhereInput | LineageWhereInput[]
    name?: StringFilter<"Lineage"> | string
    type?: EnumLineageTypeFilter<"Lineage"> | $Enums.LineageType
    primarySurname?: StringNullableFilter<"Lineage"> | string | null
    rootVillage?: StringNullableFilter<"Lineage"> | string | null
    rootRegion?: StringNullableFilter<"Lineage"> | string | null
    description?: StringNullableFilter<"Lineage"> | string | null
    createdById?: UuidNullableFilter<"Lineage"> | string | null
    createdAt?: DateTimeFilter<"Lineage"> | Date | string
    updatedAt?: DateTimeFilter<"Lineage"> | Date | string
    createdBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    memberships?: LineageMembershipListRelationFilter
    posts?: PostListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type LineageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrderInput | SortOrder
    rootVillage?: SortOrderInput | SortOrder
    rootRegion?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LineageCountOrderByAggregateInput
    _max?: LineageMaxOrderByAggregateInput
    _min?: LineageMinOrderByAggregateInput
  }

  export type LineageScalarWhereWithAggregatesInput = {
    AND?: LineageScalarWhereWithAggregatesInput | LineageScalarWhereWithAggregatesInput[]
    OR?: LineageScalarWhereWithAggregatesInput[]
    NOT?: LineageScalarWhereWithAggregatesInput | LineageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Lineage"> | string
    name?: StringWithAggregatesFilter<"Lineage"> | string
    type?: EnumLineageTypeWithAggregatesFilter<"Lineage"> | $Enums.LineageType
    primarySurname?: StringNullableWithAggregatesFilter<"Lineage"> | string | null
    rootVillage?: StringNullableWithAggregatesFilter<"Lineage"> | string | null
    rootRegion?: StringNullableWithAggregatesFilter<"Lineage"> | string | null
    description?: StringNullableWithAggregatesFilter<"Lineage"> | string | null
    createdById?: UuidNullableWithAggregatesFilter<"Lineage"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lineage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lineage"> | Date | string
  }

  export type LineageMembershipWhereInput = {
    AND?: LineageMembershipWhereInput | LineageMembershipWhereInput[]
    OR?: LineageMembershipWhereInput[]
    NOT?: LineageMembershipWhereInput | LineageMembershipWhereInput[]
    id?: UuidFilter<"LineageMembership"> | string
    lineageId?: UuidFilter<"LineageMembership"> | string
    profileId?: UuidFilter<"LineageMembership"> | string
    role?: EnumLineageRoleFilter<"LineageMembership"> | $Enums.LineageRole
    generation?: IntNullableFilter<"LineageMembership"> | number | null
    isPrimaryLineage?: BoolFilter<"LineageMembership"> | boolean
    addedById?: UuidNullableFilter<"LineageMembership"> | string | null
    createdAt?: DateTimeFilter<"LineageMembership"> | Date | string
    lineage?: XOR<LineageScalarRelationFilter, LineageWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    addedBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }

  export type LineageMembershipOrderByWithRelationInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrderInput | SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    lineage?: LineageOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    addedBy?: ProfileOrderByWithRelationInput
  }

  export type LineageMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    lineageId_profileId?: LineageMembershipLineageIdProfileIdCompoundUniqueInput
    AND?: LineageMembershipWhereInput | LineageMembershipWhereInput[]
    OR?: LineageMembershipWhereInput[]
    NOT?: LineageMembershipWhereInput | LineageMembershipWhereInput[]
    lineageId?: UuidFilter<"LineageMembership"> | string
    profileId?: UuidFilter<"LineageMembership"> | string
    role?: EnumLineageRoleFilter<"LineageMembership"> | $Enums.LineageRole
    generation?: IntNullableFilter<"LineageMembership"> | number | null
    isPrimaryLineage?: BoolFilter<"LineageMembership"> | boolean
    addedById?: UuidNullableFilter<"LineageMembership"> | string | null
    createdAt?: DateTimeFilter<"LineageMembership"> | Date | string
    lineage?: XOR<LineageScalarRelationFilter, LineageWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    addedBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }, "id" | "lineageId_profileId">

  export type LineageMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrderInput | SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LineageMembershipCountOrderByAggregateInput
    _avg?: LineageMembershipAvgOrderByAggregateInput
    _max?: LineageMembershipMaxOrderByAggregateInput
    _min?: LineageMembershipMinOrderByAggregateInput
    _sum?: LineageMembershipSumOrderByAggregateInput
  }

  export type LineageMembershipScalarWhereWithAggregatesInput = {
    AND?: LineageMembershipScalarWhereWithAggregatesInput | LineageMembershipScalarWhereWithAggregatesInput[]
    OR?: LineageMembershipScalarWhereWithAggregatesInput[]
    NOT?: LineageMembershipScalarWhereWithAggregatesInput | LineageMembershipScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"LineageMembership"> | string
    lineageId?: UuidWithAggregatesFilter<"LineageMembership"> | string
    profileId?: UuidWithAggregatesFilter<"LineageMembership"> | string
    role?: EnumLineageRoleWithAggregatesFilter<"LineageMembership"> | $Enums.LineageRole
    generation?: IntNullableWithAggregatesFilter<"LineageMembership"> | number | null
    isPrimaryLineage?: BoolWithAggregatesFilter<"LineageMembership"> | boolean
    addedById?: UuidNullableWithAggregatesFilter<"LineageMembership"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LineageMembership"> | Date | string
  }

  export type KinshipWhereInput = {
    AND?: KinshipWhereInput | KinshipWhereInput[]
    OR?: KinshipWhereInput[]
    NOT?: KinshipWhereInput | KinshipWhereInput[]
    id?: UuidFilter<"Kinship"> | string
    profileIdA?: UuidFilter<"Kinship"> | string
    profileIdB?: UuidFilter<"Kinship"> | string
    relationAtoB?: EnumKinshipTypeFilter<"Kinship"> | $Enums.KinshipType
    verified?: BoolFilter<"Kinship"> | boolean
    verifiedById?: UuidNullableFilter<"Kinship"> | string | null
    createdAt?: DateTimeFilter<"Kinship"> | Date | string
    profileA?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    profileB?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type KinshipOrderByWithRelationInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    profileA?: ProfileOrderByWithRelationInput
    profileB?: ProfileOrderByWithRelationInput
  }

  export type KinshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    profileIdA_profileIdB_relationAtoB?: KinshipProfileIdAProfileIdBRelationAtoBCompoundUniqueInput
    AND?: KinshipWhereInput | KinshipWhereInput[]
    OR?: KinshipWhereInput[]
    NOT?: KinshipWhereInput | KinshipWhereInput[]
    profileIdA?: UuidFilter<"Kinship"> | string
    profileIdB?: UuidFilter<"Kinship"> | string
    relationAtoB?: EnumKinshipTypeFilter<"Kinship"> | $Enums.KinshipType
    verified?: BoolFilter<"Kinship"> | boolean
    verifiedById?: UuidNullableFilter<"Kinship"> | string | null
    createdAt?: DateTimeFilter<"Kinship"> | Date | string
    profileA?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    profileB?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "profileIdA_profileIdB_relationAtoB">

  export type KinshipOrderByWithAggregationInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: KinshipCountOrderByAggregateInput
    _max?: KinshipMaxOrderByAggregateInput
    _min?: KinshipMinOrderByAggregateInput
  }

  export type KinshipScalarWhereWithAggregatesInput = {
    AND?: KinshipScalarWhereWithAggregatesInput | KinshipScalarWhereWithAggregatesInput[]
    OR?: KinshipScalarWhereWithAggregatesInput[]
    NOT?: KinshipScalarWhereWithAggregatesInput | KinshipScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Kinship"> | string
    profileIdA?: UuidWithAggregatesFilter<"Kinship"> | string
    profileIdB?: UuidWithAggregatesFilter<"Kinship"> | string
    relationAtoB?: EnumKinshipTypeWithAggregatesFilter<"Kinship"> | $Enums.KinshipType
    verified?: BoolWithAggregatesFilter<"Kinship"> | boolean
    verifiedById?: UuidNullableWithAggregatesFilter<"Kinship"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Kinship"> | Date | string
  }

  export type FollowWhereInput = {
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    id?: UuidFilter<"Follow"> | string
    followerId?: UuidFilter<"Follow"> | string
    followeeId?: UuidFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    followee?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type FollowOrderByWithRelationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followeeId?: SortOrder
    createdAt?: SortOrder
    follower?: ProfileOrderByWithRelationInput
    followee?: ProfileOrderByWithRelationInput
  }

  export type FollowWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    followerId_followeeId?: FollowFollowerIdFolloweeIdCompoundUniqueInput
    AND?: FollowWhereInput | FollowWhereInput[]
    OR?: FollowWhereInput[]
    NOT?: FollowWhereInput | FollowWhereInput[]
    followerId?: UuidFilter<"Follow"> | string
    followeeId?: UuidFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
    follower?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    followee?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "followerId_followeeId">

  export type FollowOrderByWithAggregationInput = {
    id?: SortOrder
    followerId?: SortOrder
    followeeId?: SortOrder
    createdAt?: SortOrder
    _count?: FollowCountOrderByAggregateInput
    _max?: FollowMaxOrderByAggregateInput
    _min?: FollowMinOrderByAggregateInput
  }

  export type FollowScalarWhereWithAggregatesInput = {
    AND?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    OR?: FollowScalarWhereWithAggregatesInput[]
    NOT?: FollowScalarWhereWithAggregatesInput | FollowScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Follow"> | string
    followerId?: UuidWithAggregatesFilter<"Follow"> | string
    followeeId?: UuidWithAggregatesFilter<"Follow"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Follow"> | Date | string
  }

  export type BlockWhereInput = {
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    id?: UuidFilter<"Block"> | string
    blockerId?: UuidFilter<"Block"> | string
    blockedId?: UuidFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blocker?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    blocked?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type BlockOrderByWithRelationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
    blocker?: ProfileOrderByWithRelationInput
    blocked?: ProfileOrderByWithRelationInput
  }

  export type BlockWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    blockerId_blockedId?: BlockBlockerIdBlockedIdCompoundUniqueInput
    AND?: BlockWhereInput | BlockWhereInput[]
    OR?: BlockWhereInput[]
    NOT?: BlockWhereInput | BlockWhereInput[]
    blockerId?: UuidFilter<"Block"> | string
    blockedId?: UuidFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
    blocker?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    blocked?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "blockerId_blockedId">

  export type BlockOrderByWithAggregationInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
    _count?: BlockCountOrderByAggregateInput
    _max?: BlockMaxOrderByAggregateInput
    _min?: BlockMinOrderByAggregateInput
  }

  export type BlockScalarWhereWithAggregatesInput = {
    AND?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    OR?: BlockScalarWhereWithAggregatesInput[]
    NOT?: BlockScalarWhereWithAggregatesInput | BlockScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Block"> | string
    blockerId?: UuidWithAggregatesFilter<"Block"> | string
    blockedId?: UuidWithAggregatesFilter<"Block"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Block"> | Date | string
  }

  export type MuteWhereInput = {
    AND?: MuteWhereInput | MuteWhereInput[]
    OR?: MuteWhereInput[]
    NOT?: MuteWhereInput | MuteWhereInput[]
    id?: UuidFilter<"Mute"> | string
    muterId?: UuidFilter<"Mute"> | string
    mutedId?: UuidFilter<"Mute"> | string
    createdAt?: DateTimeFilter<"Mute"> | Date | string
    muter?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    muted?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type MuteOrderByWithRelationInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
    muter?: ProfileOrderByWithRelationInput
    muted?: ProfileOrderByWithRelationInput
  }

  export type MuteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    muterId_mutedId?: MuteMuterIdMutedIdCompoundUniqueInput
    AND?: MuteWhereInput | MuteWhereInput[]
    OR?: MuteWhereInput[]
    NOT?: MuteWhereInput | MuteWhereInput[]
    muterId?: UuidFilter<"Mute"> | string
    mutedId?: UuidFilter<"Mute"> | string
    createdAt?: DateTimeFilter<"Mute"> | Date | string
    muter?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    muted?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "muterId_mutedId">

  export type MuteOrderByWithAggregationInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
    _count?: MuteCountOrderByAggregateInput
    _max?: MuteMaxOrderByAggregateInput
    _min?: MuteMinOrderByAggregateInput
  }

  export type MuteScalarWhereWithAggregatesInput = {
    AND?: MuteScalarWhereWithAggregatesInput | MuteScalarWhereWithAggregatesInput[]
    OR?: MuteScalarWhereWithAggregatesInput[]
    NOT?: MuteScalarWhereWithAggregatesInput | MuteScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Mute"> | string
    muterId?: UuidWithAggregatesFilter<"Mute"> | string
    mutedId?: UuidWithAggregatesFilter<"Mute"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Mute"> | Date | string
  }

  export type PostWhereInput = {
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    id?: UuidFilter<"Post"> | string
    profileId?: UuidFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    locationText?: StringNullableFilter<"Post"> | string | null
    lineageId?: UuidNullableFilter<"Post"> | string | null
    commentCount?: IntFilter<"Post"> | number
    likeCount?: IntFilter<"Post"> | number
    shareCount?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    lineage?: XOR<LineageNullableScalarRelationFilter, LineageWhereInput> | null
    comments?: CommentListRelationFilter
    reactions?: PostReactionListRelationFilter
    mediaFiles?: MediaFileListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type PostOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrderInput | SortOrder
    visibility?: SortOrder
    locationText?: SortOrderInput | SortOrder
    lineageId?: SortOrderInput | SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: ProfileOrderByWithRelationInput
    lineage?: LineageOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    reactions?: PostReactionOrderByRelationAggregateInput
    mediaFiles?: MediaFileOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type PostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PostWhereInput | PostWhereInput[]
    OR?: PostWhereInput[]
    NOT?: PostWhereInput | PostWhereInput[]
    profileId?: UuidFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    locationText?: StringNullableFilter<"Post"> | string | null
    lineageId?: UuidNullableFilter<"Post"> | string | null
    commentCount?: IntFilter<"Post"> | number
    likeCount?: IntFilter<"Post"> | number
    shareCount?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
    author?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    lineage?: XOR<LineageNullableScalarRelationFilter, LineageWhereInput> | null
    comments?: CommentListRelationFilter
    reactions?: PostReactionListRelationFilter
    mediaFiles?: MediaFileListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type PostOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrderInput | SortOrder
    visibility?: SortOrder
    locationText?: SortOrderInput | SortOrder
    lineageId?: SortOrderInput | SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PostCountOrderByAggregateInput
    _avg?: PostAvgOrderByAggregateInput
    _max?: PostMaxOrderByAggregateInput
    _min?: PostMinOrderByAggregateInput
    _sum?: PostSumOrderByAggregateInput
  }

  export type PostScalarWhereWithAggregatesInput = {
    AND?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    OR?: PostScalarWhereWithAggregatesInput[]
    NOT?: PostScalarWhereWithAggregatesInput | PostScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Post"> | string
    profileId?: UuidWithAggregatesFilter<"Post"> | string
    content?: StringNullableWithAggregatesFilter<"Post"> | string | null
    visibility?: EnumPostVisibilityWithAggregatesFilter<"Post"> | $Enums.PostVisibility
    locationText?: StringNullableWithAggregatesFilter<"Post"> | string | null
    lineageId?: UuidNullableWithAggregatesFilter<"Post"> | string | null
    commentCount?: IntWithAggregatesFilter<"Post"> | number
    likeCount?: IntWithAggregatesFilter<"Post"> | number
    shareCount?: IntWithAggregatesFilter<"Post"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Post"> | Date | string
  }

  export type MediaFileWhereInput = {
    AND?: MediaFileWhereInput | MediaFileWhereInput[]
    OR?: MediaFileWhereInput[]
    NOT?: MediaFileWhereInput | MediaFileWhereInput[]
    id?: UuidFilter<"MediaFile"> | string
    postId?: UuidFilter<"MediaFile"> | string
    type?: EnumMediaTypeFilter<"MediaFile"> | $Enums.MediaType
    url?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    width?: IntNullableFilter<"MediaFile"> | number | null
    height?: IntNullableFilter<"MediaFile"> | number | null
    sizeBytes?: BigIntFilter<"MediaFile"> | bigint | number
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    updatedAt?: DateTimeFilter<"MediaFile"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }

  export type MediaFileOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: PostOrderByWithRelationInput
  }

  export type MediaFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaFileWhereInput | MediaFileWhereInput[]
    OR?: MediaFileWhereInput[]
    NOT?: MediaFileWhereInput | MediaFileWhereInput[]
    postId?: UuidFilter<"MediaFile"> | string
    type?: EnumMediaTypeFilter<"MediaFile"> | $Enums.MediaType
    url?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    width?: IntNullableFilter<"MediaFile"> | number | null
    height?: IntNullableFilter<"MediaFile"> | number | null
    sizeBytes?: BigIntFilter<"MediaFile"> | bigint | number
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    updatedAt?: DateTimeFilter<"MediaFile"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
  }, "id">

  export type MediaFileOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaFileCountOrderByAggregateInput
    _avg?: MediaFileAvgOrderByAggregateInput
    _max?: MediaFileMaxOrderByAggregateInput
    _min?: MediaFileMinOrderByAggregateInput
    _sum?: MediaFileSumOrderByAggregateInput
  }

  export type MediaFileScalarWhereWithAggregatesInput = {
    AND?: MediaFileScalarWhereWithAggregatesInput | MediaFileScalarWhereWithAggregatesInput[]
    OR?: MediaFileScalarWhereWithAggregatesInput[]
    NOT?: MediaFileScalarWhereWithAggregatesInput | MediaFileScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MediaFile"> | string
    postId?: UuidWithAggregatesFilter<"MediaFile"> | string
    type?: EnumMediaTypeWithAggregatesFilter<"MediaFile"> | $Enums.MediaType
    url?: StringWithAggregatesFilter<"MediaFile"> | string
    mimeType?: StringWithAggregatesFilter<"MediaFile"> | string
    width?: IntNullableWithAggregatesFilter<"MediaFile"> | number | null
    height?: IntNullableWithAggregatesFilter<"MediaFile"> | number | null
    sizeBytes?: BigIntWithAggregatesFilter<"MediaFile"> | bigint | number
    createdAt?: DateTimeWithAggregatesFilter<"MediaFile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MediaFile"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: UuidFilter<"Comment"> | string
    postId?: UuidFilter<"Comment"> | string
    profileId?: UuidFilter<"Comment"> | string
    parentCommentId?: UuidNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    likeCount?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    parentComment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    reactions?: CommentReactionListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
    author?: ProfileOrderByWithRelationInput
    parentComment?: CommentOrderByWithRelationInput
    replies?: CommentOrderByRelationAggregateInput
    reactions?: CommentReactionOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: UuidFilter<"Comment"> | string
    profileId?: UuidFilter<"Comment"> | string
    parentCommentId?: UuidNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    likeCount?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    author?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    parentComment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    replies?: CommentListRelationFilter
    reactions?: CommentReactionListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _avg?: CommentAvgOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
    _sum?: CommentSumOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Comment"> | string
    postId?: UuidWithAggregatesFilter<"Comment"> | string
    profileId?: UuidWithAggregatesFilter<"Comment"> | string
    parentCommentId?: UuidNullableWithAggregatesFilter<"Comment"> | string | null
    content?: StringWithAggregatesFilter<"Comment"> | string
    likeCount?: IntWithAggregatesFilter<"Comment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type PostReactionWhereInput = {
    AND?: PostReactionWhereInput | PostReactionWhereInput[]
    OR?: PostReactionWhereInput[]
    NOT?: PostReactionWhereInput | PostReactionWhereInput[]
    id?: UuidFilter<"PostReaction"> | string
    postId?: UuidFilter<"PostReaction"> | string
    profileId?: UuidFilter<"PostReaction"> | string
    type?: EnumReactionTypeFilter<"PostReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"PostReaction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type PostReactionOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    post?: PostOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type PostReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    postId_profileId?: PostReactionPostIdProfileIdCompoundUniqueInput
    AND?: PostReactionWhereInput | PostReactionWhereInput[]
    OR?: PostReactionWhereInput[]
    NOT?: PostReactionWhereInput | PostReactionWhereInput[]
    postId?: UuidFilter<"PostReaction"> | string
    profileId?: UuidFilter<"PostReaction"> | string
    type?: EnumReactionTypeFilter<"PostReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"PostReaction"> | Date | string
    post?: XOR<PostScalarRelationFilter, PostWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "postId_profileId">

  export type PostReactionOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: PostReactionCountOrderByAggregateInput
    _max?: PostReactionMaxOrderByAggregateInput
    _min?: PostReactionMinOrderByAggregateInput
  }

  export type PostReactionScalarWhereWithAggregatesInput = {
    AND?: PostReactionScalarWhereWithAggregatesInput | PostReactionScalarWhereWithAggregatesInput[]
    OR?: PostReactionScalarWhereWithAggregatesInput[]
    NOT?: PostReactionScalarWhereWithAggregatesInput | PostReactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PostReaction"> | string
    postId?: UuidWithAggregatesFilter<"PostReaction"> | string
    profileId?: UuidWithAggregatesFilter<"PostReaction"> | string
    type?: EnumReactionTypeWithAggregatesFilter<"PostReaction"> | $Enums.ReactionType
    createdAt?: DateTimeWithAggregatesFilter<"PostReaction"> | Date | string
  }

  export type CommentReactionWhereInput = {
    AND?: CommentReactionWhereInput | CommentReactionWhereInput[]
    OR?: CommentReactionWhereInput[]
    NOT?: CommentReactionWhereInput | CommentReactionWhereInput[]
    id?: UuidFilter<"CommentReaction"> | string
    commentId?: UuidFilter<"CommentReaction"> | string
    profileId?: UuidFilter<"CommentReaction"> | string
    type?: EnumReactionTypeFilter<"CommentReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"CommentReaction"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type CommentReactionOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    comment?: CommentOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type CommentReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    commentId_profileId?: CommentReactionCommentIdProfileIdCompoundUniqueInput
    AND?: CommentReactionWhereInput | CommentReactionWhereInput[]
    OR?: CommentReactionWhereInput[]
    NOT?: CommentReactionWhereInput | CommentReactionWhereInput[]
    commentId?: UuidFilter<"CommentReaction"> | string
    profileId?: UuidFilter<"CommentReaction"> | string
    type?: EnumReactionTypeFilter<"CommentReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"CommentReaction"> | Date | string
    comment?: XOR<CommentScalarRelationFilter, CommentWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "commentId_profileId">

  export type CommentReactionOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: CommentReactionCountOrderByAggregateInput
    _max?: CommentReactionMaxOrderByAggregateInput
    _min?: CommentReactionMinOrderByAggregateInput
  }

  export type CommentReactionScalarWhereWithAggregatesInput = {
    AND?: CommentReactionScalarWhereWithAggregatesInput | CommentReactionScalarWhereWithAggregatesInput[]
    OR?: CommentReactionScalarWhereWithAggregatesInput[]
    NOT?: CommentReactionScalarWhereWithAggregatesInput | CommentReactionScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CommentReaction"> | string
    commentId?: UuidWithAggregatesFilter<"CommentReaction"> | string
    profileId?: UuidWithAggregatesFilter<"CommentReaction"> | string
    type?: EnumReactionTypeWithAggregatesFilter<"CommentReaction"> | $Enums.ReactionType
    createdAt?: DateTimeWithAggregatesFilter<"CommentReaction"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: UuidFilter<"Conversation"> | string
    isGroup?: BoolFilter<"Conversation"> | boolean
    title?: StringNullableFilter<"Conversation"> | string | null
    createdById?: UuidNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    createdBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    createdBy?: ProfileOrderByWithRelationInput
    participants?: ConversationParticipantOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    isGroup?: BoolFilter<"Conversation"> | boolean
    title?: StringNullableFilter<"Conversation"> | string | null
    createdById?: UuidNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    createdBy?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    participants?: ConversationParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrderInput | SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Conversation"> | string
    isGroup?: BoolWithAggregatesFilter<"Conversation"> | boolean
    title?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdById?: UuidNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantWhereInput = {
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    id?: UuidFilter<"ConversationParticipant"> | string
    conversationId?: UuidFilter<"ConversationParticipant"> | string
    profileId?: UuidFilter<"ConversationParticipant"> | string
    role?: StringFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type ConversationParticipantOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type ConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_profileId?: ConversationParticipantConversationIdProfileIdCompoundUniqueInput
    AND?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    OR?: ConversationParticipantWhereInput[]
    NOT?: ConversationParticipantWhereInput | ConversationParticipantWhereInput[]
    conversationId?: UuidFilter<"ConversationParticipant"> | string
    profileId?: UuidFilter<"ConversationParticipant"> | string
    role?: StringFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "conversationId_profileId">

  export type ConversationParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrderInput | SortOrder
    joinedAt?: SortOrder
    _count?: ConversationParticipantCountOrderByAggregateInput
    _max?: ConversationParticipantMaxOrderByAggregateInput
    _min?: ConversationParticipantMinOrderByAggregateInput
  }

  export type ConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: ConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: ConversationParticipantScalarWhereWithAggregatesInput | ConversationParticipantScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ConversationParticipant"> | string
    conversationId?: UuidWithAggregatesFilter<"ConversationParticipant"> | string
    profileId?: UuidWithAggregatesFilter<"ConversationParticipant"> | string
    role?: StringWithAggregatesFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeNullableWithAggregatesFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeWithAggregatesFilter<"ConversationParticipant"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: UuidFilter<"Message"> | string
    conversationId?: UuidFilter<"Message"> | string
    senderId?: UuidFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    timestamp?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    reads?: MessageReadListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
    sender?: ProfileOrderByWithRelationInput
    reads?: MessageReadOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: UuidFilter<"Message"> | string
    senderId?: UuidFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    timestamp?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
    sender?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    reads?: MessageReadListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrderInput | SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Message"> | string
    conversationId?: UuidWithAggregatesFilter<"Message"> | string
    senderId?: UuidWithAggregatesFilter<"Message"> | string
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    mediaUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    timestamp?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: UuidFilter<"Notification"> | string
    recipientId?: UuidFilter<"Notification"> | string
    actorId?: UuidNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    postId?: UuidNullableFilter<"Notification"> | string | null
    commentId?: UuidNullableFilter<"Notification"> | string | null
    lineageId?: UuidNullableFilter<"Notification"> | string | null
    messageId?: UuidNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    actor?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    lineage?: XOR<LineageNullableScalarRelationFilter, LineageWhereInput> | null
    message?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrderInput | SortOrder
    type?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    lineageId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    recipient?: ProfileOrderByWithRelationInput
    actor?: ProfileOrderByWithRelationInput
    post?: PostOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
    lineage?: LineageOrderByWithRelationInput
    message?: MessageOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    recipientId?: UuidFilter<"Notification"> | string
    actorId?: UuidNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    postId?: UuidNullableFilter<"Notification"> | string | null
    commentId?: UuidNullableFilter<"Notification"> | string | null
    lineageId?: UuidNullableFilter<"Notification"> | string | null
    messageId?: UuidNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    actor?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    post?: XOR<PostNullableScalarRelationFilter, PostWhereInput> | null
    comment?: XOR<CommentNullableScalarRelationFilter, CommentWhereInput> | null
    lineage?: XOR<LineageNullableScalarRelationFilter, LineageWhereInput> | null
    message?: XOR<MessageNullableScalarRelationFilter, MessageWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrderInput | SortOrder
    type?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    lineageId?: SortOrderInput | SortOrder
    messageId?: SortOrderInput | SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Notification"> | string
    recipientId?: UuidWithAggregatesFilter<"Notification"> | string
    actorId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    postId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    commentId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    lineageId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    messageId?: UuidNullableWithAggregatesFilter<"Notification"> | string | null
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type InterestWhereInput = {
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    id?: UuidFilter<"Interest"> | string
    name?: StringFilter<"Interest"> | string
    users?: ProfileInterestListRelationFilter
  }

  export type InterestOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    users?: ProfileInterestOrderByRelationAggregateInput
  }

  export type InterestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: InterestWhereInput | InterestWhereInput[]
    OR?: InterestWhereInput[]
    NOT?: InterestWhereInput | InterestWhereInput[]
    users?: ProfileInterestListRelationFilter
  }, "id" | "name">

  export type InterestOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: InterestCountOrderByAggregateInput
    _max?: InterestMaxOrderByAggregateInput
    _min?: InterestMinOrderByAggregateInput
  }

  export type InterestScalarWhereWithAggregatesInput = {
    AND?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    OR?: InterestScalarWhereWithAggregatesInput[]
    NOT?: InterestScalarWhereWithAggregatesInput | InterestScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Interest"> | string
    name?: StringWithAggregatesFilter<"Interest"> | string
  }

  export type ProfileInterestWhereInput = {
    AND?: ProfileInterestWhereInput | ProfileInterestWhereInput[]
    OR?: ProfileInterestWhereInput[]
    NOT?: ProfileInterestWhereInput | ProfileInterestWhereInput[]
    userId?: UuidFilter<"ProfileInterest"> | string
    interestId?: UuidFilter<"ProfileInterest"> | string
    createdAt?: DateTimeFilter<"ProfileInterest"> | Date | string
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    interest?: XOR<InterestScalarRelationFilter, InterestWhereInput>
  }

  export type ProfileInterestOrderByWithRelationInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
    user?: ProfileOrderByWithRelationInput
    interest?: InterestOrderByWithRelationInput
  }

  export type ProfileInterestWhereUniqueInput = Prisma.AtLeast<{
    userId_interestId?: ProfileInterestUserIdInterestIdCompoundUniqueInput
    AND?: ProfileInterestWhereInput | ProfileInterestWhereInput[]
    OR?: ProfileInterestWhereInput[]
    NOT?: ProfileInterestWhereInput | ProfileInterestWhereInput[]
    userId?: UuidFilter<"ProfileInterest"> | string
    interestId?: UuidFilter<"ProfileInterest"> | string
    createdAt?: DateTimeFilter<"ProfileInterest"> | Date | string
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    interest?: XOR<InterestScalarRelationFilter, InterestWhereInput>
  }, "userId_interestId">

  export type ProfileInterestOrderByWithAggregationInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
    _count?: ProfileInterestCountOrderByAggregateInput
    _max?: ProfileInterestMaxOrderByAggregateInput
    _min?: ProfileInterestMinOrderByAggregateInput
  }

  export type ProfileInterestScalarWhereWithAggregatesInput = {
    AND?: ProfileInterestScalarWhereWithAggregatesInput | ProfileInterestScalarWhereWithAggregatesInput[]
    OR?: ProfileInterestScalarWhereWithAggregatesInput[]
    NOT?: ProfileInterestScalarWhereWithAggregatesInput | ProfileInterestScalarWhereWithAggregatesInput[]
    userId?: UuidWithAggregatesFilter<"ProfileInterest"> | string
    interestId?: UuidWithAggregatesFilter<"ProfileInterest"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProfileInterest"> | Date | string
  }

  export type MessageReadWhereInput = {
    AND?: MessageReadWhereInput | MessageReadWhereInput[]
    OR?: MessageReadWhereInput[]
    NOT?: MessageReadWhereInput | MessageReadWhereInput[]
    messageId?: UuidFilter<"MessageRead"> | string
    userId?: UuidFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type MessageReadOrderByWithRelationInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    message?: MessageOrderByWithRelationInput
    user?: ProfileOrderByWithRelationInput
  }

  export type MessageReadWhereUniqueInput = Prisma.AtLeast<{
    messageId_userId?: MessageReadMessageIdUserIdCompoundUniqueInput
    AND?: MessageReadWhereInput | MessageReadWhereInput[]
    OR?: MessageReadWhereInput[]
    NOT?: MessageReadWhereInput | MessageReadWhereInput[]
    messageId?: UuidFilter<"MessageRead"> | string
    userId?: UuidFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "messageId_userId">

  export type MessageReadOrderByWithAggregationInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
    _count?: MessageReadCountOrderByAggregateInput
    _max?: MessageReadMaxOrderByAggregateInput
    _min?: MessageReadMinOrderByAggregateInput
  }

  export type MessageReadScalarWhereWithAggregatesInput = {
    AND?: MessageReadScalarWhereWithAggregatesInput | MessageReadScalarWhereWithAggregatesInput[]
    OR?: MessageReadScalarWhereWithAggregatesInput[]
    NOT?: MessageReadScalarWhereWithAggregatesInput | MessageReadScalarWhereWithAggregatesInput[]
    messageId?: UuidWithAggregatesFilter<"MessageRead"> | string
    userId?: UuidWithAggregatesFilter<"MessageRead"> | string
    readAt?: DateTimeWithAggregatesFilter<"MessageRead"> | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileSettingsCreateInput = {
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutSettingsInput
  }

  export type ProfileSettingsUncheckedCreateInput = {
    profileId: string
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileSettingsUpdateInput = {
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type ProfileSettingsUncheckedUpdateInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileSettingsCreateManyInput = {
    profileId: string
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileSettingsUpdateManyMutationInput = {
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileSettingsUncheckedUpdateManyInput = {
    profileId?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageCreateInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutLineagesCreatedInput
    memberships?: LineageMembershipCreateNestedManyWithoutLineageInput
    posts?: PostCreateNestedManyWithoutLineageInput
    notifications?: NotificationCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipUncheckedCreateNestedManyWithoutLineageInput
    posts?: PostUncheckedCreateNestedManyWithoutLineageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutLineagesCreatedNestedInput
    memberships?: LineageMembershipUpdateManyWithoutLineageNestedInput
    posts?: PostUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput
    posts?: PostUncheckedUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type LineageCreateManyInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LineageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipCreateInput = {
    id?: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
    lineage: LineageCreateNestedOneWithoutMembershipsInput
    profile: ProfileCreateNestedOneWithoutLineageMembershipsInput
    addedBy?: ProfileCreateNestedOneWithoutLineageMembershipsAddedInput
  }

  export type LineageMembershipUncheckedCreateInput = {
    id?: string
    lineageId: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type LineageMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineage?: LineageUpdateOneRequiredWithoutMembershipsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutLineageMembershipsNestedInput
    addedBy?: ProfileUpdateOneWithoutLineageMembershipsAddedNestedInput
  }

  export type LineageMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipCreateManyInput = {
    id?: string
    lineageId: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type LineageMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipCreateInput = {
    id?: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
    profileA: ProfileCreateNestedOneWithoutKinshipsAInput
    profileB: ProfileCreateNestedOneWithoutKinshipsBInput
  }

  export type KinshipUncheckedCreateInput = {
    id?: string
    profileIdA: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileA?: ProfileUpdateOneRequiredWithoutKinshipsANestedInput
    profileB?: ProfileUpdateOneRequiredWithoutKinshipsBNestedInput
  }

  export type KinshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdA?: StringFieldUpdateOperationsInput | string
    profileIdB?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipCreateManyInput = {
    id?: string
    profileIdA: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdA?: StringFieldUpdateOperationsInput | string
    profileIdB?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateInput = {
    id?: string
    createdAt?: Date | string
    follower: ProfileCreateNestedOneWithoutFollowsAsFollowerInput
    followee: ProfileCreateNestedOneWithoutFollowsAsFolloweeInput
  }

  export type FollowUncheckedCreateInput = {
    id?: string
    followerId: string
    followeeId: string
    createdAt?: Date | string
  }

  export type FollowUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: ProfileUpdateOneRequiredWithoutFollowsAsFollowerNestedInput
    followee?: ProfileUpdateOneRequiredWithoutFollowsAsFolloweeNestedInput
  }

  export type FollowUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowCreateManyInput = {
    id?: string
    followerId: string
    followeeId: string
    createdAt?: Date | string
  }

  export type FollowUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    followeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateInput = {
    id?: string
    createdAt?: Date | string
    blocker: ProfileCreateNestedOneWithoutBlocksAsBlockerInput
    blocked: ProfileCreateNestedOneWithoutBlocksAsBlockedInput
  }

  export type BlockUncheckedCreateInput = {
    id?: string
    blockerId: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: ProfileUpdateOneRequiredWithoutBlocksAsBlockerNestedInput
    blocked?: ProfileUpdateOneRequiredWithoutBlocksAsBlockedNestedInput
  }

  export type BlockUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockCreateManyInput = {
    id?: string
    blockerId: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteCreateInput = {
    id?: string
    createdAt?: Date | string
    muter: ProfileCreateNestedOneWithoutMutesAsMuterInput
    muted: ProfileCreateNestedOneWithoutMutesAsMutedInput
  }

  export type MuteUncheckedCreateInput = {
    id?: string
    muterId: string
    mutedId: string
    createdAt?: Date | string
  }

  export type MuteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    muter?: ProfileUpdateOneRequiredWithoutMutesAsMuterNestedInput
    muted?: ProfileUpdateOneRequiredWithoutMutesAsMutedNestedInput
  }

  export type MuteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
    mutedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteCreateManyInput = {
    id?: string
    muterId: string
    mutedId: string
    createdAt?: Date | string
  }

  export type MuteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
    mutedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostCreateInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: ProfileCreateNestedOneWithoutPostsInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateManyInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileCreateInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
    post: PostCreateNestedOneWithoutMediaFilesInput
  }

  export type MediaFileUncheckedCreateInput = {
    id?: string
    postId: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutMediaFilesNestedInput
  }

  export type MediaFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileCreateManyInput = {
    id?: string
    postId: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionCreateInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutReactionsInput
    profile: ProfileCreateNestedOneWithoutPostReactionsInput
  }

  export type PostReactionUncheckedCreateInput = {
    id?: string
    postId: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type PostReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutReactionsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutPostReactionsNestedInput
  }

  export type PostReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionCreateManyInput = {
    id?: string
    postId: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type PostReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionCreateInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutReactionsInput
    profile: ProfileCreateNestedOneWithoutCommentReactionsInput
  }

  export type CommentReactionUncheckedCreateInput = {
    id?: string
    commentId: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutReactionsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutCommentReactionsNestedInput
  }

  export type CommentReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionCreateManyInput = {
    id?: string
    commentId: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutConversationsOwnedInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById?: string | null
    createdAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutConversationsOwnedNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById?: string | null
    createdAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateInput = {
    id?: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
    profile: ProfileCreateNestedOneWithoutConversationMembersInput
  }

  export type ConversationParticipantUncheckedCreateInput = {
    id?: string
    conversationId: string
    profileId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutConversationMembersNestedInput
  }

  export type ConversationParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyInput = {
    id?: string
    conversationId: string
    profileId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: ProfileCreateNestedOneWithoutMessagesInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
    notifications?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: ProfileUpdateOneRequiredWithoutMessagesNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
    actor?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
    actor?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InterestCreateInput = {
    id?: string
    name: string
    users?: ProfileInterestCreateNestedManyWithoutInterestInput
  }

  export type InterestUncheckedCreateInput = {
    id?: string
    name: string
    users?: ProfileInterestUncheckedCreateNestedManyWithoutInterestInput
  }

  export type InterestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: ProfileInterestUpdateManyWithoutInterestNestedInput
  }

  export type InterestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: ProfileInterestUncheckedUpdateManyWithoutInterestNestedInput
  }

  export type InterestCreateManyInput = {
    id?: string
    name: string
  }

  export type InterestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InterestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ProfileInterestCreateInput = {
    createdAt?: Date | string
    user: ProfileCreateNestedOneWithoutInterestsInput
    interest: InterestCreateNestedOneWithoutUsersInput
  }

  export type ProfileInterestUncheckedCreateInput = {
    userId: string
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileInterestUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ProfileUpdateOneRequiredWithoutInterestsNestedInput
    interest?: InterestUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ProfileInterestUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestCreateManyInput = {
    userId: string
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileInterestUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateInput = {
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadsInput
    user: ProfileCreateNestedOneWithoutMessageReadsInput
  }

  export type MessageReadUncheckedCreateInput = {
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUpdateInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadsNestedInput
    user?: ProfileUpdateOneRequiredWithoutMessageReadsNestedInput
  }

  export type MessageReadUncheckedUpdateInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateManyInput = {
    messageId: string
    userId: string
    readAt?: Date | string
  }

  export type MessageReadUpdateManyMutationInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileInterestListRelationFilter = {
    every?: ProfileInterestWhereInput
    some?: ProfileInterestWhereInput
    none?: ProfileInterestWhereInput
  }

  export type PostListRelationFilter = {
    every?: PostWhereInput
    some?: PostWhereInput
    none?: PostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageReadListRelationFilter = {
    every?: MessageReadWhereInput
    some?: MessageReadWhereInput
    none?: MessageReadWhereInput
  }

  export type PostReactionListRelationFilter = {
    every?: PostReactionWhereInput
    some?: PostReactionWhereInput
    none?: PostReactionWhereInput
  }

  export type ProfileSettingsNullableScalarRelationFilter = {
    is?: ProfileSettingsWhereInput | null
    isNot?: ProfileSettingsWhereInput | null
  }

  export type LineageMembershipListRelationFilter = {
    every?: LineageMembershipWhereInput
    some?: LineageMembershipWhereInput
    none?: LineageMembershipWhereInput
  }

  export type KinshipListRelationFilter = {
    every?: KinshipWhereInput
    some?: KinshipWhereInput
    none?: KinshipWhereInput
  }

  export type CommentReactionListRelationFilter = {
    every?: CommentReactionWhereInput
    some?: CommentReactionWhereInput
    none?: CommentReactionWhereInput
  }

  export type FollowListRelationFilter = {
    every?: FollowWhereInput
    some?: FollowWhereInput
    none?: FollowWhereInput
  }

  export type BlockListRelationFilter = {
    every?: BlockWhereInput
    some?: BlockWhereInput
    none?: BlockWhereInput
  }

  export type MuteListRelationFilter = {
    every?: MuteWhereInput
    some?: MuteWhereInput
    none?: MuteWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type ConversationParticipantListRelationFilter = {
    every?: ConversationParticipantWhereInput
    some?: ConversationParticipantWhereInput
    none?: ConversationParticipantWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type LineageListRelationFilter = {
    every?: LineageWhereInput
    some?: LineageWhereInput
    none?: LineageWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProfileInterestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageReadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LineageMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KinshipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FollowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MuteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LineageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    country?: SortOrder
    city?: SortOrder
    district?: SortOrder
    location?: SortOrder
    bio?: SortOrder
    countryCode?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    lineageMainSurname?: SortOrder
    lineageRootVillage?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    country?: SortOrder
    city?: SortOrder
    district?: SortOrder
    location?: SortOrder
    bio?: SortOrder
    countryCode?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    lineageMainSurname?: SortOrder
    lineageRootVillage?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    gender?: SortOrder
    dateOfBirth?: SortOrder
    country?: SortOrder
    city?: SortOrder
    district?: SortOrder
    location?: SortOrder
    bio?: SortOrder
    countryCode?: SortOrder
    avatarUrl?: SortOrder
    coverUrl?: SortOrder
    lineageMainSurname?: SortOrder
    lineageRootVillage?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type ProfileSettingsCountOrderByAggregateInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSettingsMaxOrderByAggregateInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSettingsMinOrderByAggregateInput = {
    profileId?: SortOrder
    isPrivate?: SortOrder
    showLastSeen?: SortOrder
    allowTagging?: SortOrder
    allowMessagesFrom?: SortOrder
    discoveryAllowLineage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLineageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageType | EnumLineageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageTypeFilter<$PrismaModel> | $Enums.LineageType
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type LineageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrder
    rootVillage?: SortOrder
    rootRegion?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LineageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrder
    rootVillage?: SortOrder
    rootRegion?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LineageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    primarySurname?: SortOrder
    rootVillage?: SortOrder
    rootRegion?: SortOrder
    description?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLineageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageType | EnumLineageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageTypeWithAggregatesFilter<$PrismaModel> | $Enums.LineageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLineageTypeFilter<$PrismaModel>
    _max?: NestedEnumLineageTypeFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumLineageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageRole | EnumLineageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageRoleFilter<$PrismaModel> | $Enums.LineageRole
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type LineageScalarRelationFilter = {
    is?: LineageWhereInput
    isNot?: LineageWhereInput
  }

  export type LineageMembershipLineageIdProfileIdCompoundUniqueInput = {
    lineageId: string
    profileId: string
  }

  export type LineageMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LineageMembershipAvgOrderByAggregateInput = {
    generation?: SortOrder
  }

  export type LineageMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LineageMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    lineageId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    generation?: SortOrder
    isPrimaryLineage?: SortOrder
    addedById?: SortOrder
    createdAt?: SortOrder
  }

  export type LineageMembershipSumOrderByAggregateInput = {
    generation?: SortOrder
  }

  export type EnumLineageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageRole | EnumLineageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageRoleWithAggregatesFilter<$PrismaModel> | $Enums.LineageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLineageRoleFilter<$PrismaModel>
    _max?: NestedEnumLineageRoleFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumKinshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KinshipType | EnumKinshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKinshipTypeFilter<$PrismaModel> | $Enums.KinshipType
  }

  export type KinshipProfileIdAProfileIdBRelationAtoBCompoundUniqueInput = {
    profileIdA: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
  }

  export type KinshipCountOrderByAggregateInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
  }

  export type KinshipMaxOrderByAggregateInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
  }

  export type KinshipMinOrderByAggregateInput = {
    id?: SortOrder
    profileIdA?: SortOrder
    profileIdB?: SortOrder
    relationAtoB?: SortOrder
    verified?: SortOrder
    verifiedById?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumKinshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KinshipType | EnumKinshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKinshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.KinshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKinshipTypeFilter<$PrismaModel>
    _max?: NestedEnumKinshipTypeFilter<$PrismaModel>
  }

  export type FollowFollowerIdFolloweeIdCompoundUniqueInput = {
    followerId: string
    followeeId: string
  }

  export type FollowCountOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followeeId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMaxOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followeeId?: SortOrder
    createdAt?: SortOrder
  }

  export type FollowMinOrderByAggregateInput = {
    id?: SortOrder
    followerId?: SortOrder
    followeeId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockBlockerIdBlockedIdCompoundUniqueInput = {
    blockerId: string
    blockedId: string
  }

  export type BlockCountOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMaxOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type BlockMinOrderByAggregateInput = {
    id?: SortOrder
    blockerId?: SortOrder
    blockedId?: SortOrder
    createdAt?: SortOrder
  }

  export type MuteMuterIdMutedIdCompoundUniqueInput = {
    muterId: string
    mutedId: string
  }

  export type MuteCountOrderByAggregateInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
  }

  export type MuteMaxOrderByAggregateInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
  }

  export type MuteMinOrderByAggregateInput = {
    id?: SortOrder
    muterId?: SortOrder
    mutedId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type LineageNullableScalarRelationFilter = {
    is?: LineageWhereInput | null
    isNot?: LineageWhereInput | null
  }

  export type MediaFileListRelationFilter = {
    every?: MediaFileWhereInput
    some?: MediaFileWhereInput
    none?: MediaFileWhereInput
  }

  export type MediaFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrder
    visibility?: SortOrder
    locationText?: SortOrder
    lineageId?: SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostAvgOrderByAggregateInput = {
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
  }

  export type PostMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrder
    visibility?: SortOrder
    locationText?: SortOrder
    lineageId?: SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    content?: SortOrder
    visibility?: SortOrder
    locationText?: SortOrder
    lineageId?: SortOrder
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PostSumOrderByAggregateInput = {
    commentCount?: SortOrder
    likeCount?: SortOrder
    shareCount?: SortOrder
  }

  export type EnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type PostScalarRelationFilter = {
    is?: PostWhereInput
    isNot?: PostWhereInput
  }

  export type MediaFileCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaFileAvgOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
  }

  export type MediaFileMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaFileMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    type?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaFileSumOrderByAggregateInput = {
    width?: SortOrder
    height?: SortOrder
    sizeBytes?: SortOrder
  }

  export type EnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type CommentNullableScalarRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentAvgOrderByAggregateInput = {
    likeCount?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    likeCount?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentSumOrderByAggregateInput = {
    likeCount?: SortOrder
  }

  export type EnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type PostReactionPostIdProfileIdCompoundUniqueInput = {
    postId: string
    profileId: string
  }

  export type PostReactionCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PostReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type PostReactionMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type CommentScalarRelationFilter = {
    is?: CommentWhereInput
    isNot?: CommentWhereInput
  }

  export type CommentReactionCommentIdProfileIdCompoundUniqueInput = {
    commentId: string
    profileId: string
  }

  export type CommentReactionCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type CommentReactionMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    profileId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    isGroup?: SortOrder
    title?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type ConversationParticipantConversationIdProfileIdCompoundUniqueInput = {
    conversationId: string
    profileId: string
  }

  export type ConversationParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type ConversationParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    profileId?: SortOrder
    role?: SortOrder
    lastReadAt?: SortOrder
    joinedAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    timestamp?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    mediaUrl?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
    timestamp?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type PostNullableScalarRelationFilter = {
    is?: PostWhereInput | null
    isNot?: PostWhereInput | null
  }

  export type MessageNullableScalarRelationFilter = {
    is?: MessageWhereInput | null
    isNot?: MessageWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    lineageId?: SortOrder
    messageId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    lineageId?: SortOrder
    messageId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    recipientId?: SortOrder
    actorId?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    lineageId?: SortOrder
    messageId?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type InterestCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type InterestMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type InterestMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type InterestScalarRelationFilter = {
    is?: InterestWhereInput
    isNot?: InterestWhereInput
  }

  export type ProfileInterestUserIdInterestIdCompoundUniqueInput = {
    userId: string
    interestId: string
  }

  export type ProfileInterestCountOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileInterestMaxOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
  }

  export type ProfileInterestMinOrderByAggregateInput = {
    userId?: SortOrder
    interestId?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageReadMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageReadCountOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadMaxOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type MessageReadMinOrderByAggregateInput = {
    messageId?: SortOrder
    userId?: SortOrder
    readAt?: SortOrder
  }

  export type ProfileInterestCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput> | ProfileInterestCreateWithoutUserInput[] | ProfileInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutUserInput | ProfileInterestCreateOrConnectWithoutUserInput[]
    createMany?: ProfileInterestCreateManyUserInputEnvelope
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageReadCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type PostReactionCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput> | PostReactionCreateWithoutProfileInput[] | PostReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutProfileInput | PostReactionCreateOrConnectWithoutProfileInput[]
    createMany?: PostReactionCreateManyProfileInputEnvelope
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
  }

  export type ProfileSettingsCreateNestedOneWithoutProfileInput = {
    create?: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileSettingsCreateOrConnectWithoutProfileInput
    connect?: ProfileSettingsWhereUniqueInput
  }

  export type LineageMembershipCreateNestedManyWithoutProfileInput = {
    create?: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput> | LineageMembershipCreateWithoutProfileInput[] | LineageMembershipUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutProfileInput | LineageMembershipCreateOrConnectWithoutProfileInput[]
    createMany?: LineageMembershipCreateManyProfileInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type KinshipCreateNestedManyWithoutProfileAInput = {
    create?: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput> | KinshipCreateWithoutProfileAInput[] | KinshipUncheckedCreateWithoutProfileAInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileAInput | KinshipCreateOrConnectWithoutProfileAInput[]
    createMany?: KinshipCreateManyProfileAInputEnvelope
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
  }

  export type KinshipCreateNestedManyWithoutProfileBInput = {
    create?: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput> | KinshipCreateWithoutProfileBInput[] | KinshipUncheckedCreateWithoutProfileBInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileBInput | KinshipCreateOrConnectWithoutProfileBInput[]
    createMany?: KinshipCreateManyProfileBInputEnvelope
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
  }

  export type CommentReactionCreateNestedManyWithoutProfileInput = {
    create?: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput> | CommentReactionCreateWithoutProfileInput[] | CommentReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutProfileInput | CommentReactionCreateOrConnectWithoutProfileInput[]
    createMany?: CommentReactionCreateManyProfileInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowCreateNestedManyWithoutFolloweeInput = {
    create?: XOR<FollowCreateWithoutFolloweeInput, FollowUncheckedCreateWithoutFolloweeInput> | FollowCreateWithoutFolloweeInput[] | FollowUncheckedCreateWithoutFolloweeInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFolloweeInput | FollowCreateOrConnectWithoutFolloweeInput[]
    createMany?: FollowCreateManyFolloweeInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type MuteCreateNestedManyWithoutMuterInput = {
    create?: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput> | MuteCreateWithoutMuterInput[] | MuteUncheckedCreateWithoutMuterInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMuterInput | MuteCreateOrConnectWithoutMuterInput[]
    createMany?: MuteCreateManyMuterInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type MuteCreateNestedManyWithoutMutedInput = {
    create?: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput> | MuteCreateWithoutMutedInput[] | MuteUncheckedCreateWithoutMutedInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMutedInput | MuteCreateOrConnectWithoutMutedInput[]
    createMany?: MuteCreateManyMutedInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationParticipantCreateNestedManyWithoutProfileInput = {
    create?: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput> | ConversationParticipantCreateWithoutProfileInput[] | ConversationParticipantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutProfileInput | ConversationParticipantCreateOrConnectWithoutProfileInput[]
    createMany?: ConversationParticipantCreateManyProfileInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutActorInput = {
    create?: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput> | NotificationCreateWithoutActorInput[] | NotificationUncheckedCreateWithoutActorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutActorInput | NotificationCreateOrConnectWithoutActorInput[]
    createMany?: NotificationCreateManyActorInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LineageCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput> | LineageCreateWithoutCreatedByInput[] | LineageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LineageCreateOrConnectWithoutCreatedByInput | LineageCreateOrConnectWithoutCreatedByInput[]
    createMany?: LineageCreateManyCreatedByInputEnvelope
    connect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
  }

  export type LineageMembershipCreateNestedManyWithoutAddedByInput = {
    create?: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput> | LineageMembershipCreateWithoutAddedByInput[] | LineageMembershipUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutAddedByInput | LineageMembershipCreateOrConnectWithoutAddedByInput[]
    createMany?: LineageMembershipCreateManyAddedByInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type ProfileInterestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput> | ProfileInterestCreateWithoutUserInput[] | ProfileInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutUserInput | ProfileInterestCreateOrConnectWithoutUserInput[]
    createMany?: ProfileInterestCreateManyUserInputEnvelope
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageReadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type PostReactionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput> | PostReactionCreateWithoutProfileInput[] | PostReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutProfileInput | PostReactionCreateOrConnectWithoutProfileInput[]
    createMany?: PostReactionCreateManyProfileInputEnvelope
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
  }

  export type ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileSettingsCreateOrConnectWithoutProfileInput
    connect?: ProfileSettingsWhereUniqueInput
  }

  export type LineageMembershipUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput> | LineageMembershipCreateWithoutProfileInput[] | LineageMembershipUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutProfileInput | LineageMembershipCreateOrConnectWithoutProfileInput[]
    createMany?: LineageMembershipCreateManyProfileInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type KinshipUncheckedCreateNestedManyWithoutProfileAInput = {
    create?: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput> | KinshipCreateWithoutProfileAInput[] | KinshipUncheckedCreateWithoutProfileAInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileAInput | KinshipCreateOrConnectWithoutProfileAInput[]
    createMany?: KinshipCreateManyProfileAInputEnvelope
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
  }

  export type KinshipUncheckedCreateNestedManyWithoutProfileBInput = {
    create?: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput> | KinshipCreateWithoutProfileBInput[] | KinshipUncheckedCreateWithoutProfileBInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileBInput | KinshipCreateOrConnectWithoutProfileBInput[]
    createMany?: KinshipCreateManyProfileBInputEnvelope
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
  }

  export type CommentReactionUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput> | CommentReactionCreateWithoutProfileInput[] | CommentReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutProfileInput | CommentReactionCreateOrConnectWithoutProfileInput[]
    createMany?: CommentReactionCreateManyProfileInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFollowerInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type FollowUncheckedCreateNestedManyWithoutFolloweeInput = {
    create?: XOR<FollowCreateWithoutFolloweeInput, FollowUncheckedCreateWithoutFolloweeInput> | FollowCreateWithoutFolloweeInput[] | FollowUncheckedCreateWithoutFolloweeInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFolloweeInput | FollowCreateOrConnectWithoutFolloweeInput[]
    createMany?: FollowCreateManyFolloweeInputEnvelope
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type BlockUncheckedCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
  }

  export type MuteUncheckedCreateNestedManyWithoutMuterInput = {
    create?: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput> | MuteCreateWithoutMuterInput[] | MuteUncheckedCreateWithoutMuterInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMuterInput | MuteCreateOrConnectWithoutMuterInput[]
    createMany?: MuteCreateManyMuterInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type MuteUncheckedCreateNestedManyWithoutMutedInput = {
    create?: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput> | MuteCreateWithoutMutedInput[] | MuteUncheckedCreateWithoutMutedInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMutedInput | MuteCreateOrConnectWithoutMutedInput[]
    createMany?: MuteCreateManyMutedInputEnvelope
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput> | ConversationParticipantCreateWithoutProfileInput[] | ConversationParticipantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutProfileInput | ConversationParticipantCreateOrConnectWithoutProfileInput[]
    createMany?: ConversationParticipantCreateManyProfileInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput> | NotificationCreateWithoutActorInput[] | NotificationUncheckedCreateWithoutActorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutActorInput | NotificationCreateOrConnectWithoutActorInput[]
    createMany?: NotificationCreateManyActorInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LineageUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput> | LineageCreateWithoutCreatedByInput[] | LineageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LineageCreateOrConnectWithoutCreatedByInput | LineageCreateOrConnectWithoutCreatedByInput[]
    createMany?: LineageCreateManyCreatedByInputEnvelope
    connect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
  }

  export type LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput = {
    create?: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput> | LineageMembershipCreateWithoutAddedByInput[] | LineageMembershipUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutAddedByInput | LineageMembershipCreateOrConnectWithoutAddedByInput[]
    createMany?: LineageMembershipCreateManyAddedByInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileInterestUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput> | ProfileInterestCreateWithoutUserInput[] | ProfileInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutUserInput | ProfileInterestCreateOrConnectWithoutUserInput[]
    upsert?: ProfileInterestUpsertWithWhereUniqueWithoutUserInput | ProfileInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileInterestCreateManyUserInputEnvelope
    set?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    disconnect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    delete?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    update?: ProfileInterestUpdateWithWhereUniqueWithoutUserInput | ProfileInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileInterestUpdateManyWithWhereWithoutUserInput | ProfileInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
  }

  export type PostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageReadUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutUserInput | MessageReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutUserInput | MessageReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutUserInput | MessageReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type PostReactionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput> | PostReactionCreateWithoutProfileInput[] | PostReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutProfileInput | PostReactionCreateOrConnectWithoutProfileInput[]
    upsert?: PostReactionUpsertWithWhereUniqueWithoutProfileInput | PostReactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostReactionCreateManyProfileInputEnvelope
    set?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    disconnect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    delete?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    update?: PostReactionUpdateWithWhereUniqueWithoutProfileInput | PostReactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostReactionUpdateManyWithWhereWithoutProfileInput | PostReactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
  }

  export type ProfileSettingsUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileSettingsCreateOrConnectWithoutProfileInput
    upsert?: ProfileSettingsUpsertWithoutProfileInput
    disconnect?: ProfileSettingsWhereInput | boolean
    delete?: ProfileSettingsWhereInput | boolean
    connect?: ProfileSettingsWhereUniqueInput
    update?: XOR<XOR<ProfileSettingsUpdateToOneWithWhereWithoutProfileInput, ProfileSettingsUpdateWithoutProfileInput>, ProfileSettingsUncheckedUpdateWithoutProfileInput>
  }

  export type LineageMembershipUpdateManyWithoutProfileNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput> | LineageMembershipCreateWithoutProfileInput[] | LineageMembershipUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutProfileInput | LineageMembershipCreateOrConnectWithoutProfileInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutProfileInput | LineageMembershipUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: LineageMembershipCreateManyProfileInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutProfileInput | LineageMembershipUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutProfileInput | LineageMembershipUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type KinshipUpdateManyWithoutProfileANestedInput = {
    create?: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput> | KinshipCreateWithoutProfileAInput[] | KinshipUncheckedCreateWithoutProfileAInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileAInput | KinshipCreateOrConnectWithoutProfileAInput[]
    upsert?: KinshipUpsertWithWhereUniqueWithoutProfileAInput | KinshipUpsertWithWhereUniqueWithoutProfileAInput[]
    createMany?: KinshipCreateManyProfileAInputEnvelope
    set?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    disconnect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    delete?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    update?: KinshipUpdateWithWhereUniqueWithoutProfileAInput | KinshipUpdateWithWhereUniqueWithoutProfileAInput[]
    updateMany?: KinshipUpdateManyWithWhereWithoutProfileAInput | KinshipUpdateManyWithWhereWithoutProfileAInput[]
    deleteMany?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
  }

  export type KinshipUpdateManyWithoutProfileBNestedInput = {
    create?: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput> | KinshipCreateWithoutProfileBInput[] | KinshipUncheckedCreateWithoutProfileBInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileBInput | KinshipCreateOrConnectWithoutProfileBInput[]
    upsert?: KinshipUpsertWithWhereUniqueWithoutProfileBInput | KinshipUpsertWithWhereUniqueWithoutProfileBInput[]
    createMany?: KinshipCreateManyProfileBInputEnvelope
    set?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    disconnect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    delete?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    update?: KinshipUpdateWithWhereUniqueWithoutProfileBInput | KinshipUpdateWithWhereUniqueWithoutProfileBInput[]
    updateMany?: KinshipUpdateManyWithWhereWithoutProfileBInput | KinshipUpdateManyWithWhereWithoutProfileBInput[]
    deleteMany?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
  }

  export type CommentReactionUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput> | CommentReactionCreateWithoutProfileInput[] | CommentReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutProfileInput | CommentReactionCreateOrConnectWithoutProfileInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutProfileInput | CommentReactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CommentReactionCreateManyProfileInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutProfileInput | CommentReactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutProfileInput | CommentReactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUpdateManyWithoutFolloweeNestedInput = {
    create?: XOR<FollowCreateWithoutFolloweeInput, FollowUncheckedCreateWithoutFolloweeInput> | FollowCreateWithoutFolloweeInput[] | FollowUncheckedCreateWithoutFolloweeInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFolloweeInput | FollowCreateOrConnectWithoutFolloweeInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFolloweeInput | FollowUpsertWithWhereUniqueWithoutFolloweeInput[]
    createMany?: FollowCreateManyFolloweeInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFolloweeInput | FollowUpdateWithWhereUniqueWithoutFolloweeInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFolloweeInput | FollowUpdateManyWithWhereWithoutFolloweeInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedInput | BlockUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedInput | BlockUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedInput | BlockUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type MuteUpdateManyWithoutMuterNestedInput = {
    create?: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput> | MuteCreateWithoutMuterInput[] | MuteUncheckedCreateWithoutMuterInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMuterInput | MuteCreateOrConnectWithoutMuterInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutMuterInput | MuteUpsertWithWhereUniqueWithoutMuterInput[]
    createMany?: MuteCreateManyMuterInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutMuterInput | MuteUpdateWithWhereUniqueWithoutMuterInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutMuterInput | MuteUpdateManyWithWhereWithoutMuterInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type MuteUpdateManyWithoutMutedNestedInput = {
    create?: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput> | MuteCreateWithoutMutedInput[] | MuteUncheckedCreateWithoutMutedInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMutedInput | MuteCreateOrConnectWithoutMutedInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutMutedInput | MuteUpsertWithWhereUniqueWithoutMutedInput[]
    createMany?: MuteCreateManyMutedInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutMutedInput | MuteUpdateWithWhereUniqueWithoutMutedInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutMutedInput | MuteUpdateManyWithWhereWithoutMutedInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutCreatedByInput | ConversationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutCreatedByInput | ConversationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutCreatedByInput | ConversationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationParticipantUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput> | ConversationParticipantCreateWithoutProfileInput[] | ConversationParticipantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutProfileInput | ConversationParticipantCreateOrConnectWithoutProfileInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput | ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ConversationParticipantCreateManyProfileInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput | ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutProfileInput | ConversationParticipantUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutActorNestedInput = {
    create?: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput> | NotificationCreateWithoutActorInput[] | NotificationUncheckedCreateWithoutActorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutActorInput | NotificationCreateOrConnectWithoutActorInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutActorInput | NotificationUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: NotificationCreateManyActorInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutActorInput | NotificationUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutActorInput | NotificationUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LineageUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput> | LineageCreateWithoutCreatedByInput[] | LineageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LineageCreateOrConnectWithoutCreatedByInput | LineageCreateOrConnectWithoutCreatedByInput[]
    upsert?: LineageUpsertWithWhereUniqueWithoutCreatedByInput | LineageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LineageCreateManyCreatedByInputEnvelope
    set?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    disconnect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    delete?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    connect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    update?: LineageUpdateWithWhereUniqueWithoutCreatedByInput | LineageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LineageUpdateManyWithWhereWithoutCreatedByInput | LineageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LineageScalarWhereInput | LineageScalarWhereInput[]
  }

  export type LineageMembershipUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput> | LineageMembershipCreateWithoutAddedByInput[] | LineageMembershipUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutAddedByInput | LineageMembershipCreateOrConnectWithoutAddedByInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput | LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: LineageMembershipCreateManyAddedByInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput | LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutAddedByInput | LineageMembershipUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type ProfileInterestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput> | ProfileInterestCreateWithoutUserInput[] | ProfileInterestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutUserInput | ProfileInterestCreateOrConnectWithoutUserInput[]
    upsert?: ProfileInterestUpsertWithWhereUniqueWithoutUserInput | ProfileInterestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ProfileInterestCreateManyUserInputEnvelope
    set?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    disconnect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    delete?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    update?: ProfileInterestUpdateWithWhereUniqueWithoutUserInput | ProfileInterestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ProfileInterestUpdateManyWithWhereWithoutUserInput | ProfileInterestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput> | PostCreateWithoutAuthorInput[] | PostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: PostCreateOrConnectWithoutAuthorInput | PostCreateOrConnectWithoutAuthorInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutAuthorInput | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: PostCreateManyAuthorInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutAuthorInput | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: PostUpdateManyWithWhereWithoutAuthorInput | PostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageReadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput> | MessageReadCreateWithoutUserInput[] | MessageReadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutUserInput | MessageReadCreateOrConnectWithoutUserInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutUserInput | MessageReadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageReadCreateManyUserInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutUserInput | MessageReadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutUserInput | MessageReadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type PostReactionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput> | PostReactionCreateWithoutProfileInput[] | PostReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutProfileInput | PostReactionCreateOrConnectWithoutProfileInput[]
    upsert?: PostReactionUpsertWithWhereUniqueWithoutProfileInput | PostReactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: PostReactionCreateManyProfileInputEnvelope
    set?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    disconnect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    delete?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    update?: PostReactionUpdateWithWhereUniqueWithoutProfileInput | PostReactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: PostReactionUpdateManyWithWhereWithoutProfileInput | PostReactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
  }

  export type ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    connectOrCreate?: ProfileSettingsCreateOrConnectWithoutProfileInput
    upsert?: ProfileSettingsUpsertWithoutProfileInput
    disconnect?: ProfileSettingsWhereInput | boolean
    delete?: ProfileSettingsWhereInput | boolean
    connect?: ProfileSettingsWhereUniqueInput
    update?: XOR<XOR<ProfileSettingsUpdateToOneWithWhereWithoutProfileInput, ProfileSettingsUpdateWithoutProfileInput>, ProfileSettingsUncheckedUpdateWithoutProfileInput>
  }

  export type LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput> | LineageMembershipCreateWithoutProfileInput[] | LineageMembershipUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutProfileInput | LineageMembershipCreateOrConnectWithoutProfileInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutProfileInput | LineageMembershipUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: LineageMembershipCreateManyProfileInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutProfileInput | LineageMembershipUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutProfileInput | LineageMembershipUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type KinshipUncheckedUpdateManyWithoutProfileANestedInput = {
    create?: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput> | KinshipCreateWithoutProfileAInput[] | KinshipUncheckedCreateWithoutProfileAInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileAInput | KinshipCreateOrConnectWithoutProfileAInput[]
    upsert?: KinshipUpsertWithWhereUniqueWithoutProfileAInput | KinshipUpsertWithWhereUniqueWithoutProfileAInput[]
    createMany?: KinshipCreateManyProfileAInputEnvelope
    set?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    disconnect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    delete?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    update?: KinshipUpdateWithWhereUniqueWithoutProfileAInput | KinshipUpdateWithWhereUniqueWithoutProfileAInput[]
    updateMany?: KinshipUpdateManyWithWhereWithoutProfileAInput | KinshipUpdateManyWithWhereWithoutProfileAInput[]
    deleteMany?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
  }

  export type KinshipUncheckedUpdateManyWithoutProfileBNestedInput = {
    create?: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput> | KinshipCreateWithoutProfileBInput[] | KinshipUncheckedCreateWithoutProfileBInput[]
    connectOrCreate?: KinshipCreateOrConnectWithoutProfileBInput | KinshipCreateOrConnectWithoutProfileBInput[]
    upsert?: KinshipUpsertWithWhereUniqueWithoutProfileBInput | KinshipUpsertWithWhereUniqueWithoutProfileBInput[]
    createMany?: KinshipCreateManyProfileBInputEnvelope
    set?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    disconnect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    delete?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    connect?: KinshipWhereUniqueInput | KinshipWhereUniqueInput[]
    update?: KinshipUpdateWithWhereUniqueWithoutProfileBInput | KinshipUpdateWithWhereUniqueWithoutProfileBInput[]
    updateMany?: KinshipUpdateManyWithWhereWithoutProfileBInput | KinshipUpdateManyWithWhereWithoutProfileBInput[]
    deleteMany?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
  }

  export type CommentReactionUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput> | CommentReactionCreateWithoutProfileInput[] | CommentReactionUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutProfileInput | CommentReactionCreateOrConnectWithoutProfileInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutProfileInput | CommentReactionUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: CommentReactionCreateManyProfileInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutProfileInput | CommentReactionUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutProfileInput | CommentReactionUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFollowerNestedInput = {
    create?: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput> | FollowCreateWithoutFollowerInput[] | FollowUncheckedCreateWithoutFollowerInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFollowerInput | FollowCreateOrConnectWithoutFollowerInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFollowerInput | FollowUpsertWithWhereUniqueWithoutFollowerInput[]
    createMany?: FollowCreateManyFollowerInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFollowerInput | FollowUpdateWithWhereUniqueWithoutFollowerInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFollowerInput | FollowUpdateManyWithWhereWithoutFollowerInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type FollowUncheckedUpdateManyWithoutFolloweeNestedInput = {
    create?: XOR<FollowCreateWithoutFolloweeInput, FollowUncheckedCreateWithoutFolloweeInput> | FollowCreateWithoutFolloweeInput[] | FollowUncheckedCreateWithoutFolloweeInput[]
    connectOrCreate?: FollowCreateOrConnectWithoutFolloweeInput | FollowCreateOrConnectWithoutFolloweeInput[]
    upsert?: FollowUpsertWithWhereUniqueWithoutFolloweeInput | FollowUpsertWithWhereUniqueWithoutFolloweeInput[]
    createMany?: FollowCreateManyFolloweeInputEnvelope
    set?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    disconnect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    delete?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    connect?: FollowWhereUniqueInput | FollowWhereUniqueInput[]
    update?: FollowUpdateWithWhereUniqueWithoutFolloweeInput | FollowUpdateWithWhereUniqueWithoutFolloweeInput[]
    updateMany?: FollowUpdateManyWithWhereWithoutFolloweeInput | FollowUpdateManyWithWhereWithoutFolloweeInput[]
    deleteMany?: FollowScalarWhereInput | FollowScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput> | BlockCreateWithoutBlockerInput[] | BlockUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockerInput | BlockCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockerInput | BlockUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockCreateManyBlockerInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockerInput | BlockUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockerInput | BlockUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type BlockUncheckedUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput> | BlockCreateWithoutBlockedInput[] | BlockUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockCreateOrConnectWithoutBlockedInput | BlockCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockUpsertWithWhereUniqueWithoutBlockedInput | BlockUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockCreateManyBlockedInputEnvelope
    set?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    disconnect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    delete?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    connect?: BlockWhereUniqueInput | BlockWhereUniqueInput[]
    update?: BlockUpdateWithWhereUniqueWithoutBlockedInput | BlockUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockUpdateManyWithWhereWithoutBlockedInput | BlockUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockScalarWhereInput | BlockScalarWhereInput[]
  }

  export type MuteUncheckedUpdateManyWithoutMuterNestedInput = {
    create?: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput> | MuteCreateWithoutMuterInput[] | MuteUncheckedCreateWithoutMuterInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMuterInput | MuteCreateOrConnectWithoutMuterInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutMuterInput | MuteUpsertWithWhereUniqueWithoutMuterInput[]
    createMany?: MuteCreateManyMuterInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutMuterInput | MuteUpdateWithWhereUniqueWithoutMuterInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutMuterInput | MuteUpdateManyWithWhereWithoutMuterInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type MuteUncheckedUpdateManyWithoutMutedNestedInput = {
    create?: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput> | MuteCreateWithoutMutedInput[] | MuteUncheckedCreateWithoutMutedInput[]
    connectOrCreate?: MuteCreateOrConnectWithoutMutedInput | MuteCreateOrConnectWithoutMutedInput[]
    upsert?: MuteUpsertWithWhereUniqueWithoutMutedInput | MuteUpsertWithWhereUniqueWithoutMutedInput[]
    createMany?: MuteCreateManyMutedInputEnvelope
    set?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    disconnect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    delete?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    connect?: MuteWhereUniqueInput | MuteWhereUniqueInput[]
    update?: MuteUpdateWithWhereUniqueWithoutMutedInput | MuteUpdateWithWhereUniqueWithoutMutedInput[]
    updateMany?: MuteUpdateManyWithWhereWithoutMutedInput | MuteUpdateManyWithWhereWithoutMutedInput[]
    deleteMany?: MuteScalarWhereInput | MuteScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput> | ConversationCreateWithoutCreatedByInput[] | ConversationUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutCreatedByInput | ConversationCreateOrConnectWithoutCreatedByInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutCreatedByInput | ConversationUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ConversationCreateManyCreatedByInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutCreatedByInput | ConversationUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutCreatedByInput | ConversationUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput> | ConversationParticipantCreateWithoutProfileInput[] | ConversationParticipantUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutProfileInput | ConversationParticipantCreateOrConnectWithoutProfileInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput | ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ConversationParticipantCreateManyProfileInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput | ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutProfileInput | ConversationParticipantUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput> | NotificationCreateWithoutActorInput[] | NotificationUncheckedCreateWithoutActorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutActorInput | NotificationCreateOrConnectWithoutActorInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutActorInput | NotificationUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: NotificationCreateManyActorInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutActorInput | NotificationUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutActorInput | NotificationUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LineageUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput> | LineageCreateWithoutCreatedByInput[] | LineageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: LineageCreateOrConnectWithoutCreatedByInput | LineageCreateOrConnectWithoutCreatedByInput[]
    upsert?: LineageUpsertWithWhereUniqueWithoutCreatedByInput | LineageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: LineageCreateManyCreatedByInputEnvelope
    set?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    disconnect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    delete?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    connect?: LineageWhereUniqueInput | LineageWhereUniqueInput[]
    update?: LineageUpdateWithWhereUniqueWithoutCreatedByInput | LineageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: LineageUpdateManyWithWhereWithoutCreatedByInput | LineageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: LineageScalarWhereInput | LineageScalarWhereInput[]
  }

  export type LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput> | LineageMembershipCreateWithoutAddedByInput[] | LineageMembershipUncheckedCreateWithoutAddedByInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutAddedByInput | LineageMembershipCreateOrConnectWithoutAddedByInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput | LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput[]
    createMany?: LineageMembershipCreateManyAddedByInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput | LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutAddedByInput | LineageMembershipUpdateManyWithWhereWithoutAddedByInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutSettingsInput = {
    create?: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSettingsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutSettingsInput
    upsert?: ProfileUpsertWithoutSettingsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutSettingsInput, ProfileUpdateWithoutSettingsInput>, ProfileUncheckedUpdateWithoutSettingsInput>
  }

  export type ProfileCreateNestedOneWithoutLineagesCreatedInput = {
    create?: XOR<ProfileCreateWithoutLineagesCreatedInput, ProfileUncheckedCreateWithoutLineagesCreatedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineagesCreatedInput
    connect?: ProfileWhereUniqueInput
  }

  export type LineageMembershipCreateNestedManyWithoutLineageInput = {
    create?: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput> | LineageMembershipCreateWithoutLineageInput[] | LineageMembershipUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutLineageInput | LineageMembershipCreateOrConnectWithoutLineageInput[]
    createMany?: LineageMembershipCreateManyLineageInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type PostCreateNestedManyWithoutLineageInput = {
    create?: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput> | PostCreateWithoutLineageInput[] | PostUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLineageInput | PostCreateOrConnectWithoutLineageInput[]
    createMany?: PostCreateManyLineageInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutLineageInput = {
    create?: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput> | NotificationCreateWithoutLineageInput[] | NotificationUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLineageInput | NotificationCreateOrConnectWithoutLineageInput[]
    createMany?: NotificationCreateManyLineageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type LineageMembershipUncheckedCreateNestedManyWithoutLineageInput = {
    create?: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput> | LineageMembershipCreateWithoutLineageInput[] | LineageMembershipUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutLineageInput | LineageMembershipCreateOrConnectWithoutLineageInput[]
    createMany?: LineageMembershipCreateManyLineageInputEnvelope
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
  }

  export type PostUncheckedCreateNestedManyWithoutLineageInput = {
    create?: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput> | PostCreateWithoutLineageInput[] | PostUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLineageInput | PostCreateOrConnectWithoutLineageInput[]
    createMany?: PostCreateManyLineageInputEnvelope
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutLineageInput = {
    create?: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput> | NotificationCreateWithoutLineageInput[] | NotificationUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLineageInput | NotificationCreateOrConnectWithoutLineageInput[]
    createMany?: NotificationCreateManyLineageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumLineageTypeFieldUpdateOperationsInput = {
    set?: $Enums.LineageType
  }

  export type ProfileUpdateOneWithoutLineagesCreatedNestedInput = {
    create?: XOR<ProfileCreateWithoutLineagesCreatedInput, ProfileUncheckedCreateWithoutLineagesCreatedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineagesCreatedInput
    upsert?: ProfileUpsertWithoutLineagesCreatedInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutLineagesCreatedInput, ProfileUpdateWithoutLineagesCreatedInput>, ProfileUncheckedUpdateWithoutLineagesCreatedInput>
  }

  export type LineageMembershipUpdateManyWithoutLineageNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput> | LineageMembershipCreateWithoutLineageInput[] | LineageMembershipUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutLineageInput | LineageMembershipCreateOrConnectWithoutLineageInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutLineageInput | LineageMembershipUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: LineageMembershipCreateManyLineageInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutLineageInput | LineageMembershipUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutLineageInput | LineageMembershipUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type PostUpdateManyWithoutLineageNestedInput = {
    create?: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput> | PostCreateWithoutLineageInput[] | PostUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLineageInput | PostCreateOrConnectWithoutLineageInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutLineageInput | PostUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: PostCreateManyLineageInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutLineageInput | PostUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: PostUpdateManyWithWhereWithoutLineageInput | PostUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutLineageNestedInput = {
    create?: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput> | NotificationCreateWithoutLineageInput[] | NotificationUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLineageInput | NotificationCreateOrConnectWithoutLineageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutLineageInput | NotificationUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: NotificationCreateManyLineageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutLineageInput | NotificationUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutLineageInput | NotificationUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput = {
    create?: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput> | LineageMembershipCreateWithoutLineageInput[] | LineageMembershipUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: LineageMembershipCreateOrConnectWithoutLineageInput | LineageMembershipCreateOrConnectWithoutLineageInput[]
    upsert?: LineageMembershipUpsertWithWhereUniqueWithoutLineageInput | LineageMembershipUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: LineageMembershipCreateManyLineageInputEnvelope
    set?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    disconnect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    delete?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    connect?: LineageMembershipWhereUniqueInput | LineageMembershipWhereUniqueInput[]
    update?: LineageMembershipUpdateWithWhereUniqueWithoutLineageInput | LineageMembershipUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: LineageMembershipUpdateManyWithWhereWithoutLineageInput | LineageMembershipUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
  }

  export type PostUncheckedUpdateManyWithoutLineageNestedInput = {
    create?: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput> | PostCreateWithoutLineageInput[] | PostUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: PostCreateOrConnectWithoutLineageInput | PostCreateOrConnectWithoutLineageInput[]
    upsert?: PostUpsertWithWhereUniqueWithoutLineageInput | PostUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: PostCreateManyLineageInputEnvelope
    set?: PostWhereUniqueInput | PostWhereUniqueInput[]
    disconnect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    delete?: PostWhereUniqueInput | PostWhereUniqueInput[]
    connect?: PostWhereUniqueInput | PostWhereUniqueInput[]
    update?: PostUpdateWithWhereUniqueWithoutLineageInput | PostUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: PostUpdateManyWithWhereWithoutLineageInput | PostUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: PostScalarWhereInput | PostScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutLineageNestedInput = {
    create?: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput> | NotificationCreateWithoutLineageInput[] | NotificationUncheckedCreateWithoutLineageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutLineageInput | NotificationCreateOrConnectWithoutLineageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutLineageInput | NotificationUpsertWithWhereUniqueWithoutLineageInput[]
    createMany?: NotificationCreateManyLineageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutLineageInput | NotificationUpdateWithWhereUniqueWithoutLineageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutLineageInput | NotificationUpdateManyWithWhereWithoutLineageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type LineageCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<LineageCreateWithoutMembershipsInput, LineageUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutMembershipsInput
    connect?: LineageWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutLineageMembershipsInput = {
    create?: XOR<ProfileCreateWithoutLineageMembershipsInput, ProfileUncheckedCreateWithoutLineageMembershipsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineageMembershipsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutLineageMembershipsAddedInput = {
    create?: XOR<ProfileCreateWithoutLineageMembershipsAddedInput, ProfileUncheckedCreateWithoutLineageMembershipsAddedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineageMembershipsAddedInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnumLineageRoleFieldUpdateOperationsInput = {
    set?: $Enums.LineageRole
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type LineageUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<LineageCreateWithoutMembershipsInput, LineageUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutMembershipsInput
    upsert?: LineageUpsertWithoutMembershipsInput
    connect?: LineageWhereUniqueInput
    update?: XOR<XOR<LineageUpdateToOneWithWhereWithoutMembershipsInput, LineageUpdateWithoutMembershipsInput>, LineageUncheckedUpdateWithoutMembershipsInput>
  }

  export type ProfileUpdateOneRequiredWithoutLineageMembershipsNestedInput = {
    create?: XOR<ProfileCreateWithoutLineageMembershipsInput, ProfileUncheckedCreateWithoutLineageMembershipsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineageMembershipsInput
    upsert?: ProfileUpsertWithoutLineageMembershipsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutLineageMembershipsInput, ProfileUpdateWithoutLineageMembershipsInput>, ProfileUncheckedUpdateWithoutLineageMembershipsInput>
  }

  export type ProfileUpdateOneWithoutLineageMembershipsAddedNestedInput = {
    create?: XOR<ProfileCreateWithoutLineageMembershipsAddedInput, ProfileUncheckedCreateWithoutLineageMembershipsAddedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutLineageMembershipsAddedInput
    upsert?: ProfileUpsertWithoutLineageMembershipsAddedInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutLineageMembershipsAddedInput, ProfileUpdateWithoutLineageMembershipsAddedInput>, ProfileUncheckedUpdateWithoutLineageMembershipsAddedInput>
  }

  export type ProfileCreateNestedOneWithoutKinshipsAInput = {
    create?: XOR<ProfileCreateWithoutKinshipsAInput, ProfileUncheckedCreateWithoutKinshipsAInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutKinshipsAInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutKinshipsBInput = {
    create?: XOR<ProfileCreateWithoutKinshipsBInput, ProfileUncheckedCreateWithoutKinshipsBInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutKinshipsBInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnumKinshipTypeFieldUpdateOperationsInput = {
    set?: $Enums.KinshipType
  }

  export type ProfileUpdateOneRequiredWithoutKinshipsANestedInput = {
    create?: XOR<ProfileCreateWithoutKinshipsAInput, ProfileUncheckedCreateWithoutKinshipsAInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutKinshipsAInput
    upsert?: ProfileUpsertWithoutKinshipsAInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutKinshipsAInput, ProfileUpdateWithoutKinshipsAInput>, ProfileUncheckedUpdateWithoutKinshipsAInput>
  }

  export type ProfileUpdateOneRequiredWithoutKinshipsBNestedInput = {
    create?: XOR<ProfileCreateWithoutKinshipsBInput, ProfileUncheckedCreateWithoutKinshipsBInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutKinshipsBInput
    upsert?: ProfileUpsertWithoutKinshipsBInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutKinshipsBInput, ProfileUpdateWithoutKinshipsBInput>, ProfileUncheckedUpdateWithoutKinshipsBInput>
  }

  export type ProfileCreateNestedOneWithoutFollowsAsFollowerInput = {
    create?: XOR<ProfileCreateWithoutFollowsAsFollowerInput, ProfileUncheckedCreateWithoutFollowsAsFollowerInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFollowsAsFollowerInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutFollowsAsFolloweeInput = {
    create?: XOR<ProfileCreateWithoutFollowsAsFolloweeInput, ProfileUncheckedCreateWithoutFollowsAsFolloweeInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFollowsAsFolloweeInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutFollowsAsFollowerNestedInput = {
    create?: XOR<ProfileCreateWithoutFollowsAsFollowerInput, ProfileUncheckedCreateWithoutFollowsAsFollowerInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFollowsAsFollowerInput
    upsert?: ProfileUpsertWithoutFollowsAsFollowerInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutFollowsAsFollowerInput, ProfileUpdateWithoutFollowsAsFollowerInput>, ProfileUncheckedUpdateWithoutFollowsAsFollowerInput>
  }

  export type ProfileUpdateOneRequiredWithoutFollowsAsFolloweeNestedInput = {
    create?: XOR<ProfileCreateWithoutFollowsAsFolloweeInput, ProfileUncheckedCreateWithoutFollowsAsFolloweeInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutFollowsAsFolloweeInput
    upsert?: ProfileUpsertWithoutFollowsAsFolloweeInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutFollowsAsFolloweeInput, ProfileUpdateWithoutFollowsAsFolloweeInput>, ProfileUncheckedUpdateWithoutFollowsAsFolloweeInput>
  }

  export type ProfileCreateNestedOneWithoutBlocksAsBlockerInput = {
    create?: XOR<ProfileCreateWithoutBlocksAsBlockerInput, ProfileUncheckedCreateWithoutBlocksAsBlockerInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlocksAsBlockerInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutBlocksAsBlockedInput = {
    create?: XOR<ProfileCreateWithoutBlocksAsBlockedInput, ProfileUncheckedCreateWithoutBlocksAsBlockedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlocksAsBlockedInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutBlocksAsBlockerNestedInput = {
    create?: XOR<ProfileCreateWithoutBlocksAsBlockerInput, ProfileUncheckedCreateWithoutBlocksAsBlockerInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlocksAsBlockerInput
    upsert?: ProfileUpsertWithoutBlocksAsBlockerInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutBlocksAsBlockerInput, ProfileUpdateWithoutBlocksAsBlockerInput>, ProfileUncheckedUpdateWithoutBlocksAsBlockerInput>
  }

  export type ProfileUpdateOneRequiredWithoutBlocksAsBlockedNestedInput = {
    create?: XOR<ProfileCreateWithoutBlocksAsBlockedInput, ProfileUncheckedCreateWithoutBlocksAsBlockedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBlocksAsBlockedInput
    upsert?: ProfileUpsertWithoutBlocksAsBlockedInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutBlocksAsBlockedInput, ProfileUpdateWithoutBlocksAsBlockedInput>, ProfileUncheckedUpdateWithoutBlocksAsBlockedInput>
  }

  export type ProfileCreateNestedOneWithoutMutesAsMuterInput = {
    create?: XOR<ProfileCreateWithoutMutesAsMuterInput, ProfileUncheckedCreateWithoutMutesAsMuterInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMutesAsMuterInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutMutesAsMutedInput = {
    create?: XOR<ProfileCreateWithoutMutesAsMutedInput, ProfileUncheckedCreateWithoutMutesAsMutedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMutesAsMutedInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutMutesAsMuterNestedInput = {
    create?: XOR<ProfileCreateWithoutMutesAsMuterInput, ProfileUncheckedCreateWithoutMutesAsMuterInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMutesAsMuterInput
    upsert?: ProfileUpsertWithoutMutesAsMuterInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMutesAsMuterInput, ProfileUpdateWithoutMutesAsMuterInput>, ProfileUncheckedUpdateWithoutMutesAsMuterInput>
  }

  export type ProfileUpdateOneRequiredWithoutMutesAsMutedNestedInput = {
    create?: XOR<ProfileCreateWithoutMutesAsMutedInput, ProfileUncheckedCreateWithoutMutesAsMutedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMutesAsMutedInput
    upsert?: ProfileUpsertWithoutMutesAsMutedInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMutesAsMutedInput, ProfileUpdateWithoutMutesAsMutedInput>, ProfileUncheckedUpdateWithoutMutesAsMutedInput>
  }

  export type ProfileCreateNestedOneWithoutPostsInput = {
    create?: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostsInput
    connect?: ProfileWhereUniqueInput
  }

  export type LineageCreateNestedOneWithoutPostsInput = {
    create?: XOR<LineageCreateWithoutPostsInput, LineageUncheckedCreateWithoutPostsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutPostsInput
    connect?: LineageWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostReactionCreateNestedManyWithoutPostInput = {
    create?: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput> | PostReactionCreateWithoutPostInput[] | PostReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutPostInput | PostReactionCreateOrConnectWithoutPostInput[]
    createMany?: PostReactionCreateManyPostInputEnvelope
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
  }

  export type MediaFileCreateNestedManyWithoutPostInput = {
    create?: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput> | MediaFileCreateWithoutPostInput[] | MediaFileUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutPostInput | MediaFileCreateOrConnectWithoutPostInput[]
    createMany?: MediaFileCreateManyPostInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutPostInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type PostReactionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput> | PostReactionCreateWithoutPostInput[] | PostReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutPostInput | PostReactionCreateOrConnectWithoutPostInput[]
    createMany?: PostReactionCreateManyPostInputEnvelope
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
  }

  export type MediaFileUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput> | MediaFileCreateWithoutPostInput[] | MediaFileUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutPostInput | MediaFileCreateOrConnectWithoutPostInput[]
    createMany?: MediaFileCreateManyPostInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumPostVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.PostVisibility
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProfileUpdateOneRequiredWithoutPostsNestedInput = {
    create?: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostsInput
    upsert?: ProfileUpsertWithoutPostsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostsInput, ProfileUpdateWithoutPostsInput>, ProfileUncheckedUpdateWithoutPostsInput>
  }

  export type LineageUpdateOneWithoutPostsNestedInput = {
    create?: XOR<LineageCreateWithoutPostsInput, LineageUncheckedCreateWithoutPostsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutPostsInput
    upsert?: LineageUpsertWithoutPostsInput
    disconnect?: LineageWhereInput | boolean
    delete?: LineageWhereInput | boolean
    connect?: LineageWhereUniqueInput
    update?: XOR<XOR<LineageUpdateToOneWithWhereWithoutPostsInput, LineageUpdateWithoutPostsInput>, LineageUncheckedUpdateWithoutPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostReactionUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput> | PostReactionCreateWithoutPostInput[] | PostReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutPostInput | PostReactionCreateOrConnectWithoutPostInput[]
    upsert?: PostReactionUpsertWithWhereUniqueWithoutPostInput | PostReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostReactionCreateManyPostInputEnvelope
    set?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    disconnect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    delete?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    update?: PostReactionUpdateWithWhereUniqueWithoutPostInput | PostReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostReactionUpdateManyWithWhereWithoutPostInput | PostReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
  }

  export type MediaFileUpdateManyWithoutPostNestedInput = {
    create?: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput> | MediaFileCreateWithoutPostInput[] | MediaFileUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutPostInput | MediaFileCreateOrConnectWithoutPostInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutPostInput | MediaFileUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: MediaFileCreateManyPostInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutPostInput | MediaFileUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutPostInput | MediaFileUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutPostNestedInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPostInput | NotificationUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPostInput | NotificationUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPostInput | NotificationUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type PostReactionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput> | PostReactionCreateWithoutPostInput[] | PostReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostReactionCreateOrConnectWithoutPostInput | PostReactionCreateOrConnectWithoutPostInput[]
    upsert?: PostReactionUpsertWithWhereUniqueWithoutPostInput | PostReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostReactionCreateManyPostInputEnvelope
    set?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    disconnect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    delete?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    connect?: PostReactionWhereUniqueInput | PostReactionWhereUniqueInput[]
    update?: PostReactionUpdateWithWhereUniqueWithoutPostInput | PostReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostReactionUpdateManyWithWhereWithoutPostInput | PostReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
  }

  export type MediaFileUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput> | MediaFileCreateWithoutPostInput[] | MediaFileUncheckedCreateWithoutPostInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutPostInput | MediaFileCreateOrConnectWithoutPostInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutPostInput | MediaFileUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: MediaFileCreateManyPostInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutPostInput | MediaFileUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutPostInput | MediaFileUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput> | NotificationCreateWithoutPostInput[] | NotificationUncheckedCreateWithoutPostInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutPostInput | NotificationCreateOrConnectWithoutPostInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutPostInput | NotificationUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: NotificationCreateManyPostInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutPostInput | NotificationUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutPostInput | NotificationUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutMediaFilesInput = {
    create?: XOR<PostCreateWithoutMediaFilesInput, PostUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: PostCreateOrConnectWithoutMediaFilesInput
    connect?: PostWhereUniqueInput
  }

  export type EnumMediaTypeFieldUpdateOperationsInput = {
    set?: $Enums.MediaType
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type PostUpdateOneRequiredWithoutMediaFilesNestedInput = {
    create?: XOR<PostCreateWithoutMediaFilesInput, PostUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: PostCreateOrConnectWithoutMediaFilesInput
    upsert?: PostUpsertWithoutMediaFilesInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutMediaFilesInput, PostUpdateWithoutMediaFilesInput>, PostUncheckedUpdateWithoutMediaFilesInput>
  }

  export type PostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    connect?: PostWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ProfileCreateWithoutCommentsInput, ProfileUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCommentsInput
    connect?: ProfileWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    connect?: CommentWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentReactionCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type CommentReactionUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type PostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: PostCreateOrConnectWithoutCommentsInput
    upsert?: PostUpsertWithoutCommentsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutCommentsInput, PostUpdateWithoutCommentsInput>, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type ProfileUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ProfileCreateWithoutCommentsInput, ProfileUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCommentsInput
    upsert?: ProfileUpsertWithoutCommentsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutCommentsInput, ProfileUpdateWithoutCommentsInput>, ProfileUncheckedUpdateWithoutCommentsInput>
  }

  export type CommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: CommentCreateOrConnectWithoutRepliesInput
    upsert?: CommentUpsertWithoutRepliesInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutRepliesInput, CommentUpdateWithoutRepliesInput>, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentCommentInput | CommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentCommentInput | CommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentCommentInput | CommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentReactionUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutCommentInput | CommentReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutCommentInput | CommentReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutCommentInput | CommentReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCommentInput | NotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCommentInput | NotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCommentInput | NotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput> | CommentCreateWithoutParentCommentInput[] | CommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutParentCommentInput | CommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutParentCommentInput | CommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: CommentCreateManyParentCommentInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutParentCommentInput | CommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutParentCommentInput | CommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type CommentReactionUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput> | CommentReactionCreateWithoutCommentInput[] | CommentReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentReactionCreateOrConnectWithoutCommentInput | CommentReactionCreateOrConnectWithoutCommentInput[]
    upsert?: CommentReactionUpsertWithWhereUniqueWithoutCommentInput | CommentReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentReactionCreateManyCommentInputEnvelope
    set?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    disconnect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    delete?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    connect?: CommentReactionWhereUniqueInput | CommentReactionWhereUniqueInput[]
    update?: CommentReactionUpdateWithWhereUniqueWithoutCommentInput | CommentReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentReactionUpdateManyWithWhereWithoutCommentInput | CommentReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput> | NotificationCreateWithoutCommentInput[] | NotificationUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutCommentInput | NotificationCreateOrConnectWithoutCommentInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutCommentInput | NotificationUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: NotificationCreateManyCommentInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutCommentInput | NotificationUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutCommentInput | NotificationUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type PostCreateNestedOneWithoutReactionsInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    connect?: PostWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutPostReactionsInput = {
    create?: XOR<ProfileCreateWithoutPostReactionsInput, ProfileUncheckedCreateWithoutPostReactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostReactionsInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType
  }

  export type PostUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: PostCreateOrConnectWithoutReactionsInput
    upsert?: PostUpsertWithoutReactionsInput
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutReactionsInput, PostUpdateWithoutReactionsInput>, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type ProfileUpdateOneRequiredWithoutPostReactionsNestedInput = {
    create?: XOR<ProfileCreateWithoutPostReactionsInput, ProfileUncheckedCreateWithoutPostReactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutPostReactionsInput
    upsert?: ProfileUpsertWithoutPostReactionsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutPostReactionsInput, ProfileUpdateWithoutPostReactionsInput>, ProfileUncheckedUpdateWithoutPostReactionsInput>
  }

  export type CommentCreateNestedOneWithoutReactionsInput = {
    create?: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionsInput
    connect?: CommentWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutCommentReactionsInput = {
    create?: XOR<ProfileCreateWithoutCommentReactionsInput, ProfileUncheckedCreateWithoutCommentReactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCommentReactionsInput
    connect?: ProfileWhereUniqueInput
  }

  export type CommentUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionsInput
    upsert?: CommentUpsertWithoutReactionsInput
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutReactionsInput, CommentUpdateWithoutReactionsInput>, CommentUncheckedUpdateWithoutReactionsInput>
  }

  export type ProfileUpdateOneRequiredWithoutCommentReactionsNestedInput = {
    create?: XOR<ProfileCreateWithoutCommentReactionsInput, ProfileUncheckedCreateWithoutCommentReactionsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCommentReactionsInput
    upsert?: ProfileUpsertWithoutCommentReactionsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutCommentReactionsInput, ProfileUpdateWithoutCommentReactionsInput>, ProfileUncheckedUpdateWithoutCommentReactionsInput>
  }

  export type ProfileCreateNestedOneWithoutConversationsOwnedInput = {
    create?: XOR<ProfileCreateWithoutConversationsOwnedInput, ProfileUncheckedCreateWithoutConversationsOwnedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationsOwnedInput
    connect?: ProfileWhereUniqueInput
  }

  export type ConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ProfileUpdateOneWithoutConversationsOwnedNestedInput = {
    create?: XOR<ProfileCreateWithoutConversationsOwnedInput, ProfileUncheckedCreateWithoutConversationsOwnedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationsOwnedInput
    upsert?: ProfileUpsertWithoutConversationsOwnedInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutConversationsOwnedInput, ProfileUpdateWithoutConversationsOwnedInput>, ProfileUncheckedUpdateWithoutConversationsOwnedInput>
  }

  export type ConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput> | ConversationParticipantCreateWithoutConversationInput[] | ConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ConversationParticipantCreateOrConnectWithoutConversationInput | ConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ConversationParticipantCreateManyConversationInputEnvelope
    set?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    disconnect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    delete?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    connect?: ConversationParticipantWhereUniqueInput | ConversationParticipantWhereUniqueInput[]
    update?: ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ConversationParticipantUpdateManyWithWhereWithoutConversationInput | ConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutConversationMembersInput = {
    create?: XOR<ProfileCreateWithoutConversationMembersInput, ProfileUncheckedCreateWithoutConversationMembersInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationMembersInput
    connect?: ProfileWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutParticipantsInput
    upsert?: ConversationUpsertWithoutParticipantsInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutParticipantsInput, ConversationUpdateWithoutParticipantsInput>, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ProfileUpdateOneRequiredWithoutConversationMembersNestedInput = {
    create?: XOR<ProfileCreateWithoutConversationMembersInput, ProfileUncheckedCreateWithoutConversationMembersInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationMembersInput
    upsert?: ProfileUpsertWithoutConversationMembersInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutConversationMembersInput, ProfileUpdateWithoutConversationMembersInput>, ProfileUncheckedUpdateWithoutConversationMembersInput>
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ProfileCreateWithoutMessagesInput, ProfileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMessagesInput
    connect?: ProfileWhereUniqueInput
  }

  export type MessageReadCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutMessageInput = {
    create?: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput> | NotificationCreateWithoutMessageInput[] | NotificationUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMessageInput | NotificationCreateOrConnectWithoutMessageInput[]
    createMany?: NotificationCreateManyMessageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessageReadUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput> | NotificationCreateWithoutMessageInput[] | NotificationUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMessageInput | NotificationCreateOrConnectWithoutMessageInput[]
    createMany?: NotificationCreateManyMessageInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ProfileUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ProfileCreateWithoutMessagesInput, ProfileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMessagesInput
    upsert?: ProfileUpsertWithoutMessagesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMessagesInput, ProfileUpdateWithoutMessagesInput>, ProfileUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageReadUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutMessageInput | MessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutMessageInput | MessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutMessageInput | MessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput> | NotificationCreateWithoutMessageInput[] | NotificationUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMessageInput | NotificationCreateOrConnectWithoutMessageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMessageInput | NotificationUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NotificationCreateManyMessageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMessageInput | NotificationUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMessageInput | NotificationUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessageReadUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput> | MessageReadCreateWithoutMessageInput[] | MessageReadUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageReadCreateOrConnectWithoutMessageInput | MessageReadCreateOrConnectWithoutMessageInput[]
    upsert?: MessageReadUpsertWithWhereUniqueWithoutMessageInput | MessageReadUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageReadCreateManyMessageInputEnvelope
    set?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    disconnect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    delete?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    connect?: MessageReadWhereUniqueInput | MessageReadWhereUniqueInput[]
    update?: MessageReadUpdateWithWhereUniqueWithoutMessageInput | MessageReadUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageReadUpdateManyWithWhereWithoutMessageInput | MessageReadUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput> | NotificationCreateWithoutMessageInput[] | NotificationUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutMessageInput | NotificationCreateOrConnectWithoutMessageInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutMessageInput | NotificationUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: NotificationCreateManyMessageInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutMessageInput | NotificationUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutMessageInput | NotificationUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<ProfileCreateWithoutNotificationsInput, ProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutNotificationsInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutNotificationsAsActorInput = {
    create?: XOR<ProfileCreateWithoutNotificationsAsActorInput, ProfileUncheckedCreateWithoutNotificationsAsActorInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutNotificationsAsActorInput
    connect?: ProfileWhereUniqueInput
  }

  export type PostCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotificationsInput
    connect?: PostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotificationsInput
    connect?: CommentWhereUniqueInput
  }

  export type LineageCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<LineageCreateWithoutNotificationsInput, LineageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutNotificationsInput
    connect?: LineageWhereUniqueInput
  }

  export type MessageCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<MessageCreateWithoutNotificationsInput, MessageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutNotificationsInput
    connect?: MessageWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type ProfileUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<ProfileCreateWithoutNotificationsInput, ProfileUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutNotificationsInput
    upsert?: ProfileUpsertWithoutNotificationsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutNotificationsInput, ProfileUpdateWithoutNotificationsInput>, ProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProfileUpdateOneWithoutNotificationsAsActorNestedInput = {
    create?: XOR<ProfileCreateWithoutNotificationsAsActorInput, ProfileUncheckedCreateWithoutNotificationsAsActorInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutNotificationsAsActorInput
    upsert?: ProfileUpsertWithoutNotificationsAsActorInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutNotificationsAsActorInput, ProfileUpdateWithoutNotificationsAsActorInput>, ProfileUncheckedUpdateWithoutNotificationsAsActorInput>
  }

  export type PostUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: PostCreateOrConnectWithoutNotificationsInput
    upsert?: PostUpsertWithoutNotificationsInput
    disconnect?: PostWhereInput | boolean
    delete?: PostWhereInput | boolean
    connect?: PostWhereUniqueInput
    update?: XOR<XOR<PostUpdateToOneWithWhereWithoutNotificationsInput, PostUpdateWithoutNotificationsInput>, PostUncheckedUpdateWithoutNotificationsInput>
  }

  export type CommentUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutNotificationsInput
    upsert?: CommentUpsertWithoutNotificationsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutNotificationsInput, CommentUpdateWithoutNotificationsInput>, CommentUncheckedUpdateWithoutNotificationsInput>
  }

  export type LineageUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<LineageCreateWithoutNotificationsInput, LineageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: LineageCreateOrConnectWithoutNotificationsInput
    upsert?: LineageUpsertWithoutNotificationsInput
    disconnect?: LineageWhereInput | boolean
    delete?: LineageWhereInput | boolean
    connect?: LineageWhereUniqueInput
    update?: XOR<XOR<LineageUpdateToOneWithWhereWithoutNotificationsInput, LineageUpdateWithoutNotificationsInput>, LineageUncheckedUpdateWithoutNotificationsInput>
  }

  export type MessageUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<MessageCreateWithoutNotificationsInput, MessageUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutNotificationsInput
    upsert?: MessageUpsertWithoutNotificationsInput
    disconnect?: MessageWhereInput | boolean
    delete?: MessageWhereInput | boolean
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutNotificationsInput, MessageUpdateWithoutNotificationsInput>, MessageUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProfileInterestCreateNestedManyWithoutInterestInput = {
    create?: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput> | ProfileInterestCreateWithoutInterestInput[] | ProfileInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutInterestInput | ProfileInterestCreateOrConnectWithoutInterestInput[]
    createMany?: ProfileInterestCreateManyInterestInputEnvelope
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
  }

  export type ProfileInterestUncheckedCreateNestedManyWithoutInterestInput = {
    create?: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput> | ProfileInterestCreateWithoutInterestInput[] | ProfileInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutInterestInput | ProfileInterestCreateOrConnectWithoutInterestInput[]
    createMany?: ProfileInterestCreateManyInterestInputEnvelope
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
  }

  export type ProfileInterestUpdateManyWithoutInterestNestedInput = {
    create?: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput> | ProfileInterestCreateWithoutInterestInput[] | ProfileInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutInterestInput | ProfileInterestCreateOrConnectWithoutInterestInput[]
    upsert?: ProfileInterestUpsertWithWhereUniqueWithoutInterestInput | ProfileInterestUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: ProfileInterestCreateManyInterestInputEnvelope
    set?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    disconnect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    delete?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    update?: ProfileInterestUpdateWithWhereUniqueWithoutInterestInput | ProfileInterestUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: ProfileInterestUpdateManyWithWhereWithoutInterestInput | ProfileInterestUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
  }

  export type ProfileInterestUncheckedUpdateManyWithoutInterestNestedInput = {
    create?: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput> | ProfileInterestCreateWithoutInterestInput[] | ProfileInterestUncheckedCreateWithoutInterestInput[]
    connectOrCreate?: ProfileInterestCreateOrConnectWithoutInterestInput | ProfileInterestCreateOrConnectWithoutInterestInput[]
    upsert?: ProfileInterestUpsertWithWhereUniqueWithoutInterestInput | ProfileInterestUpsertWithWhereUniqueWithoutInterestInput[]
    createMany?: ProfileInterestCreateManyInterestInputEnvelope
    set?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    disconnect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    delete?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    connect?: ProfileInterestWhereUniqueInput | ProfileInterestWhereUniqueInput[]
    update?: ProfileInterestUpdateWithWhereUniqueWithoutInterestInput | ProfileInterestUpdateWithWhereUniqueWithoutInterestInput[]
    updateMany?: ProfileInterestUpdateManyWithWhereWithoutInterestInput | ProfileInterestUpdateManyWithWhereWithoutInterestInput[]
    deleteMany?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
  }

  export type ProfileCreateNestedOneWithoutInterestsInput = {
    create?: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutInterestsInput
    connect?: ProfileWhereUniqueInput
  }

  export type InterestCreateNestedOneWithoutUsersInput = {
    create?: XOR<InterestCreateWithoutUsersInput, InterestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InterestCreateOrConnectWithoutUsersInput
    connect?: InterestWhereUniqueInput
  }

  export type ProfileUpdateOneRequiredWithoutInterestsNestedInput = {
    create?: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutInterestsInput
    upsert?: ProfileUpsertWithoutInterestsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutInterestsInput, ProfileUpdateWithoutInterestsInput>, ProfileUncheckedUpdateWithoutInterestsInput>
  }

  export type InterestUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<InterestCreateWithoutUsersInput, InterestUncheckedCreateWithoutUsersInput>
    connectOrCreate?: InterestCreateOrConnectWithoutUsersInput
    upsert?: InterestUpsertWithoutUsersInput
    connect?: InterestWhereUniqueInput
    update?: XOR<XOR<InterestUpdateToOneWithWhereWithoutUsersInput, InterestUpdateWithoutUsersInput>, InterestUncheckedUpdateWithoutUsersInput>
  }

  export type MessageCreateNestedOneWithoutReadsInput = {
    create?: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadsInput
    connect?: MessageWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutMessageReadsInput = {
    create?: XOR<ProfileCreateWithoutMessageReadsInput, ProfileUncheckedCreateWithoutMessageReadsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMessageReadsInput
    connect?: ProfileWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutReadsNestedInput = {
    create?: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutReadsInput
    upsert?: MessageUpsertWithoutReadsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutReadsInput, MessageUpdateWithoutReadsInput>, MessageUncheckedUpdateWithoutReadsInput>
  }

  export type ProfileUpdateOneRequiredWithoutMessageReadsNestedInput = {
    create?: XOR<ProfileCreateWithoutMessageReadsInput, ProfileUncheckedCreateWithoutMessageReadsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutMessageReadsInput
    upsert?: ProfileUpsertWithoutMessageReadsInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutMessageReadsInput, ProfileUpdateWithoutMessageReadsInput>, ProfileUncheckedUpdateWithoutMessageReadsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumLineageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageType | EnumLineageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageTypeFilter<$PrismaModel> | $Enums.LineageType
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumLineageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageType | EnumLineageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageType[] | ListEnumLineageTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageTypeWithAggregatesFilter<$PrismaModel> | $Enums.LineageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLineageTypeFilter<$PrismaModel>
    _max?: NestedEnumLineageTypeFilter<$PrismaModel>
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumLineageRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageRole | EnumLineageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageRoleFilter<$PrismaModel> | $Enums.LineageRole
  }

  export type NestedEnumLineageRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LineageRole | EnumLineageRoleFieldRefInput<$PrismaModel>
    in?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.LineageRole[] | ListEnumLineageRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumLineageRoleWithAggregatesFilter<$PrismaModel> | $Enums.LineageRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLineageRoleFilter<$PrismaModel>
    _max?: NestedEnumLineageRoleFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumKinshipTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.KinshipType | EnumKinshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKinshipTypeFilter<$PrismaModel> | $Enums.KinshipType
  }

  export type NestedEnumKinshipTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KinshipType | EnumKinshipTypeFieldRefInput<$PrismaModel>
    in?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.KinshipType[] | ListEnumKinshipTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumKinshipTypeWithAggregatesFilter<$PrismaModel> | $Enums.KinshipType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKinshipTypeFilter<$PrismaModel>
    _max?: NestedEnumKinshipTypeFilter<$PrismaModel>
  }

  export type NestedEnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMediaTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeFilter<$PrismaModel> | $Enums.MediaType
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaType | EnumMediaTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.MediaType[] | ListEnumMediaTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumMediaTypeWithAggregatesFilter<$PrismaModel> | $Enums.MediaType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaTypeFilter<$PrismaModel>
    _max?: NestedEnumMediaTypeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type ProfileInterestCreateWithoutUserInput = {
    createdAt?: Date | string
    interest: InterestCreateNestedOneWithoutUsersInput
  }

  export type ProfileInterestUncheckedCreateWithoutUserInput = {
    interestId: string
    createdAt?: Date | string
  }

  export type ProfileInterestCreateOrConnectWithoutUserInput = {
    where: ProfileInterestWhereUniqueInput
    create: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput>
  }

  export type ProfileInterestCreateManyUserInputEnvelope = {
    data: ProfileInterestCreateManyUserInput | ProfileInterestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutAuthorInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lineage?: LineageCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutAuthorInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutAuthorInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostCreateManyAuthorInputEnvelope = {
    data: PostCreateManyAuthorInput | PostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    postId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
    notifications?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageReadCreateWithoutUserInput = {
    readAt?: Date | string
    message: MessageCreateNestedOneWithoutReadsInput
  }

  export type MessageReadUncheckedCreateWithoutUserInput = {
    messageId: string
    readAt?: Date | string
  }

  export type MessageReadCreateOrConnectWithoutUserInput = {
    where: MessageReadWhereUniqueInput
    create: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput>
  }

  export type MessageReadCreateManyUserInputEnvelope = {
    data: MessageReadCreateManyUserInput | MessageReadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PostReactionCreateWithoutProfileInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutReactionsInput
  }

  export type PostReactionUncheckedCreateWithoutProfileInput = {
    id?: string
    postId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type PostReactionCreateOrConnectWithoutProfileInput = {
    where: PostReactionWhereUniqueInput
    create: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput>
  }

  export type PostReactionCreateManyProfileInputEnvelope = {
    data: PostReactionCreateManyProfileInput | PostReactionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type ProfileSettingsCreateWithoutProfileInput = {
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileSettingsUncheckedCreateWithoutProfileInput = {
    isPrivate?: boolean
    showLastSeen?: boolean
    allowTagging?: boolean
    allowMessagesFrom?: string
    discoveryAllowLineage?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileSettingsCreateOrConnectWithoutProfileInput = {
    where: ProfileSettingsWhereUniqueInput
    create: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
  }

  export type LineageMembershipCreateWithoutProfileInput = {
    id?: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
    lineage: LineageCreateNestedOneWithoutMembershipsInput
    addedBy?: ProfileCreateNestedOneWithoutLineageMembershipsAddedInput
  }

  export type LineageMembershipUncheckedCreateWithoutProfileInput = {
    id?: string
    lineageId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type LineageMembershipCreateOrConnectWithoutProfileInput = {
    where: LineageMembershipWhereUniqueInput
    create: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput>
  }

  export type LineageMembershipCreateManyProfileInputEnvelope = {
    data: LineageMembershipCreateManyProfileInput | LineageMembershipCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type KinshipCreateWithoutProfileAInput = {
    id?: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
    profileB: ProfileCreateNestedOneWithoutKinshipsBInput
  }

  export type KinshipUncheckedCreateWithoutProfileAInput = {
    id?: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipCreateOrConnectWithoutProfileAInput = {
    where: KinshipWhereUniqueInput
    create: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput>
  }

  export type KinshipCreateManyProfileAInputEnvelope = {
    data: KinshipCreateManyProfileAInput | KinshipCreateManyProfileAInput[]
    skipDuplicates?: boolean
  }

  export type KinshipCreateWithoutProfileBInput = {
    id?: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
    profileA: ProfileCreateNestedOneWithoutKinshipsAInput
  }

  export type KinshipUncheckedCreateWithoutProfileBInput = {
    id?: string
    profileIdA: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipCreateOrConnectWithoutProfileBInput = {
    where: KinshipWhereUniqueInput
    create: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput>
  }

  export type KinshipCreateManyProfileBInputEnvelope = {
    data: KinshipCreateManyProfileBInput | KinshipCreateManyProfileBInput[]
    skipDuplicates?: boolean
  }

  export type CommentReactionCreateWithoutProfileInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    comment: CommentCreateNestedOneWithoutReactionsInput
  }

  export type CommentReactionUncheckedCreateWithoutProfileInput = {
    id?: string
    commentId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentReactionCreateOrConnectWithoutProfileInput = {
    where: CommentReactionWhereUniqueInput
    create: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput>
  }

  export type CommentReactionCreateManyProfileInputEnvelope = {
    data: CommentReactionCreateManyProfileInput | CommentReactionCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFollowerInput = {
    id?: string
    createdAt?: Date | string
    followee: ProfileCreateNestedOneWithoutFollowsAsFolloweeInput
  }

  export type FollowUncheckedCreateWithoutFollowerInput = {
    id?: string
    followeeId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowCreateManyFollowerInputEnvelope = {
    data: FollowCreateManyFollowerInput | FollowCreateManyFollowerInput[]
    skipDuplicates?: boolean
  }

  export type FollowCreateWithoutFolloweeInput = {
    id?: string
    createdAt?: Date | string
    follower: ProfileCreateNestedOneWithoutFollowsAsFollowerInput
  }

  export type FollowUncheckedCreateWithoutFolloweeInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type FollowCreateOrConnectWithoutFolloweeInput = {
    where: FollowWhereUniqueInput
    create: XOR<FollowCreateWithoutFolloweeInput, FollowUncheckedCreateWithoutFolloweeInput>
  }

  export type FollowCreateManyFolloweeInputEnvelope = {
    data: FollowCreateManyFolloweeInput | FollowCreateManyFolloweeInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutBlockerInput = {
    id?: string
    createdAt?: Date | string
    blocked: ProfileCreateNestedOneWithoutBlocksAsBlockedInput
  }

  export type BlockUncheckedCreateWithoutBlockerInput = {
    id?: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockCreateManyBlockerInputEnvelope = {
    data: BlockCreateManyBlockerInput | BlockCreateManyBlockerInput[]
    skipDuplicates?: boolean
  }

  export type BlockCreateWithoutBlockedInput = {
    id?: string
    createdAt?: Date | string
    blocker: ProfileCreateNestedOneWithoutBlocksAsBlockerInput
  }

  export type BlockUncheckedCreateWithoutBlockedInput = {
    id?: string
    blockerId: string
    createdAt?: Date | string
  }

  export type BlockCreateOrConnectWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    create: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput>
  }

  export type BlockCreateManyBlockedInputEnvelope = {
    data: BlockCreateManyBlockedInput | BlockCreateManyBlockedInput[]
    skipDuplicates?: boolean
  }

  export type MuteCreateWithoutMuterInput = {
    id?: string
    createdAt?: Date | string
    muted: ProfileCreateNestedOneWithoutMutesAsMutedInput
  }

  export type MuteUncheckedCreateWithoutMuterInput = {
    id?: string
    mutedId: string
    createdAt?: Date | string
  }

  export type MuteCreateOrConnectWithoutMuterInput = {
    where: MuteWhereUniqueInput
    create: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput>
  }

  export type MuteCreateManyMuterInputEnvelope = {
    data: MuteCreateManyMuterInput | MuteCreateManyMuterInput[]
    skipDuplicates?: boolean
  }

  export type MuteCreateWithoutMutedInput = {
    id?: string
    createdAt?: Date | string
    muter: ProfileCreateNestedOneWithoutMutesAsMuterInput
  }

  export type MuteUncheckedCreateWithoutMutedInput = {
    id?: string
    muterId: string
    createdAt?: Date | string
  }

  export type MuteCreateOrConnectWithoutMutedInput = {
    where: MuteWhereUniqueInput
    create: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput>
  }

  export type MuteCreateManyMutedInputEnvelope = {
    data: MuteCreateManyMutedInput | MuteCreateManyMutedInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutCreatedByInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutCreatedByInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutCreatedByInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput>
  }

  export type ConversationCreateManyCreatedByInputEnvelope = {
    data: ConversationCreateManyCreatedByInput | ConversationCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ConversationParticipantCreateWithoutProfileInput = {
    id?: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutParticipantsInput
  }

  export type ConversationParticipantUncheckedCreateWithoutProfileInput = {
    id?: string
    conversationId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutProfileInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput>
  }

  export type ConversationParticipantCreateManyProfileInputEnvelope = {
    data: ConversationParticipantCreateManyProfileInput | ConversationParticipantCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    actor?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutActorInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutActorInput = {
    id?: string
    recipientId: string
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutActorInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput>
  }

  export type NotificationCreateManyActorInputEnvelope = {
    data: NotificationCreateManyActorInput | NotificationCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type LineageCreateWithoutCreatedByInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipCreateNestedManyWithoutLineageInput
    posts?: PostCreateNestedManyWithoutLineageInput
    notifications?: NotificationCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipUncheckedCreateNestedManyWithoutLineageInput
    posts?: PostUncheckedCreateNestedManyWithoutLineageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageCreateOrConnectWithoutCreatedByInput = {
    where: LineageWhereUniqueInput
    create: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput>
  }

  export type LineageCreateManyCreatedByInputEnvelope = {
    data: LineageCreateManyCreatedByInput | LineageCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type LineageMembershipCreateWithoutAddedByInput = {
    id?: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
    lineage: LineageCreateNestedOneWithoutMembershipsInput
    profile: ProfileCreateNestedOneWithoutLineageMembershipsInput
  }

  export type LineageMembershipUncheckedCreateWithoutAddedByInput = {
    id?: string
    lineageId: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
  }

  export type LineageMembershipCreateOrConnectWithoutAddedByInput = {
    where: LineageMembershipWhereUniqueInput
    create: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput>
  }

  export type LineageMembershipCreateManyAddedByInputEnvelope = {
    data: LineageMembershipCreateManyAddedByInput | LineageMembershipCreateManyAddedByInput[]
    skipDuplicates?: boolean
  }

  export type ProfileInterestUpsertWithWhereUniqueWithoutUserInput = {
    where: ProfileInterestWhereUniqueInput
    update: XOR<ProfileInterestUpdateWithoutUserInput, ProfileInterestUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileInterestCreateWithoutUserInput, ProfileInterestUncheckedCreateWithoutUserInput>
  }

  export type ProfileInterestUpdateWithWhereUniqueWithoutUserInput = {
    where: ProfileInterestWhereUniqueInput
    data: XOR<ProfileInterestUpdateWithoutUserInput, ProfileInterestUncheckedUpdateWithoutUserInput>
  }

  export type ProfileInterestUpdateManyWithWhereWithoutUserInput = {
    where: ProfileInterestScalarWhereInput
    data: XOR<ProfileInterestUpdateManyMutationInput, ProfileInterestUncheckedUpdateManyWithoutUserInput>
  }

  export type ProfileInterestScalarWhereInput = {
    AND?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
    OR?: ProfileInterestScalarWhereInput[]
    NOT?: ProfileInterestScalarWhereInput | ProfileInterestScalarWhereInput[]
    userId?: UuidFilter<"ProfileInterest"> | string
    interestId?: UuidFilter<"ProfileInterest"> | string
    createdAt?: DateTimeFilter<"ProfileInterest"> | Date | string
  }

  export type PostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
    create: XOR<PostCreateWithoutAuthorInput, PostUncheckedCreateWithoutAuthorInput>
  }

  export type PostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutAuthorInput, PostUncheckedUpdateWithoutAuthorInput>
  }

  export type PostUpdateManyWithWhereWithoutAuthorInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type PostScalarWhereInput = {
    AND?: PostScalarWhereInput | PostScalarWhereInput[]
    OR?: PostScalarWhereInput[]
    NOT?: PostScalarWhereInput | PostScalarWhereInput[]
    id?: UuidFilter<"Post"> | string
    profileId?: UuidFilter<"Post"> | string
    content?: StringNullableFilter<"Post"> | string | null
    visibility?: EnumPostVisibilityFilter<"Post"> | $Enums.PostVisibility
    locationText?: StringNullableFilter<"Post"> | string | null
    lineageId?: UuidNullableFilter<"Post"> | string | null
    commentCount?: IntFilter<"Post"> | number
    likeCount?: IntFilter<"Post"> | number
    shareCount?: IntFilter<"Post"> | number
    createdAt?: DateTimeFilter<"Post"> | Date | string
    updatedAt?: DateTimeFilter<"Post"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: UuidFilter<"Comment"> | string
    postId?: UuidFilter<"Comment"> | string
    profileId?: UuidFilter<"Comment"> | string
    parentCommentId?: UuidNullableFilter<"Comment"> | string | null
    content?: StringFilter<"Comment"> | string
    likeCount?: IntFilter<"Comment"> | number
    createdAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: UuidFilter<"Message"> | string
    conversationId?: UuidFilter<"Message"> | string
    senderId?: UuidFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    timestamp?: DateTimeFilter<"Message"> | Date | string
  }

  export type MessageReadUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageReadWhereUniqueInput
    update: XOR<MessageReadUpdateWithoutUserInput, MessageReadUncheckedUpdateWithoutUserInput>
    create: XOR<MessageReadCreateWithoutUserInput, MessageReadUncheckedCreateWithoutUserInput>
  }

  export type MessageReadUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageReadWhereUniqueInput
    data: XOR<MessageReadUpdateWithoutUserInput, MessageReadUncheckedUpdateWithoutUserInput>
  }

  export type MessageReadUpdateManyWithWhereWithoutUserInput = {
    where: MessageReadScalarWhereInput
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageReadScalarWhereInput = {
    AND?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
    OR?: MessageReadScalarWhereInput[]
    NOT?: MessageReadScalarWhereInput | MessageReadScalarWhereInput[]
    messageId?: UuidFilter<"MessageRead"> | string
    userId?: UuidFilter<"MessageRead"> | string
    readAt?: DateTimeFilter<"MessageRead"> | Date | string
  }

  export type PostReactionUpsertWithWhereUniqueWithoutProfileInput = {
    where: PostReactionWhereUniqueInput
    update: XOR<PostReactionUpdateWithoutProfileInput, PostReactionUncheckedUpdateWithoutProfileInput>
    create: XOR<PostReactionCreateWithoutProfileInput, PostReactionUncheckedCreateWithoutProfileInput>
  }

  export type PostReactionUpdateWithWhereUniqueWithoutProfileInput = {
    where: PostReactionWhereUniqueInput
    data: XOR<PostReactionUpdateWithoutProfileInput, PostReactionUncheckedUpdateWithoutProfileInput>
  }

  export type PostReactionUpdateManyWithWhereWithoutProfileInput = {
    where: PostReactionScalarWhereInput
    data: XOR<PostReactionUpdateManyMutationInput, PostReactionUncheckedUpdateManyWithoutProfileInput>
  }

  export type PostReactionScalarWhereInput = {
    AND?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
    OR?: PostReactionScalarWhereInput[]
    NOT?: PostReactionScalarWhereInput | PostReactionScalarWhereInput[]
    id?: UuidFilter<"PostReaction"> | string
    postId?: UuidFilter<"PostReaction"> | string
    profileId?: UuidFilter<"PostReaction"> | string
    type?: EnumReactionTypeFilter<"PostReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"PostReaction"> | Date | string
  }

  export type ProfileSettingsUpsertWithoutProfileInput = {
    update: XOR<ProfileSettingsUpdateWithoutProfileInput, ProfileSettingsUncheckedUpdateWithoutProfileInput>
    create: XOR<ProfileSettingsCreateWithoutProfileInput, ProfileSettingsUncheckedCreateWithoutProfileInput>
    where?: ProfileSettingsWhereInput
  }

  export type ProfileSettingsUpdateToOneWithWhereWithoutProfileInput = {
    where?: ProfileSettingsWhereInput
    data: XOR<ProfileSettingsUpdateWithoutProfileInput, ProfileSettingsUncheckedUpdateWithoutProfileInput>
  }

  export type ProfileSettingsUpdateWithoutProfileInput = {
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileSettingsUncheckedUpdateWithoutProfileInput = {
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    showLastSeen?: BoolFieldUpdateOperationsInput | boolean
    allowTagging?: BoolFieldUpdateOperationsInput | boolean
    allowMessagesFrom?: StringFieldUpdateOperationsInput | string
    discoveryAllowLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUpsertWithWhereUniqueWithoutProfileInput = {
    where: LineageMembershipWhereUniqueInput
    update: XOR<LineageMembershipUpdateWithoutProfileInput, LineageMembershipUncheckedUpdateWithoutProfileInput>
    create: XOR<LineageMembershipCreateWithoutProfileInput, LineageMembershipUncheckedCreateWithoutProfileInput>
  }

  export type LineageMembershipUpdateWithWhereUniqueWithoutProfileInput = {
    where: LineageMembershipWhereUniqueInput
    data: XOR<LineageMembershipUpdateWithoutProfileInput, LineageMembershipUncheckedUpdateWithoutProfileInput>
  }

  export type LineageMembershipUpdateManyWithWhereWithoutProfileInput = {
    where: LineageMembershipScalarWhereInput
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyWithoutProfileInput>
  }

  export type LineageMembershipScalarWhereInput = {
    AND?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
    OR?: LineageMembershipScalarWhereInput[]
    NOT?: LineageMembershipScalarWhereInput | LineageMembershipScalarWhereInput[]
    id?: UuidFilter<"LineageMembership"> | string
    lineageId?: UuidFilter<"LineageMembership"> | string
    profileId?: UuidFilter<"LineageMembership"> | string
    role?: EnumLineageRoleFilter<"LineageMembership"> | $Enums.LineageRole
    generation?: IntNullableFilter<"LineageMembership"> | number | null
    isPrimaryLineage?: BoolFilter<"LineageMembership"> | boolean
    addedById?: UuidNullableFilter<"LineageMembership"> | string | null
    createdAt?: DateTimeFilter<"LineageMembership"> | Date | string
  }

  export type KinshipUpsertWithWhereUniqueWithoutProfileAInput = {
    where: KinshipWhereUniqueInput
    update: XOR<KinshipUpdateWithoutProfileAInput, KinshipUncheckedUpdateWithoutProfileAInput>
    create: XOR<KinshipCreateWithoutProfileAInput, KinshipUncheckedCreateWithoutProfileAInput>
  }

  export type KinshipUpdateWithWhereUniqueWithoutProfileAInput = {
    where: KinshipWhereUniqueInput
    data: XOR<KinshipUpdateWithoutProfileAInput, KinshipUncheckedUpdateWithoutProfileAInput>
  }

  export type KinshipUpdateManyWithWhereWithoutProfileAInput = {
    where: KinshipScalarWhereInput
    data: XOR<KinshipUpdateManyMutationInput, KinshipUncheckedUpdateManyWithoutProfileAInput>
  }

  export type KinshipScalarWhereInput = {
    AND?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
    OR?: KinshipScalarWhereInput[]
    NOT?: KinshipScalarWhereInput | KinshipScalarWhereInput[]
    id?: UuidFilter<"Kinship"> | string
    profileIdA?: UuidFilter<"Kinship"> | string
    profileIdB?: UuidFilter<"Kinship"> | string
    relationAtoB?: EnumKinshipTypeFilter<"Kinship"> | $Enums.KinshipType
    verified?: BoolFilter<"Kinship"> | boolean
    verifiedById?: UuidNullableFilter<"Kinship"> | string | null
    createdAt?: DateTimeFilter<"Kinship"> | Date | string
  }

  export type KinshipUpsertWithWhereUniqueWithoutProfileBInput = {
    where: KinshipWhereUniqueInput
    update: XOR<KinshipUpdateWithoutProfileBInput, KinshipUncheckedUpdateWithoutProfileBInput>
    create: XOR<KinshipCreateWithoutProfileBInput, KinshipUncheckedCreateWithoutProfileBInput>
  }

  export type KinshipUpdateWithWhereUniqueWithoutProfileBInput = {
    where: KinshipWhereUniqueInput
    data: XOR<KinshipUpdateWithoutProfileBInput, KinshipUncheckedUpdateWithoutProfileBInput>
  }

  export type KinshipUpdateManyWithWhereWithoutProfileBInput = {
    where: KinshipScalarWhereInput
    data: XOR<KinshipUpdateManyMutationInput, KinshipUncheckedUpdateManyWithoutProfileBInput>
  }

  export type CommentReactionUpsertWithWhereUniqueWithoutProfileInput = {
    where: CommentReactionWhereUniqueInput
    update: XOR<CommentReactionUpdateWithoutProfileInput, CommentReactionUncheckedUpdateWithoutProfileInput>
    create: XOR<CommentReactionCreateWithoutProfileInput, CommentReactionUncheckedCreateWithoutProfileInput>
  }

  export type CommentReactionUpdateWithWhereUniqueWithoutProfileInput = {
    where: CommentReactionWhereUniqueInput
    data: XOR<CommentReactionUpdateWithoutProfileInput, CommentReactionUncheckedUpdateWithoutProfileInput>
  }

  export type CommentReactionUpdateManyWithWhereWithoutProfileInput = {
    where: CommentReactionScalarWhereInput
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyWithoutProfileInput>
  }

  export type CommentReactionScalarWhereInput = {
    AND?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
    OR?: CommentReactionScalarWhereInput[]
    NOT?: CommentReactionScalarWhereInput | CommentReactionScalarWhereInput[]
    id?: UuidFilter<"CommentReaction"> | string
    commentId?: UuidFilter<"CommentReaction"> | string
    profileId?: UuidFilter<"CommentReaction"> | string
    type?: EnumReactionTypeFilter<"CommentReaction"> | $Enums.ReactionType
    createdAt?: DateTimeFilter<"CommentReaction"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
    create: XOR<FollowCreateWithoutFollowerInput, FollowUncheckedCreateWithoutFollowerInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFollowerInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFollowerInput, FollowUncheckedUpdateWithoutFollowerInput>
  }

  export type FollowUpdateManyWithWhereWithoutFollowerInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFollowerInput>
  }

  export type FollowScalarWhereInput = {
    AND?: FollowScalarWhereInput | FollowScalarWhereInput[]
    OR?: FollowScalarWhereInput[]
    NOT?: FollowScalarWhereInput | FollowScalarWhereInput[]
    id?: UuidFilter<"Follow"> | string
    followerId?: UuidFilter<"Follow"> | string
    followeeId?: UuidFilter<"Follow"> | string
    createdAt?: DateTimeFilter<"Follow"> | Date | string
  }

  export type FollowUpsertWithWhereUniqueWithoutFolloweeInput = {
    where: FollowWhereUniqueInput
    update: XOR<FollowUpdateWithoutFolloweeInput, FollowUncheckedUpdateWithoutFolloweeInput>
    create: XOR<FollowCreateWithoutFolloweeInput, FollowUncheckedCreateWithoutFolloweeInput>
  }

  export type FollowUpdateWithWhereUniqueWithoutFolloweeInput = {
    where: FollowWhereUniqueInput
    data: XOR<FollowUpdateWithoutFolloweeInput, FollowUncheckedUpdateWithoutFolloweeInput>
  }

  export type FollowUpdateManyWithWhereWithoutFolloweeInput = {
    where: FollowScalarWhereInput
    data: XOR<FollowUpdateManyMutationInput, FollowUncheckedUpdateManyWithoutFolloweeInput>
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
    create: XOR<BlockCreateWithoutBlockerInput, BlockUncheckedCreateWithoutBlockerInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockerInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockerInput, BlockUncheckedUpdateWithoutBlockerInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockerInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockerInput>
  }

  export type BlockScalarWhereInput = {
    AND?: BlockScalarWhereInput | BlockScalarWhereInput[]
    OR?: BlockScalarWhereInput[]
    NOT?: BlockScalarWhereInput | BlockScalarWhereInput[]
    id?: UuidFilter<"Block"> | string
    blockerId?: UuidFilter<"Block"> | string
    blockedId?: UuidFilter<"Block"> | string
    createdAt?: DateTimeFilter<"Block"> | Date | string
  }

  export type BlockUpsertWithWhereUniqueWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    update: XOR<BlockUpdateWithoutBlockedInput, BlockUncheckedUpdateWithoutBlockedInput>
    create: XOR<BlockCreateWithoutBlockedInput, BlockUncheckedCreateWithoutBlockedInput>
  }

  export type BlockUpdateWithWhereUniqueWithoutBlockedInput = {
    where: BlockWhereUniqueInput
    data: XOR<BlockUpdateWithoutBlockedInput, BlockUncheckedUpdateWithoutBlockedInput>
  }

  export type BlockUpdateManyWithWhereWithoutBlockedInput = {
    where: BlockScalarWhereInput
    data: XOR<BlockUpdateManyMutationInput, BlockUncheckedUpdateManyWithoutBlockedInput>
  }

  export type MuteUpsertWithWhereUniqueWithoutMuterInput = {
    where: MuteWhereUniqueInput
    update: XOR<MuteUpdateWithoutMuterInput, MuteUncheckedUpdateWithoutMuterInput>
    create: XOR<MuteCreateWithoutMuterInput, MuteUncheckedCreateWithoutMuterInput>
  }

  export type MuteUpdateWithWhereUniqueWithoutMuterInput = {
    where: MuteWhereUniqueInput
    data: XOR<MuteUpdateWithoutMuterInput, MuteUncheckedUpdateWithoutMuterInput>
  }

  export type MuteUpdateManyWithWhereWithoutMuterInput = {
    where: MuteScalarWhereInput
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyWithoutMuterInput>
  }

  export type MuteScalarWhereInput = {
    AND?: MuteScalarWhereInput | MuteScalarWhereInput[]
    OR?: MuteScalarWhereInput[]
    NOT?: MuteScalarWhereInput | MuteScalarWhereInput[]
    id?: UuidFilter<"Mute"> | string
    muterId?: UuidFilter<"Mute"> | string
    mutedId?: UuidFilter<"Mute"> | string
    createdAt?: DateTimeFilter<"Mute"> | Date | string
  }

  export type MuteUpsertWithWhereUniqueWithoutMutedInput = {
    where: MuteWhereUniqueInput
    update: XOR<MuteUpdateWithoutMutedInput, MuteUncheckedUpdateWithoutMutedInput>
    create: XOR<MuteCreateWithoutMutedInput, MuteUncheckedCreateWithoutMutedInput>
  }

  export type MuteUpdateWithWhereUniqueWithoutMutedInput = {
    where: MuteWhereUniqueInput
    data: XOR<MuteUpdateWithoutMutedInput, MuteUncheckedUpdateWithoutMutedInput>
  }

  export type MuteUpdateManyWithWhereWithoutMutedInput = {
    where: MuteScalarWhereInput
    data: XOR<MuteUpdateManyMutationInput, MuteUncheckedUpdateManyWithoutMutedInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutCreatedByInput, ConversationUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ConversationCreateWithoutCreatedByInput, ConversationUncheckedCreateWithoutCreatedByInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutCreatedByInput, ConversationUncheckedUpdateWithoutCreatedByInput>
  }

  export type ConversationUpdateManyWithWhereWithoutCreatedByInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: UuidFilter<"Conversation"> | string
    isGroup?: BoolFilter<"Conversation"> | boolean
    title?: StringNullableFilter<"Conversation"> | string | null
    createdById?: UuidNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutProfileInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutProfileInput, ConversationParticipantUncheckedUpdateWithoutProfileInput>
    create: XOR<ConversationParticipantCreateWithoutProfileInput, ConversationParticipantUncheckedCreateWithoutProfileInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutProfileInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutProfileInput, ConversationParticipantUncheckedUpdateWithoutProfileInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutProfileInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutProfileInput>
  }

  export type ConversationParticipantScalarWhereInput = {
    AND?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    OR?: ConversationParticipantScalarWhereInput[]
    NOT?: ConversationParticipantScalarWhereInput | ConversationParticipantScalarWhereInput[]
    id?: UuidFilter<"ConversationParticipant"> | string
    conversationId?: UuidFilter<"ConversationParticipant"> | string
    profileId?: UuidFilter<"ConversationParticipant"> | string
    role?: StringFilter<"ConversationParticipant"> | string
    lastReadAt?: DateTimeNullableFilter<"ConversationParticipant"> | Date | string | null
    joinedAt?: DateTimeFilter<"ConversationParticipant"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: UuidFilter<"Notification"> | string
    recipientId?: UuidFilter<"Notification"> | string
    actorId?: UuidNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    postId?: UuidNullableFilter<"Notification"> | string | null
    commentId?: UuidNullableFilter<"Notification"> | string | null
    lineageId?: UuidNullableFilter<"Notification"> | string | null
    messageId?: UuidNullableFilter<"Notification"> | string | null
    isRead?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutActorInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutActorInput, NotificationUncheckedUpdateWithoutActorInput>
    create: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutActorInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutActorInput, NotificationUncheckedUpdateWithoutActorInput>
  }

  export type NotificationUpdateManyWithWhereWithoutActorInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutActorInput>
  }

  export type LineageUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: LineageWhereUniqueInput
    update: XOR<LineageUpdateWithoutCreatedByInput, LineageUncheckedUpdateWithoutCreatedByInput>
    create: XOR<LineageCreateWithoutCreatedByInput, LineageUncheckedCreateWithoutCreatedByInput>
  }

  export type LineageUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: LineageWhereUniqueInput
    data: XOR<LineageUpdateWithoutCreatedByInput, LineageUncheckedUpdateWithoutCreatedByInput>
  }

  export type LineageUpdateManyWithWhereWithoutCreatedByInput = {
    where: LineageScalarWhereInput
    data: XOR<LineageUpdateManyMutationInput, LineageUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type LineageScalarWhereInput = {
    AND?: LineageScalarWhereInput | LineageScalarWhereInput[]
    OR?: LineageScalarWhereInput[]
    NOT?: LineageScalarWhereInput | LineageScalarWhereInput[]
    id?: UuidFilter<"Lineage"> | string
    name?: StringFilter<"Lineage"> | string
    type?: EnumLineageTypeFilter<"Lineage"> | $Enums.LineageType
    primarySurname?: StringNullableFilter<"Lineage"> | string | null
    rootVillage?: StringNullableFilter<"Lineage"> | string | null
    rootRegion?: StringNullableFilter<"Lineage"> | string | null
    description?: StringNullableFilter<"Lineage"> | string | null
    createdById?: UuidNullableFilter<"Lineage"> | string | null
    createdAt?: DateTimeFilter<"Lineage"> | Date | string
    updatedAt?: DateTimeFilter<"Lineage"> | Date | string
  }

  export type LineageMembershipUpsertWithWhereUniqueWithoutAddedByInput = {
    where: LineageMembershipWhereUniqueInput
    update: XOR<LineageMembershipUpdateWithoutAddedByInput, LineageMembershipUncheckedUpdateWithoutAddedByInput>
    create: XOR<LineageMembershipCreateWithoutAddedByInput, LineageMembershipUncheckedCreateWithoutAddedByInput>
  }

  export type LineageMembershipUpdateWithWhereUniqueWithoutAddedByInput = {
    where: LineageMembershipWhereUniqueInput
    data: XOR<LineageMembershipUpdateWithoutAddedByInput, LineageMembershipUncheckedUpdateWithoutAddedByInput>
  }

  export type LineageMembershipUpdateManyWithWhereWithoutAddedByInput = {
    where: LineageMembershipScalarWhereInput
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyWithoutAddedByInput>
  }

  export type ProfileCreateWithoutSettingsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutSettingsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutSettingsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
  }

  export type ProfileUpsertWithoutSettingsInput = {
    update: XOR<ProfileUpdateWithoutSettingsInput, ProfileUncheckedUpdateWithoutSettingsInput>
    create: XOR<ProfileCreateWithoutSettingsInput, ProfileUncheckedCreateWithoutSettingsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutSettingsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutSettingsInput, ProfileUncheckedUpdateWithoutSettingsInput>
  }

  export type ProfileUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileCreateWithoutLineagesCreatedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutLineagesCreatedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutLineagesCreatedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLineagesCreatedInput, ProfileUncheckedCreateWithoutLineagesCreatedInput>
  }

  export type LineageMembershipCreateWithoutLineageInput = {
    id?: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutLineageMembershipsInput
    addedBy?: ProfileCreateNestedOneWithoutLineageMembershipsAddedInput
  }

  export type LineageMembershipUncheckedCreateWithoutLineageInput = {
    id?: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type LineageMembershipCreateOrConnectWithoutLineageInput = {
    where: LineageMembershipWhereUniqueInput
    create: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput>
  }

  export type LineageMembershipCreateManyLineageInputEnvelope = {
    data: LineageMembershipCreateManyLineageInput | LineageMembershipCreateManyLineageInput[]
    skipDuplicates?: boolean
  }

  export type PostCreateWithoutLineageInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: ProfileCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutLineageInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutLineageInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput>
  }

  export type PostCreateManyLineageInputEnvelope = {
    data: PostCreateManyLineageInput | PostCreateManyLineageInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutLineageInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
    actor?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutLineageInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutLineageInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput>
  }

  export type NotificationCreateManyLineageInputEnvelope = {
    data: NotificationCreateManyLineageInput | NotificationCreateManyLineageInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutLineagesCreatedInput = {
    update: XOR<ProfileUpdateWithoutLineagesCreatedInput, ProfileUncheckedUpdateWithoutLineagesCreatedInput>
    create: XOR<ProfileCreateWithoutLineagesCreatedInput, ProfileUncheckedCreateWithoutLineagesCreatedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutLineagesCreatedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutLineagesCreatedInput, ProfileUncheckedUpdateWithoutLineagesCreatedInput>
  }

  export type ProfileUpdateWithoutLineagesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLineagesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type LineageMembershipUpsertWithWhereUniqueWithoutLineageInput = {
    where: LineageMembershipWhereUniqueInput
    update: XOR<LineageMembershipUpdateWithoutLineageInput, LineageMembershipUncheckedUpdateWithoutLineageInput>
    create: XOR<LineageMembershipCreateWithoutLineageInput, LineageMembershipUncheckedCreateWithoutLineageInput>
  }

  export type LineageMembershipUpdateWithWhereUniqueWithoutLineageInput = {
    where: LineageMembershipWhereUniqueInput
    data: XOR<LineageMembershipUpdateWithoutLineageInput, LineageMembershipUncheckedUpdateWithoutLineageInput>
  }

  export type LineageMembershipUpdateManyWithWhereWithoutLineageInput = {
    where: LineageMembershipScalarWhereInput
    data: XOR<LineageMembershipUpdateManyMutationInput, LineageMembershipUncheckedUpdateManyWithoutLineageInput>
  }

  export type PostUpsertWithWhereUniqueWithoutLineageInput = {
    where: PostWhereUniqueInput
    update: XOR<PostUpdateWithoutLineageInput, PostUncheckedUpdateWithoutLineageInput>
    create: XOR<PostCreateWithoutLineageInput, PostUncheckedCreateWithoutLineageInput>
  }

  export type PostUpdateWithWhereUniqueWithoutLineageInput = {
    where: PostWhereUniqueInput
    data: XOR<PostUpdateWithoutLineageInput, PostUncheckedUpdateWithoutLineageInput>
  }

  export type PostUpdateManyWithWhereWithoutLineageInput = {
    where: PostScalarWhereInput
    data: XOR<PostUpdateManyMutationInput, PostUncheckedUpdateManyWithoutLineageInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutLineageInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutLineageInput, NotificationUncheckedUpdateWithoutLineageInput>
    create: XOR<NotificationCreateWithoutLineageInput, NotificationUncheckedCreateWithoutLineageInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutLineageInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutLineageInput, NotificationUncheckedUpdateWithoutLineageInput>
  }

  export type NotificationUpdateManyWithWhereWithoutLineageInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutLineageInput>
  }

  export type LineageCreateWithoutMembershipsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutLineagesCreatedInput
    posts?: PostCreateNestedManyWithoutLineageInput
    notifications?: NotificationCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutLineageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageCreateOrConnectWithoutMembershipsInput = {
    where: LineageWhereUniqueInput
    create: XOR<LineageCreateWithoutMembershipsInput, LineageUncheckedCreateWithoutMembershipsInput>
  }

  export type ProfileCreateWithoutLineageMembershipsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutLineageMembershipsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutLineageMembershipsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLineageMembershipsInput, ProfileUncheckedCreateWithoutLineageMembershipsInput>
  }

  export type ProfileCreateWithoutLineageMembershipsAddedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
  }

  export type ProfileUncheckedCreateWithoutLineageMembershipsAddedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type ProfileCreateOrConnectWithoutLineageMembershipsAddedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutLineageMembershipsAddedInput, ProfileUncheckedCreateWithoutLineageMembershipsAddedInput>
  }

  export type LineageUpsertWithoutMembershipsInput = {
    update: XOR<LineageUpdateWithoutMembershipsInput, LineageUncheckedUpdateWithoutMembershipsInput>
    create: XOR<LineageCreateWithoutMembershipsInput, LineageUncheckedCreateWithoutMembershipsInput>
    where?: LineageWhereInput
  }

  export type LineageUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: LineageWhereInput
    data: XOR<LineageUpdateWithoutMembershipsInput, LineageUncheckedUpdateWithoutMembershipsInput>
  }

  export type LineageUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutLineagesCreatedNestedInput
    posts?: PostUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type ProfileUpsertWithoutLineageMembershipsInput = {
    update: XOR<ProfileUpdateWithoutLineageMembershipsInput, ProfileUncheckedUpdateWithoutLineageMembershipsInput>
    create: XOR<ProfileCreateWithoutLineageMembershipsInput, ProfileUncheckedCreateWithoutLineageMembershipsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutLineageMembershipsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutLineageMembershipsInput, ProfileUncheckedUpdateWithoutLineageMembershipsInput>
  }

  export type ProfileUpdateWithoutLineageMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLineageMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUpsertWithoutLineageMembershipsAddedInput = {
    update: XOR<ProfileUpdateWithoutLineageMembershipsAddedInput, ProfileUncheckedUpdateWithoutLineageMembershipsAddedInput>
    create: XOR<ProfileCreateWithoutLineageMembershipsAddedInput, ProfileUncheckedCreateWithoutLineageMembershipsAddedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutLineageMembershipsAddedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutLineageMembershipsAddedInput, ProfileUncheckedUpdateWithoutLineageMembershipsAddedInput>
  }

  export type ProfileUpdateWithoutLineageMembershipsAddedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutLineageMembershipsAddedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ProfileCreateWithoutKinshipsAInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutKinshipsAInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutKinshipsAInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutKinshipsAInput, ProfileUncheckedCreateWithoutKinshipsAInput>
  }

  export type ProfileCreateWithoutKinshipsBInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutKinshipsBInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutKinshipsBInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutKinshipsBInput, ProfileUncheckedCreateWithoutKinshipsBInput>
  }

  export type ProfileUpsertWithoutKinshipsAInput = {
    update: XOR<ProfileUpdateWithoutKinshipsAInput, ProfileUncheckedUpdateWithoutKinshipsAInput>
    create: XOR<ProfileCreateWithoutKinshipsAInput, ProfileUncheckedCreateWithoutKinshipsAInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutKinshipsAInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutKinshipsAInput, ProfileUncheckedUpdateWithoutKinshipsAInput>
  }

  export type ProfileUpdateWithoutKinshipsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutKinshipsAInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUpsertWithoutKinshipsBInput = {
    update: XOR<ProfileUpdateWithoutKinshipsBInput, ProfileUncheckedUpdateWithoutKinshipsBInput>
    create: XOR<ProfileCreateWithoutKinshipsBInput, ProfileUncheckedCreateWithoutKinshipsBInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutKinshipsBInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutKinshipsBInput, ProfileUncheckedUpdateWithoutKinshipsBInput>
  }

  export type ProfileUpdateWithoutKinshipsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutKinshipsBInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileCreateWithoutFollowsAsFollowerInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutFollowsAsFollowerInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutFollowsAsFollowerInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutFollowsAsFollowerInput, ProfileUncheckedCreateWithoutFollowsAsFollowerInput>
  }

  export type ProfileCreateWithoutFollowsAsFolloweeInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutFollowsAsFolloweeInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutFollowsAsFolloweeInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutFollowsAsFolloweeInput, ProfileUncheckedCreateWithoutFollowsAsFolloweeInput>
  }

  export type ProfileUpsertWithoutFollowsAsFollowerInput = {
    update: XOR<ProfileUpdateWithoutFollowsAsFollowerInput, ProfileUncheckedUpdateWithoutFollowsAsFollowerInput>
    create: XOR<ProfileCreateWithoutFollowsAsFollowerInput, ProfileUncheckedCreateWithoutFollowsAsFollowerInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutFollowsAsFollowerInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutFollowsAsFollowerInput, ProfileUncheckedUpdateWithoutFollowsAsFollowerInput>
  }

  export type ProfileUpdateWithoutFollowsAsFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutFollowsAsFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUpsertWithoutFollowsAsFolloweeInput = {
    update: XOR<ProfileUpdateWithoutFollowsAsFolloweeInput, ProfileUncheckedUpdateWithoutFollowsAsFolloweeInput>
    create: XOR<ProfileCreateWithoutFollowsAsFolloweeInput, ProfileUncheckedCreateWithoutFollowsAsFolloweeInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutFollowsAsFolloweeInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutFollowsAsFolloweeInput, ProfileUncheckedUpdateWithoutFollowsAsFolloweeInput>
  }

  export type ProfileUpdateWithoutFollowsAsFolloweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutFollowsAsFolloweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileCreateWithoutBlocksAsBlockerInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutBlocksAsBlockerInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutBlocksAsBlockerInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutBlocksAsBlockerInput, ProfileUncheckedCreateWithoutBlocksAsBlockerInput>
  }

  export type ProfileCreateWithoutBlocksAsBlockedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutBlocksAsBlockedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutBlocksAsBlockedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutBlocksAsBlockedInput, ProfileUncheckedCreateWithoutBlocksAsBlockedInput>
  }

  export type ProfileUpsertWithoutBlocksAsBlockerInput = {
    update: XOR<ProfileUpdateWithoutBlocksAsBlockerInput, ProfileUncheckedUpdateWithoutBlocksAsBlockerInput>
    create: XOR<ProfileCreateWithoutBlocksAsBlockerInput, ProfileUncheckedCreateWithoutBlocksAsBlockerInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutBlocksAsBlockerInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutBlocksAsBlockerInput, ProfileUncheckedUpdateWithoutBlocksAsBlockerInput>
  }

  export type ProfileUpdateWithoutBlocksAsBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutBlocksAsBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUpsertWithoutBlocksAsBlockedInput = {
    update: XOR<ProfileUpdateWithoutBlocksAsBlockedInput, ProfileUncheckedUpdateWithoutBlocksAsBlockedInput>
    create: XOR<ProfileCreateWithoutBlocksAsBlockedInput, ProfileUncheckedCreateWithoutBlocksAsBlockedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutBlocksAsBlockedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutBlocksAsBlockedInput, ProfileUncheckedUpdateWithoutBlocksAsBlockedInput>
  }

  export type ProfileUpdateWithoutBlocksAsBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutBlocksAsBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileCreateWithoutMutesAsMuterInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutMutesAsMuterInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutMutesAsMuterInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMutesAsMuterInput, ProfileUncheckedCreateWithoutMutesAsMuterInput>
  }

  export type ProfileCreateWithoutMutesAsMutedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutMutesAsMutedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutMutesAsMutedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMutesAsMutedInput, ProfileUncheckedCreateWithoutMutesAsMutedInput>
  }

  export type ProfileUpsertWithoutMutesAsMuterInput = {
    update: XOR<ProfileUpdateWithoutMutesAsMuterInput, ProfileUncheckedUpdateWithoutMutesAsMuterInput>
    create: XOR<ProfileCreateWithoutMutesAsMuterInput, ProfileUncheckedCreateWithoutMutesAsMuterInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMutesAsMuterInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMutesAsMuterInput, ProfileUncheckedUpdateWithoutMutesAsMuterInput>
  }

  export type ProfileUpdateWithoutMutesAsMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMutesAsMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUpsertWithoutMutesAsMutedInput = {
    update: XOR<ProfileUpdateWithoutMutesAsMutedInput, ProfileUncheckedUpdateWithoutMutesAsMutedInput>
    create: XOR<ProfileCreateWithoutMutesAsMutedInput, ProfileUncheckedCreateWithoutMutesAsMutedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMutesAsMutedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMutesAsMutedInput, ProfileUncheckedUpdateWithoutMutesAsMutedInput>
  }

  export type ProfileUpdateWithoutMutesAsMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMutesAsMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileCreateWithoutPostsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutPostsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutPostsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
  }

  export type LineageCreateWithoutPostsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutLineagesCreatedInput
    memberships?: LineageMembershipCreateNestedManyWithoutLineageInput
    notifications?: NotificationCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateWithoutPostsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipUncheckedCreateNestedManyWithoutLineageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageCreateOrConnectWithoutPostsInput = {
    where: LineageWhereUniqueInput
    create: XOR<LineageCreateWithoutPostsInput, LineageUncheckedCreateWithoutPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    author: ProfileCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type PostReactionCreateWithoutPostInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutPostReactionsInput
  }

  export type PostReactionUncheckedCreateWithoutPostInput = {
    id?: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type PostReactionCreateOrConnectWithoutPostInput = {
    where: PostReactionWhereUniqueInput
    create: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput>
  }

  export type PostReactionCreateManyPostInputEnvelope = {
    data: PostReactionCreateManyPostInput | PostReactionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type MediaFileCreateWithoutPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaFileUncheckedCreateWithoutPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaFileCreateOrConnectWithoutPostInput = {
    where: MediaFileWhereUniqueInput
    create: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput>
  }

  export type MediaFileCreateManyPostInputEnvelope = {
    data: MediaFileCreateManyPostInput | MediaFileCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutPostInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
    actor?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutPostInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutPostInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput>
  }

  export type NotificationCreateManyPostInputEnvelope = {
    data: NotificationCreateManyPostInput | NotificationCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutPostsInput = {
    update: XOR<ProfileUpdateWithoutPostsInput, ProfileUncheckedUpdateWithoutPostsInput>
    create: XOR<ProfileCreateWithoutPostsInput, ProfileUncheckedCreateWithoutPostsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostsInput, ProfileUncheckedUpdateWithoutPostsInput>
  }

  export type ProfileUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type LineageUpsertWithoutPostsInput = {
    update: XOR<LineageUpdateWithoutPostsInput, LineageUncheckedUpdateWithoutPostsInput>
    create: XOR<LineageCreateWithoutPostsInput, LineageUncheckedCreateWithoutPostsInput>
    where?: LineageWhereInput
  }

  export type LineageUpdateToOneWithWhereWithoutPostsInput = {
    where?: LineageWhereInput
    data: XOR<LineageUpdateWithoutPostsInput, LineageUncheckedUpdateWithoutPostsInput>
  }

  export type LineageUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutLineagesCreatedNestedInput
    memberships?: LineageMembershipUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateWithoutPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostReactionUpsertWithWhereUniqueWithoutPostInput = {
    where: PostReactionWhereUniqueInput
    update: XOR<PostReactionUpdateWithoutPostInput, PostReactionUncheckedUpdateWithoutPostInput>
    create: XOR<PostReactionCreateWithoutPostInput, PostReactionUncheckedCreateWithoutPostInput>
  }

  export type PostReactionUpdateWithWhereUniqueWithoutPostInput = {
    where: PostReactionWhereUniqueInput
    data: XOR<PostReactionUpdateWithoutPostInput, PostReactionUncheckedUpdateWithoutPostInput>
  }

  export type PostReactionUpdateManyWithWhereWithoutPostInput = {
    where: PostReactionScalarWhereInput
    data: XOR<PostReactionUpdateManyMutationInput, PostReactionUncheckedUpdateManyWithoutPostInput>
  }

  export type MediaFileUpsertWithWhereUniqueWithoutPostInput = {
    where: MediaFileWhereUniqueInput
    update: XOR<MediaFileUpdateWithoutPostInput, MediaFileUncheckedUpdateWithoutPostInput>
    create: XOR<MediaFileCreateWithoutPostInput, MediaFileUncheckedCreateWithoutPostInput>
  }

  export type MediaFileUpdateWithWhereUniqueWithoutPostInput = {
    where: MediaFileWhereUniqueInput
    data: XOR<MediaFileUpdateWithoutPostInput, MediaFileUncheckedUpdateWithoutPostInput>
  }

  export type MediaFileUpdateManyWithWhereWithoutPostInput = {
    where: MediaFileScalarWhereInput
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyWithoutPostInput>
  }

  export type MediaFileScalarWhereInput = {
    AND?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
    OR?: MediaFileScalarWhereInput[]
    NOT?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
    id?: UuidFilter<"MediaFile"> | string
    postId?: UuidFilter<"MediaFile"> | string
    type?: EnumMediaTypeFilter<"MediaFile"> | $Enums.MediaType
    url?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    width?: IntNullableFilter<"MediaFile"> | number | null
    height?: IntNullableFilter<"MediaFile"> | number | null
    sizeBytes?: BigIntFilter<"MediaFile"> | bigint | number
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    updatedAt?: DateTimeFilter<"MediaFile"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutPostInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutPostInput, NotificationUncheckedUpdateWithoutPostInput>
    create: XOR<NotificationCreateWithoutPostInput, NotificationUncheckedCreateWithoutPostInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutPostInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutPostInput, NotificationUncheckedUpdateWithoutPostInput>
  }

  export type NotificationUpdateManyWithWhereWithoutPostInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutPostInput>
  }

  export type PostCreateWithoutMediaFilesInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: ProfileCreateNestedOneWithoutPostsInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutMediaFilesInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutMediaFilesInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutMediaFilesInput, PostUncheckedCreateWithoutMediaFilesInput>
  }

  export type PostUpsertWithoutMediaFilesInput = {
    update: XOR<PostUpdateWithoutMediaFilesInput, PostUncheckedUpdateWithoutMediaFilesInput>
    create: XOR<PostCreateWithoutMediaFilesInput, PostUncheckedCreateWithoutMediaFilesInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutMediaFilesInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutMediaFilesInput, PostUncheckedUpdateWithoutMediaFilesInput>
  }

  export type PostUpdateWithoutMediaFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutMediaFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostCreateWithoutCommentsInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: ProfileCreateNestedOneWithoutPostsInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutCommentsInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutCommentsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
  }

  export type ProfileCreateWithoutCommentsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutCommentsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutCommentsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutCommentsInput, ProfileUncheckedCreateWithoutCommentsInput>
  }

  export type CommentCreateWithoutRepliesInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutRepliesInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutRepliesInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
  }

  export type CommentCreateWithoutParentCommentInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutParentCommentInput = {
    id?: string
    postId: string
    profileId: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentCreateManyParentCommentInputEnvelope = {
    data: CommentCreateManyParentCommentInput | CommentCreateManyParentCommentInput[]
    skipDuplicates?: boolean
  }

  export type CommentReactionCreateWithoutCommentInput = {
    id?: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
    profile: ProfileCreateNestedOneWithoutCommentReactionsInput
  }

  export type CommentReactionUncheckedCreateWithoutCommentInput = {
    id?: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type CommentReactionCreateOrConnectWithoutCommentInput = {
    where: CommentReactionWhereUniqueInput
    create: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput>
  }

  export type CommentReactionCreateManyCommentInputEnvelope = {
    data: CommentReactionCreateManyCommentInput | CommentReactionCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutCommentInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
    actor?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
    message?: MessageCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutCommentInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput>
  }

  export type NotificationCreateManyCommentInputEnvelope = {
    data: NotificationCreateManyCommentInput | NotificationCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type PostUpsertWithoutCommentsInput = {
    update: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
    create: XOR<PostCreateWithoutCommentsInput, PostUncheckedCreateWithoutCommentsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutCommentsInput, PostUncheckedUpdateWithoutCommentsInput>
  }

  export type PostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ProfileUpsertWithoutCommentsInput = {
    update: XOR<ProfileUpdateWithoutCommentsInput, ProfileUncheckedUpdateWithoutCommentsInput>
    create: XOR<ProfileCreateWithoutCommentsInput, ProfileUncheckedCreateWithoutCommentsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutCommentsInput, ProfileUncheckedUpdateWithoutCommentsInput>
  }

  export type ProfileUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type CommentUpsertWithoutRepliesInput = {
    update: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<CommentCreateWithoutRepliesInput, CommentUncheckedCreateWithoutRepliesInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutRepliesInput, CommentUncheckedUpdateWithoutRepliesInput>
  }

  export type CommentUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<CommentCreateWithoutParentCommentInput, CommentUncheckedCreateWithoutParentCommentInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutParentCommentInput, CommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type CommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutParentCommentInput>
  }

  export type CommentReactionUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentReactionWhereUniqueInput
    update: XOR<CommentReactionUpdateWithoutCommentInput, CommentReactionUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentReactionCreateWithoutCommentInput, CommentReactionUncheckedCreateWithoutCommentInput>
  }

  export type CommentReactionUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentReactionWhereUniqueInput
    data: XOR<CommentReactionUpdateWithoutCommentInput, CommentReactionUncheckedUpdateWithoutCommentInput>
  }

  export type CommentReactionUpdateManyWithWhereWithoutCommentInput = {
    where: CommentReactionScalarWhereInput
    data: XOR<CommentReactionUpdateManyMutationInput, CommentReactionUncheckedUpdateManyWithoutCommentInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutCommentInput, NotificationUncheckedUpdateWithoutCommentInput>
    create: XOR<NotificationCreateWithoutCommentInput, NotificationUncheckedCreateWithoutCommentInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutCommentInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutCommentInput, NotificationUncheckedUpdateWithoutCommentInput>
  }

  export type NotificationUpdateManyWithWhereWithoutCommentInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutCommentInput>
  }

  export type PostCreateWithoutReactionsInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: ProfileCreateNestedOneWithoutPostsInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
    notifications?: NotificationCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutReactionsInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutReactionsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
  }

  export type ProfileCreateWithoutPostReactionsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutPostReactionsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutPostReactionsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutPostReactionsInput, ProfileUncheckedCreateWithoutPostReactionsInput>
  }

  export type PostUpsertWithoutReactionsInput = {
    update: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
    create: XOR<PostCreateWithoutReactionsInput, PostUncheckedCreateWithoutReactionsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutReactionsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutReactionsInput, PostUncheckedUpdateWithoutReactionsInput>
  }

  export type PostUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ProfileUpsertWithoutPostReactionsInput = {
    update: XOR<ProfileUpdateWithoutPostReactionsInput, ProfileUncheckedUpdateWithoutPostReactionsInput>
    create: XOR<ProfileCreateWithoutPostReactionsInput, ProfileUncheckedCreateWithoutPostReactionsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutPostReactionsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutPostReactionsInput, ProfileUncheckedUpdateWithoutPostReactionsInput>
  }

  export type ProfileUpdateWithoutPostReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutPostReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type CommentCreateWithoutReactionsInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    notifications?: NotificationCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutReactionsInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutReactionsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
  }

  export type ProfileCreateWithoutCommentReactionsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutCommentReactionsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutCommentReactionsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutCommentReactionsInput, ProfileUncheckedCreateWithoutCommentReactionsInput>
  }

  export type CommentUpsertWithoutReactionsInput = {
    update: XOR<CommentUpdateWithoutReactionsInput, CommentUncheckedUpdateWithoutReactionsInput>
    create: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutReactionsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutReactionsInput, CommentUncheckedUpdateWithoutReactionsInput>
  }

  export type CommentUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ProfileUpsertWithoutCommentReactionsInput = {
    update: XOR<ProfileUpdateWithoutCommentReactionsInput, ProfileUncheckedUpdateWithoutCommentReactionsInput>
    create: XOR<ProfileCreateWithoutCommentReactionsInput, ProfileUncheckedCreateWithoutCommentReactionsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutCommentReactionsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutCommentReactionsInput, ProfileUncheckedUpdateWithoutCommentReactionsInput>
  }

  export type ProfileUpdateWithoutCommentReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutCommentReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileCreateWithoutConversationsOwnedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutConversationsOwnedInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutConversationsOwnedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutConversationsOwnedInput, ProfileUncheckedCreateWithoutConversationsOwnedInput>
  }

  export type ConversationParticipantCreateWithoutConversationInput = {
    id?: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutConversationMembersInput
  }

  export type ConversationParticipantUncheckedCreateWithoutConversationInput = {
    id?: string
    profileId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type ConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantCreateManyConversationInputEnvelope = {
    data: ConversationParticipantCreateManyConversationInput | ConversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    sender: ProfileCreateNestedOneWithoutMessagesInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
    notifications?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutConversationsOwnedInput = {
    update: XOR<ProfileUpdateWithoutConversationsOwnedInput, ProfileUncheckedUpdateWithoutConversationsOwnedInput>
    create: XOR<ProfileCreateWithoutConversationsOwnedInput, ProfileUncheckedCreateWithoutConversationsOwnedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutConversationsOwnedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutConversationsOwnedInput, ProfileUncheckedUpdateWithoutConversationsOwnedInput>
  }

  export type ProfileUpdateWithoutConversationsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutConversationsOwnedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    update: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<ConversationParticipantCreateWithoutConversationInput, ConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: ConversationParticipantWhereUniqueInput
    data: XOR<ConversationParticipantUpdateWithoutConversationInput, ConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type ConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: ConversationParticipantScalarWhereInput
    data: XOR<ConversationParticipantUpdateManyMutationInput, ConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ConversationCreateWithoutParticipantsInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutConversationsOwnedInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById?: string | null
    createdAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutParticipantsInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type ProfileCreateWithoutConversationMembersInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutConversationMembersInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutConversationMembersInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutConversationMembersInput, ProfileUncheckedCreateWithoutConversationMembersInput>
  }

  export type ConversationUpsertWithoutParticipantsInput = {
    update: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<ConversationCreateWithoutParticipantsInput, ConversationUncheckedCreateWithoutParticipantsInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutParticipantsInput, ConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type ConversationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutConversationsOwnedNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ProfileUpsertWithoutConversationMembersInput = {
    update: XOR<ProfileUpdateWithoutConversationMembersInput, ProfileUncheckedUpdateWithoutConversationMembersInput>
    create: XOR<ProfileCreateWithoutConversationMembersInput, ProfileUncheckedCreateWithoutConversationMembersInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutConversationMembersInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutConversationMembersInput, ProfileUncheckedUpdateWithoutConversationMembersInput>
  }

  export type ProfileUpdateWithoutConversationMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutConversationMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutConversationsOwnedInput
    participants?: ConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdById?: string | null
    createdAt?: Date | string
    participants?: ConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ProfileCreateWithoutMessagesInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutMessagesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMessagesInput, ProfileUncheckedCreateWithoutMessagesInput>
  }

  export type MessageReadCreateWithoutMessageInput = {
    readAt?: Date | string
    user: ProfileCreateNestedOneWithoutMessageReadsInput
  }

  export type MessageReadUncheckedCreateWithoutMessageInput = {
    userId: string
    readAt?: Date | string
  }

  export type MessageReadCreateOrConnectWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    create: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadCreateManyMessageInputEnvelope = {
    data: MessageReadCreateManyMessageInput | MessageReadCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutMessageInput = {
    id?: string
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    recipient: ProfileCreateNestedOneWithoutNotificationsInput
    actor?: ProfileCreateNestedOneWithoutNotificationsAsActorInput
    post?: PostCreateNestedOneWithoutNotificationsInput
    comment?: CommentCreateNestedOneWithoutNotificationsInput
    lineage?: LineageCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutMessageInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutMessageInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput>
  }

  export type NotificationCreateManyMessageInputEnvelope = {
    data: NotificationCreateManyMessageInput | NotificationCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutConversationsOwnedNestedInput
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ProfileUpsertWithoutMessagesInput = {
    update: XOR<ProfileUpdateWithoutMessagesInput, ProfileUncheckedUpdateWithoutMessagesInput>
    create: XOR<ProfileCreateWithoutMessagesInput, ProfileUncheckedCreateWithoutMessagesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMessagesInput, ProfileUncheckedUpdateWithoutMessagesInput>
  }

  export type ProfileUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type MessageReadUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    update: XOR<MessageReadUpdateWithoutMessageInput, MessageReadUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageReadCreateWithoutMessageInput, MessageReadUncheckedCreateWithoutMessageInput>
  }

  export type MessageReadUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageReadWhereUniqueInput
    data: XOR<MessageReadUpdateWithoutMessageInput, MessageReadUncheckedUpdateWithoutMessageInput>
  }

  export type MessageReadUpdateManyWithWhereWithoutMessageInput = {
    where: MessageReadScalarWhereInput
    data: XOR<MessageReadUpdateManyMutationInput, MessageReadUncheckedUpdateManyWithoutMessageInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutMessageInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutMessageInput, NotificationUncheckedUpdateWithoutMessageInput>
    create: XOR<NotificationCreateWithoutMessageInput, NotificationUncheckedCreateWithoutMessageInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutMessageInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutMessageInput, NotificationUncheckedUpdateWithoutMessageInput>
  }

  export type NotificationUpdateManyWithWhereWithoutMessageInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutMessageInput>
  }

  export type ProfileCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutNotificationsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutNotificationsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutNotificationsInput, ProfileUncheckedCreateWithoutNotificationsInput>
  }

  export type ProfileCreateWithoutNotificationsAsActorInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutNotificationsAsActorInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutNotificationsAsActorInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutNotificationsAsActorInput, ProfileUncheckedCreateWithoutNotificationsAsActorInput>
  }

  export type PostCreateWithoutNotificationsInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: ProfileCreateNestedOneWithoutPostsInput
    lineage?: LineageCreateNestedOneWithoutPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: PostReactionCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileCreateNestedManyWithoutPostInput
  }

  export type PostUncheckedCreateWithoutNotificationsInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: PostReactionUncheckedCreateNestedManyWithoutPostInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutPostInput
  }

  export type PostCreateOrConnectWithoutNotificationsInput = {
    where: PostWhereUniqueInput
    create: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
  }

  export type CommentCreateWithoutNotificationsInput = {
    id?: string
    content: string
    likeCount?: number
    createdAt?: Date | string
    post: PostCreateNestedOneWithoutCommentsInput
    author: ProfileCreateNestedOneWithoutCommentsInput
    parentComment?: CommentCreateNestedOneWithoutRepliesInput
    replies?: CommentCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutNotificationsInput = {
    id?: string
    postId: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
    replies?: CommentUncheckedCreateNestedManyWithoutParentCommentInput
    reactions?: CommentReactionUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutNotificationsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
  }

  export type LineageCreateWithoutNotificationsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy?: ProfileCreateNestedOneWithoutLineagesCreatedInput
    memberships?: LineageMembershipCreateNestedManyWithoutLineageInput
    posts?: PostCreateNestedManyWithoutLineageInput
  }

  export type LineageUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: LineageMembershipUncheckedCreateNestedManyWithoutLineageInput
    posts?: PostUncheckedCreateNestedManyWithoutLineageInput
  }

  export type LineageCreateOrConnectWithoutNotificationsInput = {
    where: LineageWhereUniqueInput
    create: XOR<LineageCreateWithoutNotificationsInput, LineageUncheckedCreateWithoutNotificationsInput>
  }

  export type MessageCreateWithoutNotificationsInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: ProfileCreateNestedOneWithoutMessagesInput
    reads?: MessageReadCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutNotificationsInput = {
    id?: string
    conversationId: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    reads?: MessageReadUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutNotificationsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutNotificationsInput, MessageUncheckedCreateWithoutNotificationsInput>
  }

  export type ProfileUpsertWithoutNotificationsInput = {
    update: XOR<ProfileUpdateWithoutNotificationsInput, ProfileUncheckedUpdateWithoutNotificationsInput>
    create: XOR<ProfileCreateWithoutNotificationsInput, ProfileUncheckedCreateWithoutNotificationsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutNotificationsInput, ProfileUncheckedUpdateWithoutNotificationsInput>
  }

  export type ProfileUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUpsertWithoutNotificationsAsActorInput = {
    update: XOR<ProfileUpdateWithoutNotificationsAsActorInput, ProfileUncheckedUpdateWithoutNotificationsAsActorInput>
    create: XOR<ProfileCreateWithoutNotificationsAsActorInput, ProfileUncheckedCreateWithoutNotificationsAsActorInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutNotificationsAsActorInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutNotificationsAsActorInput, ProfileUncheckedUpdateWithoutNotificationsAsActorInput>
  }

  export type ProfileUpdateWithoutNotificationsAsActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutNotificationsAsActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type PostUpsertWithoutNotificationsInput = {
    update: XOR<PostUpdateWithoutNotificationsInput, PostUncheckedUpdateWithoutNotificationsInput>
    create: XOR<PostCreateWithoutNotificationsInput, PostUncheckedCreateWithoutNotificationsInput>
    where?: PostWhereInput
  }

  export type PostUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: PostWhereInput
    data: XOR<PostUpdateWithoutNotificationsInput, PostUncheckedUpdateWithoutNotificationsInput>
  }

  export type PostUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentUpsertWithoutNotificationsInput = {
    update: XOR<CommentUpdateWithoutNotificationsInput, CommentUncheckedUpdateWithoutNotificationsInput>
    create: XOR<CommentCreateWithoutNotificationsInput, CommentUncheckedCreateWithoutNotificationsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutNotificationsInput, CommentUncheckedUpdateWithoutNotificationsInput>
  }

  export type CommentUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type LineageUpsertWithoutNotificationsInput = {
    update: XOR<LineageUpdateWithoutNotificationsInput, LineageUncheckedUpdateWithoutNotificationsInput>
    create: XOR<LineageCreateWithoutNotificationsInput, LineageUncheckedCreateWithoutNotificationsInput>
    where?: LineageWhereInput
  }

  export type LineageUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: LineageWhereInput
    data: XOR<LineageUpdateWithoutNotificationsInput, LineageUncheckedUpdateWithoutNotificationsInput>
  }

  export type LineageUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: ProfileUpdateOneWithoutLineagesCreatedNestedInput
    memberships?: LineageMembershipUpdateManyWithoutLineageNestedInput
    posts?: PostUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput
    posts?: PostUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type MessageUpsertWithoutNotificationsInput = {
    update: XOR<MessageUpdateWithoutNotificationsInput, MessageUncheckedUpdateWithoutNotificationsInput>
    create: XOR<MessageCreateWithoutNotificationsInput, MessageUncheckedCreateWithoutNotificationsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutNotificationsInput, MessageUncheckedUpdateWithoutNotificationsInput>
  }

  export type MessageUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: ProfileUpdateOneRequiredWithoutMessagesNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type ProfileInterestCreateWithoutInterestInput = {
    createdAt?: Date | string
    user: ProfileCreateNestedOneWithoutInterestsInput
  }

  export type ProfileInterestUncheckedCreateWithoutInterestInput = {
    userId: string
    createdAt?: Date | string
  }

  export type ProfileInterestCreateOrConnectWithoutInterestInput = {
    where: ProfileInterestWhereUniqueInput
    create: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput>
  }

  export type ProfileInterestCreateManyInterestInputEnvelope = {
    data: ProfileInterestCreateManyInterestInput | ProfileInterestCreateManyInterestInput[]
    skipDuplicates?: boolean
  }

  export type ProfileInterestUpsertWithWhereUniqueWithoutInterestInput = {
    where: ProfileInterestWhereUniqueInput
    update: XOR<ProfileInterestUpdateWithoutInterestInput, ProfileInterestUncheckedUpdateWithoutInterestInput>
    create: XOR<ProfileInterestCreateWithoutInterestInput, ProfileInterestUncheckedCreateWithoutInterestInput>
  }

  export type ProfileInterestUpdateWithWhereUniqueWithoutInterestInput = {
    where: ProfileInterestWhereUniqueInput
    data: XOR<ProfileInterestUpdateWithoutInterestInput, ProfileInterestUncheckedUpdateWithoutInterestInput>
  }

  export type ProfileInterestUpdateManyWithWhereWithoutInterestInput = {
    where: ProfileInterestScalarWhereInput
    data: XOR<ProfileInterestUpdateManyMutationInput, ProfileInterestUncheckedUpdateManyWithoutInterestInput>
  }

  export type ProfileCreateWithoutInterestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadCreateNestedManyWithoutUserInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutInterestsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    messageReads?: MessageReadUncheckedCreateNestedManyWithoutUserInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutInterestsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
  }

  export type InterestCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type InterestUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
  }

  export type InterestCreateOrConnectWithoutUsersInput = {
    where: InterestWhereUniqueInput
    create: XOR<InterestCreateWithoutUsersInput, InterestUncheckedCreateWithoutUsersInput>
  }

  export type ProfileUpsertWithoutInterestsInput = {
    update: XOR<ProfileUpdateWithoutInterestsInput, ProfileUncheckedUpdateWithoutInterestsInput>
    create: XOR<ProfileCreateWithoutInterestsInput, ProfileUncheckedCreateWithoutInterestsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutInterestsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutInterestsInput, ProfileUncheckedUpdateWithoutInterestsInput>
  }

  export type ProfileUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutInterestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    messageReads?: MessageReadUncheckedUpdateManyWithoutUserNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type InterestUpsertWithoutUsersInput = {
    update: XOR<InterestUpdateWithoutUsersInput, InterestUncheckedUpdateWithoutUsersInput>
    create: XOR<InterestCreateWithoutUsersInput, InterestUncheckedCreateWithoutUsersInput>
    where?: InterestWhereInput
  }

  export type InterestUpdateToOneWithWhereWithoutUsersInput = {
    where?: InterestWhereInput
    data: XOR<InterestUpdateWithoutUsersInput, InterestUncheckedUpdateWithoutUsersInput>
  }

  export type InterestUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InterestUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateWithoutReadsInput = {
    id?: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
    sender: ProfileCreateNestedOneWithoutMessagesInput
    notifications?: NotificationCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutReadsInput = {
    id?: string
    conversationId: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutReadsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
  }

  export type ProfileCreateWithoutMessageReadsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestCreateNestedManyWithoutUserInput
    posts?: PostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    postReactions?: PostReactionCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantCreateNestedManyWithoutProfileInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipCreateNestedManyWithoutAddedByInput
  }

  export type ProfileUncheckedCreateWithoutMessageReadsInput = {
    id?: string
    userId: string
    firstName?: string
    lastName?: string
    username: string
    gender?: string | null
    dateOfBirth?: Date | string | null
    country?: string | null
    city?: string | null
    district?: string | null
    location?: string
    bio?: string
    countryCode?: string | null
    avatarUrl?: string | null
    coverUrl?: string | null
    lineageMainSurname?: string | null
    lineageRootVillage?: string | null
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    interests?: ProfileInterestUncheckedCreateNestedManyWithoutUserInput
    posts?: PostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    postReactions?: PostReactionUncheckedCreateNestedManyWithoutProfileInput
    settings?: ProfileSettingsUncheckedCreateNestedOneWithoutProfileInput
    lineageMemberships?: LineageMembershipUncheckedCreateNestedManyWithoutProfileInput
    kinshipsA?: KinshipUncheckedCreateNestedManyWithoutProfileAInput
    kinshipsB?: KinshipUncheckedCreateNestedManyWithoutProfileBInput
    commentReactions?: CommentReactionUncheckedCreateNestedManyWithoutProfileInput
    followsAsFollower?: FollowUncheckedCreateNestedManyWithoutFollowerInput
    followsAsFollowee?: FollowUncheckedCreateNestedManyWithoutFolloweeInput
    blocksAsBlocker?: BlockUncheckedCreateNestedManyWithoutBlockerInput
    blocksAsBlocked?: BlockUncheckedCreateNestedManyWithoutBlockedInput
    mutesAsMuter?: MuteUncheckedCreateNestedManyWithoutMuterInput
    mutesAsMuted?: MuteUncheckedCreateNestedManyWithoutMutedInput
    conversationsOwned?: ConversationUncheckedCreateNestedManyWithoutCreatedByInput
    conversationMembers?: ConversationParticipantUncheckedCreateNestedManyWithoutProfileInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    notificationsAsActor?: NotificationUncheckedCreateNestedManyWithoutActorInput
    lineagesCreated?: LineageUncheckedCreateNestedManyWithoutCreatedByInput
    lineageMembershipsAdded?: LineageMembershipUncheckedCreateNestedManyWithoutAddedByInput
  }

  export type ProfileCreateOrConnectWithoutMessageReadsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutMessageReadsInput, ProfileUncheckedCreateWithoutMessageReadsInput>
  }

  export type MessageUpsertWithoutReadsInput = {
    update: XOR<MessageUpdateWithoutReadsInput, MessageUncheckedUpdateWithoutReadsInput>
    create: XOR<MessageCreateWithoutReadsInput, MessageUncheckedCreateWithoutReadsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutReadsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutReadsInput, MessageUncheckedUpdateWithoutReadsInput>
  }

  export type MessageUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: ProfileUpdateOneRequiredWithoutMessagesNestedInput
    notifications?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type ProfileUpsertWithoutMessageReadsInput = {
    update: XOR<ProfileUpdateWithoutMessageReadsInput, ProfileUncheckedUpdateWithoutMessageReadsInput>
    create: XOR<ProfileCreateWithoutMessageReadsInput, ProfileUncheckedCreateWithoutMessageReadsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutMessageReadsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutMessageReadsInput, ProfileUncheckedUpdateWithoutMessageReadsInput>
  }

  export type ProfileUpdateWithoutMessageReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUpdateManyWithoutUserNestedInput
    posts?: PostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    postReactions?: PostReactionUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileUncheckedUpdateWithoutMessageReadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    district?: NullableStringFieldUpdateOperationsInput | string | null
    location?: StringFieldUpdateOperationsInput | string
    bio?: StringFieldUpdateOperationsInput | string
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    coverUrl?: NullableStringFieldUpdateOperationsInput | string | null
    lineageMainSurname?: NullableStringFieldUpdateOperationsInput | string | null
    lineageRootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interests?: ProfileInterestUncheckedUpdateManyWithoutUserNestedInput
    posts?: PostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    postReactions?: PostReactionUncheckedUpdateManyWithoutProfileNestedInput
    settings?: ProfileSettingsUncheckedUpdateOneWithoutProfileNestedInput
    lineageMemberships?: LineageMembershipUncheckedUpdateManyWithoutProfileNestedInput
    kinshipsA?: KinshipUncheckedUpdateManyWithoutProfileANestedInput
    kinshipsB?: KinshipUncheckedUpdateManyWithoutProfileBNestedInput
    commentReactions?: CommentReactionUncheckedUpdateManyWithoutProfileNestedInput
    followsAsFollower?: FollowUncheckedUpdateManyWithoutFollowerNestedInput
    followsAsFollowee?: FollowUncheckedUpdateManyWithoutFolloweeNestedInput
    blocksAsBlocker?: BlockUncheckedUpdateManyWithoutBlockerNestedInput
    blocksAsBlocked?: BlockUncheckedUpdateManyWithoutBlockedNestedInput
    mutesAsMuter?: MuteUncheckedUpdateManyWithoutMuterNestedInput
    mutesAsMuted?: MuteUncheckedUpdateManyWithoutMutedNestedInput
    conversationsOwned?: ConversationUncheckedUpdateManyWithoutCreatedByNestedInput
    conversationMembers?: ConversationParticipantUncheckedUpdateManyWithoutProfileNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    notificationsAsActor?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    lineagesCreated?: LineageUncheckedUpdateManyWithoutCreatedByNestedInput
    lineageMembershipsAdded?: LineageMembershipUncheckedUpdateManyWithoutAddedByNestedInput
  }

  export type ProfileInterestCreateManyUserInput = {
    interestId: string
    createdAt?: Date | string
  }

  export type PostCreateManyAuthorInput = {
    id?: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    lineageId?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    postId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    conversationId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type MessageReadCreateManyUserInput = {
    messageId: string
    readAt?: Date | string
  }

  export type PostReactionCreateManyProfileInput = {
    id?: string
    postId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type LineageMembershipCreateManyProfileInput = {
    id?: string
    lineageId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipCreateManyProfileAInput = {
    id?: string
    profileIdB: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type KinshipCreateManyProfileBInput = {
    id?: string
    profileIdA: string
    relationAtoB: $Enums.KinshipType
    verified?: boolean
    verifiedById?: string | null
    createdAt?: Date | string
  }

  export type CommentReactionCreateManyProfileInput = {
    id?: string
    commentId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type FollowCreateManyFollowerInput = {
    id?: string
    followeeId: string
    createdAt?: Date | string
  }

  export type FollowCreateManyFolloweeInput = {
    id?: string
    followerId: string
    createdAt?: Date | string
  }

  export type BlockCreateManyBlockerInput = {
    id?: string
    blockedId: string
    createdAt?: Date | string
  }

  export type BlockCreateManyBlockedInput = {
    id?: string
    blockerId: string
    createdAt?: Date | string
  }

  export type MuteCreateManyMuterInput = {
    id?: string
    mutedId: string
    createdAt?: Date | string
  }

  export type MuteCreateManyMutedInput = {
    id?: string
    muterId: string
    createdAt?: Date | string
  }

  export type ConversationCreateManyCreatedByInput = {
    id?: string
    isGroup?: boolean
    title?: string | null
    createdAt?: Date | string
  }

  export type ConversationParticipantCreateManyProfileInput = {
    id?: string
    conversationId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateManyActorInput = {
    id?: string
    recipientId: string
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type LineageCreateManyCreatedByInput = {
    id?: string
    name: string
    type?: $Enums.LineageType
    primarySurname?: string | null
    rootVillage?: string | null
    rootRegion?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LineageMembershipCreateManyAddedByInput = {
    id?: string
    lineageId: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    createdAt?: Date | string
  }

  export type ProfileInterestUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interest?: InterestUpdateOneRequiredWithoutUsersNestedInput
  }

  export type ProfileInterestUncheckedUpdateWithoutUserInput = {
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestUncheckedUpdateManyWithoutUserInput = {
    interestId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineage?: LineageUpdateOneWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUpdateWithoutUserInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: MessageUpdateOneRequiredWithoutReadsNestedInput
  }

  export type MessageReadUncheckedUpdateWithoutUserInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyWithoutUserInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type PostReactionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineage?: LineageUpdateOneRequiredWithoutMembershipsNestedInput
    addedBy?: ProfileUpdateOneWithoutLineageMembershipsAddedNestedInput
  }

  export type LineageMembershipUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipUpdateWithoutProfileAInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileB?: ProfileUpdateOneRequiredWithoutKinshipsBNestedInput
  }

  export type KinshipUncheckedUpdateWithoutProfileAInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdB?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipUncheckedUpdateManyWithoutProfileAInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdB?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipUpdateWithoutProfileBInput = {
    id?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileA?: ProfileUpdateOneRequiredWithoutKinshipsANestedInput
  }

  export type KinshipUncheckedUpdateWithoutProfileBInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdA?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KinshipUncheckedUpdateManyWithoutProfileBInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileIdA?: StringFieldUpdateOperationsInput | string
    relationAtoB?: EnumKinshipTypeFieldUpdateOperationsInput | $Enums.KinshipType
    verified?: BoolFieldUpdateOperationsInput | boolean
    verifiedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type CommentReactionUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    commentId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    followee?: ProfileUpdateOneRequiredWithoutFollowsAsFolloweeNestedInput
  }

  export type FollowUncheckedUpdateWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFollowerInput = {
    id?: StringFieldUpdateOperationsInput | string
    followeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUpdateWithoutFolloweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    follower?: ProfileUpdateOneRequiredWithoutFollowsAsFollowerNestedInput
  }

  export type FollowUncheckedUpdateWithoutFolloweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FollowUncheckedUpdateManyWithoutFolloweeInput = {
    id?: StringFieldUpdateOperationsInput | string
    followerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocked?: ProfileUpdateOneRequiredWithoutBlocksAsBlockedNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockerInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUpdateWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blocker?: ProfileUpdateOneRequiredWithoutBlocksAsBlockerNestedInput
  }

  export type BlockUncheckedUpdateWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockUncheckedUpdateManyWithoutBlockedInput = {
    id?: StringFieldUpdateOperationsInput | string
    blockerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUpdateWithoutMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    muted?: ProfileUpdateOneRequiredWithoutMutesAsMutedNestedInput
  }

  export type MuteUncheckedUpdateWithoutMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    mutedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUncheckedUpdateManyWithoutMuterInput = {
    id?: StringFieldUpdateOperationsInput | string
    mutedId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUpdateWithoutMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    muter?: ProfileUpdateOneRequiredWithoutMutesAsMuterNestedInput
  }

  export type MuteUncheckedUpdateWithoutMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MuteUncheckedUpdateManyWithoutMutedInput = {
    id?: StringFieldUpdateOperationsInput | string
    muterId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    isGroup?: BoolFieldUpdateOperationsInput | boolean
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUpdateManyWithoutLineageNestedInput
    posts?: PostUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: LineageMembershipUncheckedUpdateManyWithoutLineageNestedInput
    posts?: PostUncheckedUpdateManyWithoutLineageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutLineageNestedInput
  }

  export type LineageUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumLineageTypeFieldUpdateOperationsInput | $Enums.LineageType
    primarySurname?: NullableStringFieldUpdateOperationsInput | string | null
    rootVillage?: NullableStringFieldUpdateOperationsInput | string | null
    rootRegion?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUpdateWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lineage?: LineageUpdateOneRequiredWithoutMembershipsNestedInput
    profile?: ProfileUpdateOneRequiredWithoutLineageMembershipsNestedInput
  }

  export type LineageMembershipUncheckedUpdateWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUncheckedUpdateManyWithoutAddedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    lineageId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipCreateManyLineageInput = {
    id?: string
    profileId: string
    role?: $Enums.LineageRole
    generation?: number | null
    isPrimaryLineage?: boolean
    addedById?: string | null
    createdAt?: Date | string
  }

  export type PostCreateManyLineageInput = {
    id?: string
    profileId: string
    content?: string | null
    visibility?: $Enums.PostVisibility
    locationText?: string | null
    commentCount?: number
    likeCount?: number
    shareCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyLineageInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type LineageMembershipUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutLineageMembershipsNestedInput
    addedBy?: ProfileUpdateOneWithoutLineageMembershipsAddedNestedInput
  }

  export type LineageMembershipUncheckedUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LineageMembershipUncheckedUpdateManyWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: EnumLineageRoleFieldUpdateOperationsInput | $Enums.LineageRole
    generation?: NullableIntFieldUpdateOperationsInput | number | null
    isPrimaryLineage?: BoolFieldUpdateOperationsInput | boolean
    addedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: ProfileUpdateOneRequiredWithoutPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutPostNestedInput
    notifications?: NotificationUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: PostReactionUncheckedUpdateManyWithoutPostNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutPostNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutPostNestedInput
  }

  export type PostUncheckedUpdateManyWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    locationText?: NullableStringFieldUpdateOperationsInput | string | null
    commentCount?: IntFieldUpdateOperationsInput | number
    likeCount?: IntFieldUpdateOperationsInput | number
    shareCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
    actor?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutLineageInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    profileId: string
    parentCommentId?: string | null
    content: string
    likeCount?: number
    createdAt?: Date | string
  }

  export type PostReactionCreateManyPostInput = {
    id?: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type MediaFileCreateManyPostInput = {
    id?: string
    type: $Enums.MediaType
    url: string
    mimeType: string
    width?: number | null
    height?: number | null
    sizeBytes: bigint | number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyPostInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    commentId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: CommentUpdateOneWithoutRepliesNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    parentCommentId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutPostReactionsNestedInput
  }

  export type PostReactionUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostReactionUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumMediaTypeFieldUpdateOperationsInput | $Enums.MediaType
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    sizeBytes?: BigIntFieldUpdateOperationsInput | bigint | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
    actor?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyParentCommentInput = {
    id?: string
    postId: string
    profileId: string
    content: string
    likeCount?: number
    createdAt?: Date | string
  }

  export type CommentReactionCreateManyCommentInput = {
    id?: string
    profileId: string
    type?: $Enums.ReactionType
    createdAt?: Date | string
  }

  export type NotificationCreateManyCommentInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    lineageId?: string | null
    messageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type CommentUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: PostUpdateOneRequiredWithoutCommentsNestedInput
    author?: ProfileUpdateOneRequiredWithoutCommentsNestedInput
    replies?: CommentUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: CommentUncheckedUpdateManyWithoutParentCommentNestedInput
    reactions?: CommentReactionUncheckedUpdateManyWithoutCommentNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutParentCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    likeCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutCommentReactionsNestedInput
  }

  export type CommentReactionUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentReactionUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
    actor?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
    message?: MessageUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    messageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantCreateManyConversationInput = {
    id?: string
    profileId: string
    role?: string
    lastReadAt?: Date | string | null
    joinedAt?: Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    senderId: string
    content?: string | null
    mediaUrl?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    timestamp?: Date | string
  }

  export type ConversationParticipantUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutConversationMembersNestedInput
  }

  export type ConversationParticipantUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    lastReadAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: ProfileUpdateOneRequiredWithoutMessagesNestedInput
    reads?: MessageReadUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    reads?: MessageReadUncheckedUpdateManyWithoutMessageNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadCreateManyMessageInput = {
    userId: string
    readAt?: Date | string
  }

  export type NotificationCreateManyMessageInput = {
    id?: string
    recipientId: string
    actorId?: string | null
    type: $Enums.NotificationType
    postId?: string | null
    commentId?: string | null
    lineageId?: string | null
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageReadUpdateWithoutMessageInput = {
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ProfileUpdateOneRequiredWithoutMessageReadsNestedInput
  }

  export type MessageReadUncheckedUpdateWithoutMessageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageReadUncheckedUpdateManyWithoutMessageInput = {
    userId?: StringFieldUpdateOperationsInput | string
    readAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: ProfileUpdateOneRequiredWithoutNotificationsNestedInput
    actor?: ProfileUpdateOneWithoutNotificationsAsActorNestedInput
    post?: PostUpdateOneWithoutNotificationsNestedInput
    comment?: CommentUpdateOneWithoutNotificationsNestedInput
    lineage?: LineageUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    lineageId?: NullableStringFieldUpdateOperationsInput | string | null
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestCreateManyInterestInput = {
    userId: string
    createdAt?: Date | string
  }

  export type ProfileInterestUpdateWithoutInterestInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: ProfileUpdateOneRequiredWithoutInterestsNestedInput
  }

  export type ProfileInterestUncheckedUpdateWithoutInterestInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileInterestUncheckedUpdateManyWithoutInterestInput = {
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}